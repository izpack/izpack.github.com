<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [izpack-changes] r2046 - in izpack-src/tags: . 3.11.0	3.11.0/src/dist-files 3.11.0/src/lib/com/izforge/izpack/compiler	3.11.0/src/lib/com/izforge/izpack/installer	3.11.0/src/lib/com/izforge/izpack/io	3.11.0/src/lib/com/izforge/izpack/panels	3.11.0/src/lib/com/izforge/izpack/util
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:izpack-changes%40lists.berlios.de?Subject=%5Bizpack-changes%5D%20r2046%20-%20in%20izpack-src/tags%3A%20.%203.11.0%0A%093.11.0/src/dist-files%203.11.0/src/lib/com/izforge/izpack/compiler%0A%093.11.0/src/lib/com/izforge/izpack/installer%0A%093.11.0/src/lib/com/izforge/izpack/io%0A%093.11.0/src/lib/com/izforge/izpack/panels%0A%093.11.0/src/lib/com/izforge/izpack/util&In-Reply-To=">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000791.html">
   <LINK REL="Next"  HREF="000793.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[izpack-changes] r2046 - in izpack-src/tags: . 3.11.0	3.11.0/src/dist-files 3.11.0/src/lib/com/izforge/izpack/compiler	3.11.0/src/lib/com/izforge/izpack/installer	3.11.0/src/lib/com/izforge/izpack/io	3.11.0/src/lib/com/izforge/izpack/panels	3.11.0/src/lib/com/izforge/izpack/util</H1>
    <B>noreply at berlios.de</B> 
    <A HREF="mailto:izpack-changes%40lists.berlios.de?Subject=%5Bizpack-changes%5D%20r2046%20-%20in%20izpack-src/tags%3A%20.%203.11.0%0A%093.11.0/src/dist-files%203.11.0/src/lib/com/izforge/izpack/compiler%0A%093.11.0/src/lib/com/izforge/izpack/installer%0A%093.11.0/src/lib/com/izforge/izpack/io%0A%093.11.0/src/lib/com/izforge/izpack/panels%0A%093.11.0/src/lib/com/izforge/izpack/util&In-Reply-To="
       TITLE="[izpack-changes] r2046 - in izpack-src/tags: . 3.11.0	3.11.0/src/dist-files 3.11.0/src/lib/com/izforge/izpack/compiler	3.11.0/src/lib/com/izforge/izpack/installer	3.11.0/src/lib/com/izforge/izpack/io	3.11.0/src/lib/com/izforge/izpack/panels	3.11.0/src/lib/com/izforge/izpack/util">noreply at berlios.de
       </A><BR>
    <I>Tue Feb 12 11:03:17 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000791.html">[izpack-changes] r2045 - izpack-src/trunk/src/dist-files
</A></li>
        <LI>Next message: <A HREF="000793.html">[izpack-changes] r2047 - izpack-utils/tags
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#792">[ date ]</a>
              <a href="thread.html#792">[ thread ]</a>
              <a href="subject.html#792">[ subject ]</a>
              <a href="author.html#792">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jponge
Date: 2008-02-12 11:03:02 +0100 (Tue, 12 Feb 2008)
New Revision: 2046

Added:
   izpack-src/tags/3.11.0/
   izpack-src/tags/3.11.0/Versions.txt
   izpack-src/tags/3.11.0/src/dist-files/IzPack-install.xml
   izpack-src/tags/3.11.0/src/dist-files/Unix_shortcutSpec.xml
   izpack-src/tags/3.11.0/src/dist-files/shortcutSpec.xml
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/CompilerConfig.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/IPackager.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/MultiVolumePackager.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/Packager.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/PackagerFactory.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/CompileWorker.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/InstallerBase.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/Unpacker.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/UnpackerFactory.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/WebRepositoryAccessor.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/io/FileSpanningInputStream.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/DataCheckPanel.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/PasswordGroup.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/TextInputField.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/util/FileUtil.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/util/OsConstraint.java
Removed:
   izpack-src/tags/3.11.0/Versions.txt
   izpack-src/tags/3.11.0/src/dist-files/IzPack-install.xml
   izpack-src/tags/3.11.0/src/dist-files/Unix_shortcutSpec.xml
   izpack-src/tags/3.11.0/src/dist-files/shortcutSpec.xml
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/CompilerConfig.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/IPackager.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/MultiVolumePackager.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/Packager.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/PackagerFactory.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/CompileWorker.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/InstallerBase.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/Unpacker.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/UnpackerFactory.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/WebRepositoryAccessor.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/io/FileSpanningInputStream.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/DataCheckPanel.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/PasswordGroup.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/TextInputField.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/util/FileUtil.java
   izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/util/OsConstraint.java
Log:
Tag for 3.11.0


Copied: izpack-src/tags/3.11.0 (from rev 2042, izpack-src/trunk)

Deleted: izpack-src/tags/3.11.0/Versions.txt
===================================================================
--- izpack-src/trunk/Versions.txt	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/Versions.txt	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,1116 +0,0 @@
-[ The list of the different public versions of IzPack ]
-
-  &gt; 3.11.0 (TBD)
-
-- Added ignore as possible value for failure argument in executables (Dennis Reil)
-- Added Conditional expressions (Dennis Reil)
-- Fixed selection of default language in LanguageSelectionDialog (Dennis Reil)
-- Fixed RegularExpressionValidator (Dennis Reil)
-- Added corrupt volume detection (Dennis Reil)
-- Added file and dir fields in UserInputPanel (Dennis Reil)
-- Modifications to keep original file dates and times in _dist directory and in the installer jar
-  (Ari Voutilainen via Julien Ponge)
-- UserInputPanel: force users to select an existing directory or file
-  (Michael Hagedorn via Julien Ponge)
-- Default path for JDKPathPanel will be got from Windows registry if possible (Klaus Bartz)  
-- New Farsi langpack (Parastou Kohvaei via Klaus Bartz)
-- Dynamic control re-rendering (show/hide) on radio and checkbox selection events (Vladimir Ralev)
-- Locale support of Shortcut specification file (Klaus Bartz using a hint of Loic)
-- Enabled distributed pack-definitions (Hans Aikema based on patch by Syed Khadeer)
-- Update of the Liquid and JGoodies look and feel libraries (Julien Ponge).
-- Support for the toned-down Substance look and feel themes (Julien Ponge).
-- Added main frame GUI properties 'headingForegroundColor' and 'headingImageBorderSize'
-  (Daniel Azarov, Exadel Inc via Vladimir Ralev)
-- Unix shortcuts fixes (Vladimir Ralev)
-- TreePacksPanel, a hierarchical packs selection panel (Vladimir Ralev)
-- HTMLInfoPanel to launch links in external browser on any Windows and Linux (Vladimir Ralev)
-- PacksModel fix (Markus Schlegel via Julien Ponge).
-- Workaround for layout problems in UserInputPanel when clicking previous button (Dennis Reil)
-- Nimbus look and feel support (Julien Ponge)
-- Try to load a 64-bit dll if the 32-bit load fails and 64-bit ShellLink (Vladimir Ralev)
-- File / fileset Os constraints: addition of a JRE version test (e.g., &lt;os jre=&quot;1.5&quot; /&gt;)
-  (Gilles Wiart via Julien Ponge)
-- Hungarian langpack update (Kerekes Balazs via Julien Ponge)
-- InstallGroupPanel: sortable InstallGroups (Markus Schlegel via Julien Ponge)
-- chmod only applies and executes when file type is set to bin (Andreas Guenther via Julien Ponge)
-- LayoutManager bug at handling EditorPanes fixed (width to small) (Klaus Bartz)
-- Fixed NPE when ypcat not installed on linux. (Dick Hollenbeck via Marc Eppelmann)
-- Updated web installer (Vladimir Ralev)
-- Unix shortcuts allow programGroup icon. Fixed appearing multiple times bug in Fedora 7.
-  (Vladimir Ralev)
-- TreePacksPanel with more user-friendly click logic. Added automated installer helper.
-  (Vladimir Ralev)
-- Updated installation listener interface (Vladimir Ralev)
-- Re-entrant ShortcutPanel (WALLEM Pascal, AWL-T&amp;P via Vladimir Ralev)
-- FileExecutor: allow Java classpath specification in targetfile attribute using
-  either : or ; delimiter, and support classpath loading of all jar files within a given folder,
-  e.g. targetfile=&quot;$INSTALL_PATH/lib/allMyJars (Andreas Guenther via Julien Ponge)
-- Support of a new 'uninstall' (yes/no) attribute on pack elements to allow certains pack to be
-  kept on uninstallation (Gildas Le Louarn via Julien Ponge)
-- Uninstaller: in GUI mode, users don't see the 'force uninstallation' checkbox unless the
-  '-x' command-line flag is used (Gildas Le Louarn via Julien Ponge)
-- Fixed wrong display size of really big packs (Dennis Reil) 
-- Tango icons (Julien Ponge)
-- Refreshed installer border images (Julien Ponge)
-- Fixed conditions in PacksPanel/PacksModel (Dennis Reil)
-- Added conditions for jobs in ProcessPanel (Dennis Reil) 
-- Fixed wrong required size of packs (Dennis Reil)
-- Added condition-attribute to pack element in installer.xml (Dennis Reil)
-- Spanish langpack update (Sergio Banos Calvo via Julien Ponge)
-- Various fixes (Loic via Julien Ponge)
-- Added conditions-definition to installer xml (Dennis Reil)
-- Added dynamic variables (Dennis Reil)
-- IzPack installer: check that users are actually launching the latest version by checking from
-  the <A HREF="https://izpack.github.io/">https://izpack.github.io/</A> website (Julien Ponge)
-- Added debugging for variables and conditions (Dennis Reil)
-- Added built-in conditions (Dennis Reil)
-- ProcessPanel: make the progress bar advance after the current process has run, not before
-  (Julien Ponge)
-- JDKPathPanel: Mac OS X fix (Julien Ponge)
-- PathInputPanel: add some space between the text and the input field (Julien Ponge)
-- Installer files: support of a 'requiresjdk' element to specify wether a JDK is required for the
-  software to install (instead of just a JRE). This is a light test performed like 'javaversion'
-  before the installer frame appears. (Julien Ponge)
-- Support of XInclude-like constructs (Matthew Fudge, Volantis Systems Ltd.
-  via Julien Ponge)
-- Spanish langpack update (Sergio Banos Calvo via Julien Ponge)
-- OsVersion class: detect X86, PPC and SPARC architectures (Julien Ponge)
-- RulesEngines: new built-in rules: izpack.solarisinstall.x86 and izpack.solarisinstall.sparc (Julien Ponge)
-- New Galician translation (Xabier Cancela via Julien Ponge)
-- build.xml: include the new L&amp;F jars (Jeff Gordon via Julien Ponge)
-- FileExecutor: fix a blank dialog prompting the user to continue if there's a failure (Jeff Gordon via Julien Ponge)
-- Italian translation update (Roberto Boriotti, Sylvain Gaudard via Julien Ponge)
-- PacksPanelAutomationHelper fix (Jeff Gordon via Julien Ponge)
-- 'parsexml' attribute for resources (Matthew Fudge via Julien Ponge)
-- InstallationGroupPanel UI improvements (Jeff Gordon via Julien Ponge)
-- HTMLInfoPanel: open external links in a web browser on Mac OS X as well (Alexander Maslov via Julien Ponge)
-- UserInputPanel: some variables were not saved for silent installers (Piotr Skowronek via Julien Ponge)
-- Text fields now can support validators (Piotr Skowronek via Julien Ponge)
-- UserInputPanel: substitution support for text fields (Piotr Skowronek via Julien Ponge)
-- TextInputField: Vertical layout issue fixed. (Jeff Gordon)
-- RegularExpressionValidator: Added ability to use with password fields. (Jeff Gordon)
-- PasswordEqualityValidator: Implementation of sample validator for use in any installer. 
-  Shows how to get at validator parameters as well. (Jeff Gordon)
-- PasswordKeystoreValidator: Validates keystore and/or key access using password field. (Jeff Gordon)
-- CompilerConfig: Changed uninstaller name to allow file name without jar extension. (Jeff Gordon)
-- UserPathPanel: Implemented copy of PathPanel as an alternative to dir type in UserInputPanel. (Jeff Gordon)
-- ValidatorContainer: Added supporting class for using multiple validators. (Jeff Gordon)
-- PasswordGroup: Added usage of ValidatorContainer to support multiple validators. (Jeff Gordon)
-- UserInputPanel: Changes to support multiple validators in password field and better error messages. (Jeff Gordon)
-- build.xml: Added ValidatorContainer and section for UserPathPanel. (Jeff Gordon)
-- eng.xml: Grammatical corrections, added UserPathPanel headline, messages, and captions,
-  added UserInputPanel.dir.* messages and captions, added UserInputPanel.file.* messages and captions.
-  (Need to add/test with alternative lang packs)  (Jeff Gordon)
-- PacksPanelBase: the packs would be selected / deselected on any list event (e.g., by navigating using the keys).
-  This funky behavior has been fixed (Julien Ponge).
-- Changed File.toURL() to File.toURI().toURL() to get rid of deprecation messages in Java 6. (Jeff Gordon)
-- ProcessPanel: the installation success is set to false in case an error has occurred (Julien Ponge)
-- VariableSubstitutor: parameters can also contain dashes (without need to use braces) (Piotr Skowronek)
-- IzPack is now a Codehaus project
-
-  &gt; 3.10.2 (build 2007.05.11)
-
-- Vista/Java6 fixes (Stefan Wachter via Julien Ponge)
-- Dutch Langpack fixes (Hans Aikema)
-- Fix NPE for pack.id == null in dependencies/excludes (Hans Aikema)
-- Indonesian Langpack fixes (Thomas Santosa via Hans Aikema)
-- UserInputPanel and InstallerFrame: enable the next button for search dialogs (Michael Hagedorn via Julien Ponge)
-- VariableSubstitutor: new Java source files support (Max Fedorov via Julien Ponge)
-- French langpack updates (Loic, via Julien Ponge)
-- Documentation update (Scott Plante via Julien Ponge)
-- AutomatedUninstaller.writeUninstallData() out of sync with InstallerFrame fixed (Marius Nicolae via Marc Eppelmann)
-- Finnish langpack updates (Ari Voutilainen via Julien Ponge)
-
-  &gt; 3.10.1 (build 2007.03.29)
-
-- Fixed NPE for pack.id == null (Fabrice Mirabile)
-- Packages that are not marked as preselected must also be removed from the selectedPacks
-  (Martina Angela Albrecht, via Fabrice Mirabile)
-- FreeDesktop XDG standard support for Gnome and KDE shortcuts support
-  (Vladimir Ralev via Julien Ponge)
-- Workaround for a Sun bug in Java 6 which crashes the installer in some non-english locales,
-  see <A HREF="http://jira.jboss.com/jira/browse/JBINSTALL-232">http://jira.jboss.com/jira/browse/JBINSTALL-232</A> (Vladimir Ralev)
-- Replaced the default checkbox icons in Gnome/KDE since they do not grey-out when disabled
-  as notes in the helper label. This change is only effective for UNIX. (Vladimir Ralev)
-- Added localization support for column names in InstallationGroupPanel
-  (Markus Schlegel via Vladimir Ralev)
-- Finnish langpack updates (Ari Voutilainen via Julien Ponge)
-- Fix: Variables assigned by UserInputPanel are not available when the next page
-  nagivations rules are evaluated. <A HREF="http://jira.jboss.com/jira/browse/JBINSTALL-248">http://jira.jboss.com/jira/browse/JBINSTALL-248</A>
-  (Vladimir Ralev)
-- Fixed an XML error in the French langpack. (Julien Ponge, reported by Ari Voutilainen).
-- Compile listeners are included in izevent.jar (Julien Ponge).
-- PacksModel: the number of required bytes could be wrong when selecting and deselecting
-  packs. (Stefan Wachter via Julien Ponge)
-- Turkish langpack updated (Melih Cetin via Julien Ponge)
-
-  &gt; 3.10.0 (build 2007.01.29)
-
-- Added docu: executeForPack, executeclass,logfiledir  for ProcessPanel (Fabrice Mirabile)
-- Added docu: createForUnselectedPack for UserInputPanel (Fabrice Mirabile)
-- Added DataCheckPanel (Fabrice Mirabile &amp; Hal Vaughan)
-- Bugfix at using OS dependant panels; dtd adapted to implementation of it
-  (Klaus Bartz, thanks to Francois Guillet).
-- Added Rulesengine, Conditions, panelconditions (Dennis Reil)
-- Fix DestroyButton in UninstallerFrame clickable only once (Dennis Reil)
-- Added conditions to UserInputPanel-fields (Dennis Reil)
-- Heading panel strings can be depend on the panelid (Klaus Bartz, thanks
-  to Stefan Wachter).
-- Registry access extended to keys and values directly under a root key
-  (Klaus Bartz, thanks to Markus Schlegel).
-- Added dtd for conditions (Dennis Reil)
-- Added support for panelid in InstallerImage-Definition (Dennis Reil)
-- Added support for customicons (Dennis Reil)
-- Fixed the DesktopShortcutCheckboxEnabled Builtin Variable in docu (Fabrice Mirabile)
-- Fixed build.xml (PathSelectionPanel without using TargetPanel) (Fabrice Mirabile)
-- UserInputPanel multiline label fix (Vladimir Ralev, JBoss/RedHat, via Julien Ponge)
-- Fix for calling the IzPack Ant task from Maven builds (Vladimir Ralev, JBoss/RedHat, via Julien Ponge)
-- Support for uncompressing archives and adding their content at the installer generation time (Nils Meier, via Julien Ponge)
-- Fix for default button changes when a text field receives focus in UserInputPanel (Vladimir Ralev, JBoss/RedHat, via Dennis Reil)
-- Use the 'ProgramFiles' environment variable to detect the Windows program files folder path. (Markus Schlegel via Julien Ponge)
-- TargetPanel.dir setting bug fix (Markus Schlegel via Julien Ponge)
-- Added support for packaging selection (Dennis Reil)
-- Added support for variables in UserInputPanel (Dennis Reil)
-- Non-interactive command-line uninstaller (Vladimir Ralev, JBoss/Redhat, via Julien Ponge)
-- PathSelectionPanel: the installation path could not be fully displayed in RedHat, Fedora and
-  Ubuntu (Vladimir Ralev, JBoss/RedHat, via Julien Ponge)
-- Installations could fail if the installation path contained non-english characters
-  (Vladimir Ralev, JBoss/RedHat, via Julien Ponge)
-- Non-English installation path could be displayed garbled in InstallSummary.html
-  (Vladimir Ralev, JBoss/RedHat, via Julien Ponge)
-- Selected packs not being refreshed in the collection when the PackPanel is initialized
-  (Vladimir Ralev, JBoss/RedHat, via Julien Ponge)
-- Finnish localization updates (Ari Voutilainen via Julien Ponge)
-- Going back and forth between profile selection and packs selection made packs selection unavailable
-  (Vladimir Ralev, JBoss/RedHat, via Julien Ponge)
-- PathInputPanel: the close button had incorrect behavior for all path input question/notification messages
-  (Vladimir Ralev, JBoss/RedHat, via Julien Ponge)
-- PathInputPanel: logged a stacktrace on Linux systems when no defaultInstallDir was specified and
-  no TargetPanel.dir.x resource was present (Stefan Wachter via Julien Ponge)
-- Added MultiVolumePackager, MultiVolumeUnpacker, MultiVolumeInstaller to support splitting the installer (Dennis Reil)
-- Added conditions for packs to PacksPanel (Dennis Reil)
-- Loose packs fixes (Markus Schlegel via Julien Ponge)
-- UserInputPanel: possible scrambled text fix (Markus Schlegel via Julien Ponge)
-- UserInputPanel (Markus Schlegel via Julien Ponge):
-  - support for the new &quot;installGroup&quot;-attribute for the &quot;programGroup&quot; element of the shortcutSpec.xml
-  - late creation of shortcuts, for example in case ShortcutPanel is displayed before InstallPanel
-  - fixed a bug where each Shortcut-Subgroup influenced the remaining Shortcut creation
-- Added icon resource extension, to dynamically change installer icon (Dennis Reil)
-- New splash-screen (Romain Guy)
-
-  &gt; 3.9.0 (build 2006.09.25)
-- Fix NullPointerException in CompilerConfig, if you specify a
-	compiler listener and the compiler listener class can't be found (Dennis Reil)
-- Fix Accents In French Langpack (Fabrice Mirabile)
-- Update French Langpack (Julien Ponge)
-- New Indonesian Langpack (Hans Aikema, thanks to Thomas Edwin Santosa)
-- Updated Dutch Langpack (Hans Aikema)
-- Fix for ComboBox in SearchField of UserInputPanel returning
-  java.lang.reflect.InvocationTargetException
-  if no options added.(Fabrice Mirabile, thanks to Oliver Kiddle)
-- Fix for the header of the window runs the message into
-  the filename (Fabrice Mirabile, thanks to Oliver Kiddle)
-- Added TroubleShooting for ShellLink.dll missing in help (DocBook and XHTML)
-  (Fabrice Mirabile).
-- Swing threading fixes (Julien Ponge).
-- Some fixes adviced by IntelliJ IDEA 5.1 code inspector (Julien Ponge).
-- Spanish langpack update (Cesar Martinez Izquierdo).
-- New Polish langpack (Fabrice Mirabile, thanks to Radek)
-- Fixed the createPWD.sh (Fabrice Mirabile, thanks to Radek)
-- Workaround for crashes at end of installation with Java VM version
-  1.5 (also known as 5.0) (Klaus Bartz).
-- Updated russian langpack (Fabrice Mirabile)
-- Fixed indent of ShortcutPanels Headline (Marc Eppelmann)
-- Made available all IzPack Variable in the ShortCut Specs (Marc Eppelmann)
-- Configurable heading panel added to InstallerFrame (Klaus Bartz).
-- Panels counter (text or progressbar) useable in the heading or
-  navigation panel (Klaus Bartz).
-- Fixed logfile for AntActions (Eric Rose).
-- PacksPanels: fixed disk space requirements (Ryan Shillington, via Julien
-  Ponge).
-- Compiler fix (Ryan Shillington, via Julien Ponge).
-- fixed Shotcut(s)(Panel) for Administrators on Win32 (Marc Eppelmann)
-- Fixes on Launcher, handling stuff (Julien Ponge)
-- MAC OS: Launcher is built as universal (ie, i386/ppc) binary  (Julien Ponge)
-- MAC OS: Qt is embedded in the application bundle  (Julien Ponge)
-- Added a variable for install log, InstallerFrame.logfilePath (Klaus Bartz).
-- Added the docu for install log (Fabrice Mirabile).
-- TwoColumnLayout fix (Amit Bhayani @JBoss/RedHat).
-- New compiler (packager) comandline argument -h for IZPACK_HOME; try to
-  automatic resolving of IZPACK_HOME if not specified (Klaus Bartz).
-- New layout manager (IzPanelLayout) for simplify layouting of IzPanels.
-  Configurable anchor, gaps, stretch rules etc. (Klaus Bartz).
-- Documentation figures refreshment (Julien Ponge).
-- Throw an IllegalArgumentException in the compiler if the declared panel
-  name differs in case from the founded class name (Klaus Bartz).
-- Re-Activated Shortcut Support for the Automated Installation (Marc Eppelmann).
-- Expanded Debug.log()'s possibility to log with Timestamp and or new Date()
-  Default is now: with both. (Marc Eppelmann).
-- Suppress a NullPointerException in the RuleInputField (Dennis Reil, via Marc
-  Eppelmann).
-- Merged normal installer and registry-enabled installers (Julien Ponge).
-- A potential null pointer exception has been discovered in Unpacker with a
-  custom action. (Dennis Reil, via Julien Ponge).
-- Implemented the X-KDE subsitute user - shortcut attribute (see Unix_shortcutSpec.xml)
-  (Marc Eppelmann).
-- Write Desktop shortcuts to all known local and ypbinded users &quot;desktop&quot; folders.
-  (Marc Eppelmann)
-- Write common shortcuts and their icons to the new freedesktop.org common
-  &quot;/usr/share/applications&quot;   and &quot;/usr/share/pixmaps&quot; folders to display
-  these in the commons [start].menu (Marc Eppelmann)
-- New InstallationGroupPanel for grouping packs together (Amit Bhayani, Scott Starks,
-  Alex Pinkin @JBoss/RedHat, via Julien Ponge).
-- Variable substitution in the description-elements of the PacksPanel (Dennis Reil, via
-  Julien Ponge).
-- Added a src.tar.gz target in the build.xml to create a IzPack.src.tar.gz (Marc Eppelmann)
-
-  &gt; 3.8.1 (build 2006.01.06)
-- Added Greek language support (Fabrice Mirabile, thanks to Panayotis
-  Katsaloulis for the translation and flag).
-- New splashscreen artwork (Nicolas Deschaume).
-- Added IPAdress and ClassPath variable (Fabrice Mirabile).
-- Added HostName variable (Fabrice Mirabile, thanks to Oliver Kiddle).
-- Fixes for IPAdress (Fabrice Mirabile).
-- Patch for WebAccessor: indeterminate progress bar (Julian Payne).
-- Finish language support update (Ari Voutilainen).
-- Script parser fix when no application URL is given.
-- Fix for installer spanning screens with xinerama.
-- Fix for bug #4551 (Weiji Guo).
-- Subgrouping of shortcuts (Weiji Guo).
-- Added Korean language support (Fabrice Mirabile, thanks to Dongsu Jang).
-- Added new panel SelectedPrinterPanel which allows the user to chose any local
-  printer installed and set it to the $SELECTED_PRINTER variable. (Hal Vaughan
-  and Fabrice Mirabile).
-
-  &gt; 3.8.0 (build 2005.10.27)
-- Added 2 processor classes having the ability to fill a combobox
-  with all available unix user and groups (Thorsten Kamann)
-- All default values for the InputPanel (the values of the set attribute)
-  can conatins variables at now.  All
-  variables will be replaces by the VariableSubstitutor (Thorsten Kamann)
-- The resources of the target panel can contains variables at now. All
-  variables will be replaces by the VariableSubstitutor (Thorsten Kamann)
-- Fixed chinese Flag.
-- Patch for InstallerFrame to support user confirmation after pressing
-  windows &quot;X&quot; closing button.
-- Update the IzPackTask to support an embedded xml installation document that
-  replaces @{x} property references with the corresponding ant property.
-  (patch #442 - Scott Stark).
-- Compiler refactor into an xml parser and xml independent compiler + Pack
-  group, installGroups (patch #439/440 - Scott Stark).
-- IzPack is now released under the terms of the Apache Software License 2.0.
-- Support for a jar attribute on the listener element (patch #432 - Scott Stark).
-- PacksPanels: translations loading fix (patch #446 - Stefan Heidrich).
-- Fixing bug with comboboxes. There was no text shown if you do not use a
-  processor to generate the choices. At now you can us the id or txt attribute
-  (Thorsten Kamann)
-- Uninstaller: use the system Look and Feel instead of the cross-platform one
-  (feature request #470).
-- The uninstaller name can be changed (Thomas Girard).
-- Documentation on the panels creation updates (Elmar Grom).
-- New SummaryPanel (Klaus Bartz).
-- New SummaryLoggerInstallerListener which loggs the summary
-  into a log file (Klaus Bartz).
-- Langpack up-to-date check script (Oscar Sierra | Klaus Bartz).
-- Custom langpacks (Klaus Bartz).
-- New variable APPLICATIONS_DEFAULT_ROOT (Klaus Bartz).
-- Bugfix in MultiLineLabel; now a line break will be performed also
-  it is needed at the last word of the line (Klaus Bartz).
-- Bugfix in JDKPathPanel: now it is possible to select an out-of-version
-  JDK (Klaus Bartz).
-- Properties can be substituted at compile time from the environment,
-  command line, java properties, ant, or &lt;property&gt; tag (Chad McHenry
-  and Scott Stark).
-- New Turkish langpack (Levent Bayindir).
-- Mac OS X: better Swing integration.
-- Configurable notation of language names in the language selection dialog
-  (Christian Murphy | Klaus Bartz).
-- Fail message in SimpleFinishPanel (Klaus Bartz).
-- Interrupt handling changed (Klaus Bartz).
-- Fixed shortcuts for RedHat and Mandrake (Fabrice Mirabile, thanks to Vitor
-  Rodrigues for the code).
-- New ConditionalUserInputPanel (Andreas Breiter, patches #407, #408).
-- ExecuteForPack, allow processing depending on the selected pack (Fabrice
-  Mirabile, thanks to Johannes Gutleber for the code).
-- Ant file cleanup: requires ant 1.6. Incremental builds of jar files.
-- Macrodefs instead of antcalls (Chad McHenry).
-- createForUnselectedPack, show a userinputapanel if a pack is not selected
-  (Fabrice Mirabile, thanks to Stefano Gamma)
-- Registry support on Windows (Klaus Bartz).
-- New CheckedHelloPanel which checks already installed products (Klaus Bartz).
-- Most IzPackTask output for ant is only dumped in VERBOSE mode (Chad McHenry).
-- Introduction of a JUnit test suite.
-- Scripts for easier built of password validation and encrytion addon classes (Fabrice Mirabile)
-- standalone-compiler.jar no longer has duplicate entries (bug #3928).
-- Building process: Java source and target compatibility enforced to 1.4.
-- IzPack installer: use JGoodies Looks on *nix as MlF is buggy on 1.5.
-- &quot;Made with IzPack label&quot;: enforce a specific font for the label, making it
-  look finally good with JGoodies Looks.
-- ImgPacksPanel: removed the useless/ugly border around the description area.
-- New compressor pack added to support different compression algorithm for the
-  packs; initial supported are &quot;raw&quot;, &quot;deflate&quot; and &quot;bzip2&quot; (Klaus Bartz).
-- New documentation in XHTML Strict 1.0 + CSS (Fabrice Mirabile).
-- New documentation in DocBook (Fabrice Mirabile).
-- Unicode port of shortcuts and registry stuff (Klaus Bartz).
-- New Mac OS X icon (.icns).
-- Added the American Locale XML and Flad (Fabrice Mirabile thanks to Joe Favero)
-
-  &gt; 3.7.2 (build 2005.04.22)
-
-- IoHelper.getPrimaryGroup: bugfix for SunOS (Klaus Bartz).
-- Russian langpack fixes (Alexey Makhmutov).
-- Swedish langpack update (Nils Nordman).
-- Spanish langpack update (Juan Alvarez).
-- UserInputPanel: made 'instanceNumber' a protected atribute (patch #406,
-  Andreas Breiter).
-
-  &gt; 3.7.1 (build 2005.02.15)
-
-- The Danish langpack was empty by mistake in 3.7.0.
-- Silent installations fix (Oscar Sierra).
-- Free disk space bugfix on Solaris (Oscar Sierra).
-- Installation runable with VM versions &lt; 1.4 again (Klaus Bartz)
-  (implementation for bug #2268 changed).
-- Italian langpack fixes (Fabrice Mirabille).
-- UserInputPanel: bug fixes by Per Abich (bugs #3233 and #3283).
-- Russian langpack fixes (Alexey Makhmutov).
-- ProcessPanel log file creation fix on Win32 (Anthony Xin Chen).
-- IoHelper.getenv: on Windows keys are not case sensitive (Klaus Bartz).
-
-  &gt; 3.7.0 (build 2005.01.11)
-
-- Adding custom action stuff for packaging, installation and uninstallation
-  (Klaus Bartz).
-- The packs files can now be located on disk if needed, for instance to install
-  an application located on a live cd (Erik Artzmark).
-- The attributes &quot;includes&quot; and &quot;excludes&quot; now are supported for filesets
-  (Klaus Bartz).
-- As many sensitive clean-ups as possible have been made after a FindBugs run.
-- Support of native libraries and additional jar files in the uninstaller (Klaus Bartz).
-- InfoPanel: variables substitution is now allowed (Borje Jonsson).
-- InstallPanel supports internationalized package names (Gaganis Giorgos).
-- Support for package dependencies (Gaganis Giorgos).
-- ShortcutPanel: can be optionally skipped on non-supported platforms.
-- PacksPanels: free disk space stuff (Klaus Bartz).
-- New Malaysian langpack (Redhuan Daniel Oon).
-- System properties can now be used as variables (Borje Jonsson).
-- New Norwegian langpack (Mohammed Sourouri).
-- New Chinese langpack (Xi Ping Wang).
-- The language selection box will now appear in the Windows tasks list (Harald
-  Spfle).
-- Spanish langpack update (David Perez Carmona).
-- Fix that prevented the correct detection of OS X.
-- Custom actions for ant calls (Klaus Bartz).
-- IzPanel.setInitialFocus( Component ) stuff added (Klaus Bartz).
-- Configurable button and label icons (Klaus Bartz).
-- Configurable subpath for $INSTALL_PATH default (Klaus Bartz).
-- New base class PathInputPanle for TargetPanel; new JDKPathPanel (Klaus Bartz).
-- Common helper in IzPanel (Klaus Bartz).
-- JGoodies loading fix.
-- Unified OS detection in OsVersion (Hani Suleiman).
-- Default installation path on unix now checks for writable 'usr/local' instead
-  of 'root' username (Hani Suleiman).
-- Removed incomplete and non-functional support for Mac OS9 (Hani Suleiman).
-- Fixed punctuation and some wording in English langpack (Hani Suleiman).
-- Logfile for ProcessPanel (Klaus Bartz).
-- Automatic scrolling of ProcessPanel output (Anthony Xin Chen).
-- Fixed bug parsing some brace enclosed variables (Chad McHenry) (bug #2451).
-- New Serbian translation (Filip Brcic).
-- Bug at loading Panels from other packages fixed (Klaus Bartz).
-- Unix (KDE/Gnome) shortcuts support (Marc Eppelmann).
-- ShortcutPanel: going to a previous panel could lead to strange situations
-  (bug #2713).
-- Installers: avoid showing an empty JFrame behind the languages selection
-  dialog (observed on X11).
-- UserInputPanel: the autodetect button is hidden if not needed
-  (Michael Hagedorn).
-- A tutorial is now available.
-- New Czech langpack (Jan Pavlovic).
-- German langpack: the uninstaller checkbox string was confusing about the
-  uninstaller performing a full deletion, including the files not unpacked
-  by an IzPack installer.
-- Liquid LnF: version bump (0.2.9-alpha5).
-
-  &gt; 3.6.1 (build 2004.10.09)
-
-- Slovak translation updates (Milan Madzia).
-- Java class execution bug fix (Erik Artzmark).
-- ImgPacksPanel was not aware of i18n by using the packsLang.xml_xxx resource.
-- Portuguese langpack updates (Flavio Fonseca).
-- Blocking the GUI interaction (like in InstallPanel) was only working with the
-  mouse events. It now works with the keyboard ones too (Eduard Jodas Samper).
-- TargetPanel: refuse selecting read-only directories.
-- Documentation fixes.
-- TargetPanel: more sanity checks (Andreas Vox).
-- InstallPanel: register errors as failures (Andreas Vox).
-- Polish translation updates (Bronek Truzkowski).
-  &gt; 3.6.0 (build 2004.07.28)
-- New Danish langpack (Frank Bille Jensen).
-- Web installers can now prompt for passwords and a proxy (Chad McHenry).
-- Fixed all javadoc warnings and errors (Chad McHenry).
-- ImgPacksPanel has been reworked to offer some features that only PacksPanel
-  had (Volker Friedritz).
-- Panels can be from any package (Chad McHenry)
-- Uninstaller not included, if it is not to be written anyway (Chad McHenry).
-- Packager and Compiler refactored.
-- Changed the JFrame icon shown in the installers and uninstallers.
-- New SimpleFinishPanel that don't have the automated installers feature.
-- Heavy refactorings on the look and feels side. The Kunststoff packagers have
-  been removed. The look and feels can now be specified on a per-OS basis. If
-  no look and feel is specified for a particular OS, then the platform default
-  one will be used.
-- The IzPack own installer uses the ImgPacksPanel again with some refreshed
-  packages pictures.
-- UserInputPanel: more parameters and a regular expressions validator have been
-  added (Mike Cunneen).
-- 3 new UserInputPanel validators (Thorsten Kamann):
-  * PortValidator (checks whether a port on localhost is available)
-  * IsPortValidator (checks whether the enterd value is a port in the range
-    between 0 and 32000)
-  * HostAddressValidator (checks whether the combination host:port is available)
-- 1 new UserInputPanel processor that checks checks whether the combination of
-  host:port is available. If not the port will be arised until it is available.
-  (Thorsten Kamann)
-- Web install location specified in xml, not resource. (Chad McHenry)
-- Web installer packs are in separate jars to minimize downloads. (Chad McHenry)
-- fix bug so &lt;fileset&gt; uses same default excludes as ant. (Chad McHenry)
-- added 'defaultexcludes' attribute to &lt;fileset&gt; (Chad McHenry)
-- More elements in dtd are optional, fixed bugs causing errors if certain
-  optional elements were omitted. (Chad McHenry)
-- It is now possible to have a specific picture for a specific panel by using
-  the Installer.image.n resources where n is the panel 0-based index.
-  (Peter Mikula).
-- Adding support for i18n to the pack panel (Thorsten Kamann)
-- Removing limtation the going backward is disabled if a pack not selected and
-  the pack using a panel (Thorsten Kamann)
-- Adding support for floating text in a langpack file (Thorsten Kamann).
-- At now you can specify a processor class to pre process the set value of a
-  RuleInputField (Thorsten Kamann).
-- The choices of a combo box can be generated throug a processor class
-  (Thorsten Kamann).
-- The message of a validator can be a i18n message (Thorsten Kamann).
-- If a translation string value cannot be found, then the key will be returned
-  instead of null, avoiding null exceptions when new strings are added.
-- The finish panels are now setting the quit button text to 'Finish' instead of
-  'Quit', which could confuse some users (Dario Yuri).
-- Many Windows shortcuts code fixes and enhancements (Bill Wong).
-- UserInputPanel and PacksPanel i18n support (Gaganis Giorgos).
-- ProcessPanel can now execute Java classes (Alex Bradley).
-- TargetPanel: pressing enter in the target editor will move to the next panel
-  (Gaganis Giorgos).
-- Polish langpack fix (Bronek Truszkowski).
-
-  &gt; 3.5.4 (build 2004.06.05)
-
-- German langpack fixes once again (Klaus Bartz).
-- Slovak langpack fix (<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">pbe at whitestein.com</A>).
-- The variable for the ISO3 language code was IS03_LANG instead of ISO3_LANG (a
-  zero instead of a 'o'). This stupid bug is now fixed (bug report #1883).
-- Catalan langpack update (Oscar Aubareda Fernandez).
-- UserInputPanel: fix for the directory detection failure (bug #1849) + added
-  the possibility to use a '*' in the choices
-  (ex: &lt;choice value=&quot;/opt/java/*&quot;/&gt;). Patch by Thorsten Kamann.
-
-  &gt; 3.5.3 (build 2004.05.15)
-
-- German langpack punctuation fixes (jonelo).
-- TargetPanel: the target path could be written several times in the automated
-  install XML descriptor (bug #1864).
-- TargetPanel: the path is now always converted to absolute (could cause
-  problems in variables substitutions). (bug #1866).
-- Target Panel: the path input field could be a bit short if a picture was used.
-  Fixed by Klaus Bartz (bug #1875).
-- German langpack: spelling correction (Dustin Sacks)
-- Fixed probelems creating a web-kunststoff installer (bug #1904)
-- IzPack installer: simpler and refreshed readme text.
-
-  &gt; 3.5.2 (build 2004.05.01)
-
-- Fixed moving empty directory to root (<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">pbe at whitestein.com</A>).
-- UserInputPanel getResult() fix (bug #1769).
-- Slovak langpack fix (patch #88).
-- A new mailing-list <A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">izpack-changes at lists.berlios.de</A> has been set up to receive
-  various development-related notifications.
-- German langpack fix (bug #1828).
-- Web installer fix: wrong jar was getting izpack classes
-- RuleTextField input bug fix (bug #1618)
-
-  &gt; 3.5.1 (build 2004.03.16)
-
-- No custom look and feel will be applied on Mac platforms (Chad McHenry).
-- A message box is now raised when the installer detects that the Java version
-  it is running on is lower than the one required by the package provider.
-- The Win32 documentation shortcuts are now back again.
-- If 'user.home' is set to something like 'C:' on Windows, it will be changed to
-  'C:\'.
-- German langpack: minor fix on 'LicencePanel.agree' translation.
-- UserInputPanel.getResult(): path construction fix (bug #1634).
-
-  &gt; 3.5.0 (build.2004.02.26)
-
-- The developer services have moved to BerliOS (<A HREF="http://developer.berlios.de/">http://developer.berlios.de/</A>).
-- Uninstaller is now able to delete itself and the install directory
-  (Chad McHenry)
-- Upate Checking: The installer is now able to &quot;update&quot; an already installed
-  package, therefore removing superfluous files after installation
-  (Tino Schwarze).
-- Dutch langpack update (Hans Aikema).
-- The compiler now emits some warnings when processing an incorrect installation
-  file (Chad McHenry / Marcus Stursberg).
-- New SudoPanel (Jan Blok).
-- ShortcutPanel: the action is now performed when the 'next' button is pressed
-  (Jan Blok).
-- Nasty bug in AutomatedInstallData variables setting fix.
-- Ant build: 'clean' target fix (Chad McHenry).
-- Language selection dialog: the 'ok' button gains the focus by default (Chad
-  Mchenry).
-- Uninstaller: various fixes (Chad McHenry).
-- Installer: the 'next' button requests focus whenever it is available.
-- Switched to the Crystal icons from KDE 3.2.
-- Uninstaller: proper use of the ButtonFactory.
-- Packs can now be restricted to a certain OS list (Jan Blok).
-- Fixed a bug that caused the automated installers to produce broken installers
-  (bug #1472).
-- Files with the same file source are never stored more than once anymore in the
-  resulting installer jar (Jan Blok).
-- Various documentation refreshments. The PostScript[tm] version is not produced
-  anymore (PDF + HTML are the 2 targets).
-- Language selection box: UI rendering fix (Chad McHenry).
-
-  &gt; 3.4.0 (build 2003.12.06)
-
-- The frontend which had been deprecated in 3.3.0 has been removed. There won't
-  be another frontend until someone volunteers to make a new one.
-- The files executor has been fixed when dealing with classpath arguments
-  passing.
-
-  &gt; 3.3.0 (build 2003.11.15)
-
-- Various bugs fixed (taken from the bugs database).
-- The current GUI frontend is deprecated. The project is looking for people to
-  take over the development of a new one.
-- The compiler now returns a sensible exit code on error. This way, it can be
-  used in scripts.
-- Italian localization updates by Cristian Ghezzi.
-- Win32: Rewrote the localization of &quot;Program Files&quot; and added support for all
-  24 localized versions of Windows 2000/XP (Dennis Lundberg).
-- Portuguese localization updates from Alex Carlos Braga Antao.
-- Swedish localization updates from Dennis Lundberg.
-- InstallPanel: the overall progress bar makes steps forward only after a pack
-  has been fully processed. The previous behaviour was to step forward at the
-  beginning of a pack extraction.
-- CompilePanel: disable Start button after successful compilation (T.Schwarze).
-- improve search field of the UserInputPanel: add checkfilename (T.Schwarze).
-- XInfoPanel: UI fix.
-
-  &gt; 3.2.1 (build 2003.09.19)
-
-- Added a new built-in variable ISO3_LANG that contains the selected language
-  ISO3 code (Elmar's idea).
-- Added a new 'run.installer' target to the Ant build file.
-- Added an uninstall target to the documentation makefile.
-
-  &gt; 3.2.0 (build 2003.09.18)
-
-- Added 3 built-in variables that you can use with the variables substitutor:
-  o APP_NAME for the application name
-  o APP_URL for the application URL
-  o APP_VER for the application version.
-- New ProcessPanel (Tino Schwarze).
-- The documentation is now licensed under a Commons Creative license.
-- The documentation now has a nicer cover page.
-- Jar file execution fix on the classpath arguments passing.
-- Win32: &quot;Program Files&quot; can now be localised (resolves problems with German
-  Windows for instance).
-- com.izforge.izpack.util.OsConstraint was missing in uninstaller.jar .
-- Small documentation typing errors fixed.
-- Added an install target to the documentation Makefile.
-- Frontend: Jar files could be listed in the panels tab. Fixed.
-- The scripts execution flag is now set to every users on Unix-like systems
-  (chmod a+x), regardless of who the user is (i.e. root or a single user).
-- Reformatting (imports, Ant build file).
-
-  &gt; 3.1.0b (build 2003.08.22)
-
-- Fix in the standalone compiler (Tino Schwarze).
-
-  &gt; 3.1.0a (build 2003.08.15)
-
-- Fixes a bug while generating a Kunststoff installer.
-
-  &gt; 3.1.0 (build 2003.08.11)
-
-- Added the possibility to use a standalone compiler (Tino Schwarze).
-- Added a new target to the Ant build system in order to fix the files CR/LF and
-  encodings.
-- Includes the following enhancements from Jonathan Halliday and Tino Schwarze.
-- Added overall progress bar to InstallPanel
-- Added SearchField to the UserInputPanel which allows to search for
-  files or directories at installation time
-- Added CompilePanel which allows Java classes to be compiled after
-  installation
-- Add infrastructure for automated installation - after installation,
-  the FinishPanel allows the user to save an XML file which can later be
-  used for automated installation (simply pass it to the installer as an
-  argument, for example:
-    java -jar my_super_program.jar super_program_autoinstall.xml
-  )
-- (internal) add infrastructure for GUI abstraction
-- Improved documentation:
-  o build better PDF using pdflatex (with hyperlinks and bookmarks)
-  o reorganize documentation for the &lt;packs&gt; section
-- Add &lt;singlefile&gt; tag which is useful if a file's name after
-  installation is different from the source file name
-- Add support for os attribute and &lt;os&gt; tag to all pack entries
-  (hopefully, the DTD is correct)
-- Allow files to be kept after execution
-- Allow packs to be preselected for installation or not
-- Allow packs to be OS dependent
-- Provide finer control when overwriting files:
-  o ask for overwriting, default yes
-  o ask for overwriting, default no
-  o update (only considers mtime - no real update)
-- Allow absolute paths in source files (might already be in 3.0.9)
-- Finer error handling - report missing attributes
-- (internal) TwoColumnLayout now supports WESTONLY and EASTONLY
-- (internal) made the ResourceManager a singleton
-- Add new kind of script parsing: shell - used %{variable} syntax to
-  avoid clashes within shell scripts
-
-  &gt; 3.0.9 (build 2003.06.29)
-
-- New Romanian language pack (Dani Orza).
-- Absolute paths problems patch (Tom Moore).
-- DTD, documentation fixes.
-
-  &gt; 3.0.8a (build 2003.05.02)
-
-- A bug had been introduced in 3.0.8 during the files extraction. Fixed.
-- Polish langpacks update.
-
-  &gt; 3.0.8 (build 2003.04.26)
-
-- Packs OS-targeting (Fran Taylor).
-- OS selection improved accuracy (Sanjay Linganna).
-- The standard installers can now use the native look and feel if the
-  'useNativeLAF' resource is specified (nice feature especially with the
-  incoming JDK 1.4.2).
-- The standard installers get back the button icons and highlighting effects.
-- Russian langpack update (Igor Anikeev).
-- Directory creation patch (Jonathan Halliday).
-
-  &gt; 3.0.7 (build 2003.04.04)
-
-- Slovakian langpack thanks to Milan Madzia.
-- Japanese, Russian and Dutch langpacks updates.
-- The uninstallers can now run scripts thanks to a patch from Hani Suleiman.
-
-  &gt; 3.0.6 (build 2003.02.27)
-
-- Updated the French and German langpacks.
-- Fixed the building process to take care of all classes related to the InputPanel.
-- Made some fixes on the installers DTD.
-- Elmar Grom / UserInputPanel:
-  o Fixed a bug with the drop down box that always return the value for the last
-    option in it, regardless of what had been selected during installation.
-  o Implemented the automated installer mode.
-  o RuleInputTextField can now be validated and processed with custom code
-    (documentation to come soon).
-  o A password field is now available and can also be validated and processed
-    with custom code (documentation to come soon).
-
-  &gt; 3.0.5 (build 2003.02.14)
-
-- This release becomes the new stable version, waiting for the 3.1 release which
-  is not yet ready. The stable/unstable versions separation is suspended.
-- Fixed a TargetPanel inconsistency when the target directory is empty.
-- Fixed Ant filesets-related problems.
-- UI fonts fixes for Linux/Sun JDK-1.4.
-- Empty directories can now be included.
-- IzPack's own installer now makes uses of the Ant-style filesets.
-- Splitted the documentation pack into several ones.
-- MacOS X UI fixes (Hani Suleiman).
-
-  &gt; 3.1.0 pre5 (build 2003.01.12)
-
-- Included Elmar's new UserInputPanel documentation.
-- A panel can now be added several times in an installation. This is mostly
-  useful for the new UserInputPanel.
-- Separated the installer generation from the 'dist' target in the Ant building
-  process. The new target is 'generate.installer'.
-- Move the com.izforge.izpack.util.EtchedBorder class to com.izforge.izpack.gui.
-  The class has also been rewritten because the original code was introduced
-  with a proprietary license notice.
-
-  &gt; 3.1.0 pre4 (build 2002.12.08)
-
-- A lot of installer GUI improvements by Jan Blok :
-  o an image can be shown in the installer left side
-  o buttons will look great under OSX
-  o HelloPanel : don't display authors if not present
-  o InstallPanel : immediate installation launching (the silly install button
-    has gone to heaven)
-  o LicencePanel : better GUI
-  o PackPanel : use table and display description, complete rewrite of this
-    panel
-  o IzPackMetalTheme : Tahoma is used if present on the target machine.
-- New UserInputPanel that allows to prompt the users for some values that can
-  later be stored as variables that can be parsed for in files (Elmar Grom).
-  Sorry but I did not have time to include the related documentation at the
-  release time.
-
-  &gt; 3.1.0 pre3 (build 2002.11.24)
-
-- Restyled, cleaned, javadoc'ed the whole IzPack source code.
-- The full IzPack source code Javadocs are generated when making a release.
-- Wiped the Enroll* classes that were polluting IzPack.
-- Added the creation of shortcuts for the IzPack documentation and the
-uninstaller.
-
-  &gt; 3.1.0 pre2 (build 2002.10.19)
-
-- New (and clean) ResourceManager thanks to Marcus Stursberg.
-- Shorcut fixes by Elmar Grom.
-
-  &gt; 3.1.0 pre1 (build 2002.09.21)
-
-- When InstallPanel was the last panel, it unlocked the next button and this was
-  of course not the desired behaviour.
-- ImgPacksPanel and PacksPanel can now display the total disk space required
-  (Adam Barclay for this task).
-- MacOSX GUI fix thanks to Hani Suleiman.
-- GUI Frontend fixes by Andrew De Torres.
-- Support for files overriding behaviour (override or keep old version if
-  present) by Adam Barclay.
-- New Italian langpack thanks to Franco Graziosi.
-
-  &gt; 3.0.0 (build 2002.08.13)
-
-- First stable release of the 3.x series ;-)
-- Ant task : the trailing '/' is appended on the IzPack directory when it is
-  omitted (Gareth Cronin).
-- Many improvements on the documentation which should be quite fine - Elmar Grom
-  helped a lot on this.
-- Updated ant.jar from the Ant 1.5 stable release.
-- German language pack fixes by Jonelo.
-
-  &gt; 3.0.0 rc3 (build 2002.07.28)
-
-- The Japanese langpack has been fixed by Akky Akimoto (now Windows shortcuts
-  compliant).
-- Windows shortcuts counterpart is now fully working thanks to the big efforts
-  of Elmar Grom with the additional help of Marcus Stursberg.
-- Documentation mispelling fixes and additions by Elmar Grom.
-
-  &gt; 3.0.0 rc2 (build 2002.07.06)
-
-- Added some documentation on the *LicencePanel and *InfoPanel panels.
-- Bugfix in HTMLLicencePanel.
-- The uninstaller is now able to take care of the jar new location (under the
-  install path) and wipes everything cleanly.
-- The 'create shortcut' button in ShortcutPanel is now disabled after the
-  shortcuts are created.
-
-  &gt; 3.0.0 rc1 (build 2002.07.03)
-
-- Fixes on the shortcuts sytem.
-- New Hungarian language pack thanks to Harsan Peter.
-- New Japanese language pack thanks to Hiroki Akimoto.
-- New documentation.
-- Fixed many source coding style errors.
-- Coding guidelines publication.
-- Some Javadoc text is now generated for those who need to make panels.
-
-  &gt; 3.0.0 pre4 (build 2002.06.15)
-
-- Polish language pack thanks to Piotr Bzdyl.
-- Shortcut system fixes.
-- The IzPack installer is now able to create shortcuts on Windows systems
-  while not creating any problem on another Operating System.
-- Catalan language pack thanks to Oscar Aubareda Fernandez.
-- The uninstaller is now copied under $INSTALL_PATH/Uninstaller.
-- Closing the language selection box of an installer will (finally !) close
-  the installer.
-- Removed the same named directories and files from the installers jars.
-- The ShortcutPanel now uses the IzPack highlighted buttons.
-- Many improvements from the e-xmlmedia.fr people including the Ant fileset
-  support, all these features will be documented in the coming new
-  documentation.
-
-  &gt; 3.0.0 pre3 (build 2002.05.19)
-
-- HTML licence panel agreement system fix by Jonelo.
-- Official inclusion of Elmar Grom's Windows library to create some shortcuts on
-  this operating system.
-( following : Johannes Lehtinen )
-- Cleaned up the InstallData interface and added utility methods.
-- Made the special variables (such as $INSTALL_PATH) available to panels using
-  the standard interface.
-- Made InstallData a singleton class.
-- Added InstallData properties for Panel interoptability.
-- Added a new variable : $FILE_SEPARATOR.
-
-  &gt; 3.0.0 pre2 (build 2002.04.27)
-
-- Fixes &amp; enhancements in the executable files support (Olexij Tkatchenko).
-- 2 new splash screens by Nicolas Deschaume.
-- The launching scripts of the pre1 were corrupted.
-
-  &gt; 3.0.0 pre1 (build 2002.04.21)
-
-- Enhanced splash #5 by Nicolas Deschaume.
-- Improved uninstalling system giving an access to the panels.
-- Image support at the language selection dialog through an optionnal resource
-  (installer.langsel.img).
-- Added executable element support (Olexij Tkatchenko).
-- /usr/local is now the default installation directory only for root user,
-  normal users will have $HOME instead (Unix* - Olexij Tkatchenko).
-- New Ukrainian language support (Olexij Tkatchenko).
-- The uninstaller now deletes itself after the uninstallation job is done.
-- Modified the IzPack Ant building process to integrate IzPack itself in order
-  to generate a ready-to-distribute installer.
-
-  &gt; 2.12.0 (build 2002.03.31)
-
-- Removed the JScrollPane for the panels container.
-- Improved panels sizing policy due to the JScrollPane removing.
-
-  &gt; 2.12.0 pre3 (build 2002.03.02)
-
-- Fixed a problem with the default compiler output file naming.
-- Added the Dutch language packs thanks to Fridjof Jansen.
-- Modified the Ant makefile so that any inner class of a panel can be
-  copied too.
-
-  &gt; 2.12.0 pre2 (build 2002.02.22)
-
-- Changed the font sizes to 12 as it really looks better.
-- Removed the &quot;All rights reserved&quot; portions in the frontend languages
-  packs as it is not really usefull and it now makes the About Box look
-  better.
-- Fix in PacksPanel thanks to Marcus Wolschon.
-- Fixes in both Unix and Windows new startup scripts.
-- Paul Wilkinson added the integration with Ant.
-- Native libraries can now be specified to be added to the IzPack
-  installers through a new optionnal tag.
-
-  &gt; 2.12.0 pre1 (build 2002.02.15)
-
-- Made some modifications to get the source code pass through the
-  IBM Jikes compiler checkings successfully.
-- Updated the Readme.txt file (I forgot to make it reflect the fact that
-  IzPack has a GUI frontend :-)
-- Updated the installer english langpack file so that 'installer.quit.message'
-  is not wrong anymore.
-- Added a complete Javadoc comments set to com.izforge.izpack.installer.IzPanel
-.
-- Inclusion of the IzPack installer XML file in the source directory.
-- The compiler and the frontend can now be invoked outside of the bin/ directory
-  without any problem. This provide a *noticeable* improvement ;-)
-
-  &gt; 2.11.1 (build 2002.02.09)
-
-- Inclusion of the Kunststoff Look And Feel version 2.
-
-  &gt; 2.11.0 (build 2002.01.18)
-
-- Pre-versions modifications have been validated.
-- Improved documentation HTML version.
-- IzPack's own installer : use the ImgPacksPanel instead of the classic
-  PacksPanel.
-- 2 new frontend splash screens thanks to Nicolas Deschaume.
-- HelloPanel : displays the email adresses enclosed by '&lt;' and '&gt;'.
-- This version is compiled with IBM Jikes.
-
-  &gt; 2.11.0 pre2 (build 2001.12.17)
-
-- Frontend : added a toolbar.
-- Ant makefile : removed the 'clean' dependency for the 'all' target.
-- Installer : the next button will automatically lock if the last panel is
-  reached but does not already lock it.
-
-  &gt; 2.11.0 pre1 (build 2001.12.09)
-
-- Installer : cached languages flags.
-- Installer : the languages flags are now grayed when not active (it creates
-  a rollover-effect when choosing the language in the list).
-- Frontend : the about box can't be resized.
-- Errors : now reported on the error output stream (System.err) instead of
-  the output stream (System.out).
-- Frontend : better GUI interaction.
-- ImgPacksPanel : fixed the bug that caused the snapshots not to switch as
-  expected when using the keyboard.
-- Updated Brazilian and Russian flags to conform with the other flags.
-
-  &gt; 2.10.0 (build 2001.12.02)
-
-- Pre-versions modifications have been validated.
-- A panel can now specify some custom variables (Serge Sivkov).
-- New Brazilian-Portuguese translation thanks to Joao Marcelo Pereira Alves.
-- New Russian translation thanks to Serge Sivkov.
-
-  &gt; 2.10.0 pre 2 (build 2001.11.25)
-
-- TargetPanel : it is now possible to specify a specific default installation
-  directory for a specific Operating System thanks to Michael Peterson.
-- Ant makefile : generation of the lib/ directory if not present (Michael
-  Peterson).
-- Documentation : updated to reflect the TargetPanel enhancements.
-
-  &gt; 2.10.0 pre 1 (build 2001.11.11)
-
-- A CVS server is now available thanks to TuxFamily.org .
-- 2 New frontend splash screens pictures by Nicolas Deschaume.
-- Safer command-line compiler invocation.
-- New variable substitution backend by Johannes Lehtinen (backward compatible).
-- Better exceptions reporting system to the end-user.
-- Installer : centered labels at the language selection prompt.
-- LicencePanel : now locks the 'next' button if the 'yes' radio is not selected.
-- TargetPanel : now warns if the specified target is an empty string.
-- InstallPanel : now removes the last processed file path when the installation
-  is over.
-
-  &gt; 2.9.0 (build 2001.10.26)
-
-- Faster and safer I/O thanks to Johannes Lehtinen.
-- Faster frontend splash screen.
-- Removed the finalizers in the code.
-- Windows icon file added.
-
-  &gt; 2.8.0 (build 2001.10.20)
-
-- New Frontend splash screen.
-- New file saving stupid bug fix in the Frontend.
-- FinishPanel : tooltip for the script button.
-- InstallPanel : new animated icon for the install button.
-- XInfoPanel : adaptative text panel.
-- Frontend : recent files list (support for the imported files also).
-- Fixed some size problems with the installer language selection dialog.
-- XML Frontend preferences file spec auto-upgrade.
-- New Finnish language pack thanks to Johannes Lehtinen.
-
-  &gt; 2.7.0 (build 2001.09.26)
-
-- Frontend localisation support.
-- The Frontend remembers the last opened directory.
-- Flags for the language selection for the installers.
-- Language pre-selection for the installers.
-- TargetPanel : warns when the selected directory exists.
-- InstallPanel : animated icon for the install button.
-- New spanish langpack thanks to Carlos Rueda.
-
-  &gt; 2.6.1 (build 2001.09.22)
-
-- Added an image to the frontend about box.
-- Fix in the Ant Makefile that caused it to fail in case of a first-time build.
-
-  &gt; 2.6.0 (build 2001.09.20)
-
-- Cleaner installer icons loading using an XML file.
-- Installation DTD mistake fix.
-- New GUI Frontend.
-- Sample installation XML comment fix.
-- German langpack small fixes.
-- Better internationalisation on Swing-specific strings.
-- Minor bug fixes.
-- Threaded compiling process.
-- Fix in the packs panel.
-- Better installer navigation buttons locking/unlocking.
-
-  &gt; 2.5.0 (build 2001.09.07)
-
-- New web installers support.
-
-  &gt; 2.4.0 (build 2001.09.05)
-
-- Automated installations support.
-- New XPM icons.
-- Improved build.xml.
-- MacOS and MacOSX installation paths support.
-- Minor bug fix in the TargetPanel path selection.
-
-  &gt; 2.3.0 (build 2001.08.29)
-
-- Uninstaller support.
-- Fix on InstallPanel : it does not change its size each time that a new
-  file is processed.
-- Bug fix in the IzPack variables translation system.
-- German langpack thanks to Klaus Hartlage.
-- Made a real documentation (it was time to do it :-) .
-
-  &gt; 2.2.0 (build 2001.08.18)
-
-- New panels available : ImgPacksPanel, HTMLInfoPanel, HTMLLicencePanel.
-- Use of Kunststoff 1.1.1 instead of 1.0.
-- Jakarta Ant script thanks to Pierre Dittgen.
-- API changes to allow a panel to ask for being skipped.
-- Wheights for some panels components fixed.
-- Added a Thanks.txt file :-)
-
-  &gt; 2.1.0 (build 2001.08.14)
-
-- Fixed a problem with the base path and the installation xml file, they don't
-  need to be in the same directory anymore.
-- 2 tips in the source code from Brad Cox have been included.
-- A new kind of installer is available : standard-kunststoff (same as standard
-  but with the Kunststoff Look and Feel support).
-- Fix in TargetPanel : you can specify the installation path by typing it
-  without having to validate it with the enter key.
-- Fixed the bottom components wheights in the installer frame : now it looks
-  much better.
-
-  &gt; 2.0.1 (build 2001.08.11)
-
-- No more warnings when the user wants to quit the installer and the
-  installation is done with the panel InstallPanel.
-
-  &gt; 2.0.0 (build 2001.08.10)
-
-- ... a brand new IzPack !
-- Now it is an XML-based compiler.
-- A more modular architecture (you can create your own panels for instance).
-- No GUI builder for the moment, it will come in the next versions.
-- More kinds of installers to come.
-_______________________________________________________________________________
-
-  &gt; 1.1.1 (build 2001.04.21)
-
-- Faster installer building / installation process.
-- String comparisons are now using the equalsIgnoreCase method instead of an
-  objects equality test '==' (safest).
-- Modified the about box.
-- Clearly made a difference between images &amp; icons in the jar files
-  (restructuration).
-- Tested successfully on BlackDown Linux JVM.
-
-  &gt; 1.1 (build 2001.04.10)
-
-- Adds the extensions to the filenames in the builder if it was omited.
-- Adjusted the fonts in the Metal theme; now it should look right.
-- Adjusted the thread priority of the splash &amp; progress windows, it should be
-  faster.
-- The setup now recognizes the os so that the default installation path is
-  appropriated.
-- Editors now place the caret at the beginning when a need (ex : a new text
-  is loaded).
-- Enhanced the language packs selection in the builder.
-- Added the french language packs.
-- Parses the script files for special variables.
-- Now comes along with a documentation.
-
-  &gt; 1.0 (build 2001.03.18)
-
-- Adjusted the fonts in the Metal theme.
-- Fixed the very stupid bugs with the files in pack deletion.
-- Improved the behaviour of the packs tab functions.
-- Made some small optimizations on various gui code parts.
-- Changed the text editors from JEditorPane to JTextArea : no more lines
-  wrappings problems.
-- Gained 5kb on Setup.jar.
-- Blocks user interaction in the builder during the installer creation.
-
-  &gt; 1.0 beta 1 (build 2001.03.11)
-
-- The first public release :-)
-- There are a lot of features to add and enhance in the next releases, of
-  course.

Copied: izpack-src/tags/3.11.0/Versions.txt (from rev 2044, izpack-src/trunk/Versions.txt)

Deleted: izpack-src/tags/3.11.0/src/dist-files/IzPack-install.xml
===================================================================
--- izpack-src/trunk/src/dist-files/IzPack-install.xml	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/dist-files/IzPack-install.xml	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,232 +0,0 @@
-&lt;!--
-    $Id$
-
-    IzPack installer XML file
-
-    By Julien PONGE
-
-    In order to build an installer for IzPack, let's create a directory
-    named '_dist' in the IzPack root directory. Then copy the files from
-    'src/dist-files' into '_dist'. Copy your IzPack image, that is all
-    the files present at the IzPack root directory. To make it clear,
-    you'll get bin/, lib/, ... and text files like Versions.txt and so
-    on. Now you can invoke the IzPack compiler and it will generate the
-    installer.
-
-    Alternatively, you can use the IzPack Ant makefile and run 'ant dist'. It's
-    much simpler :-)
---&gt;
-
-        &lt;!-- The installation --&gt;
-&lt;installation version=&quot;1.0&quot;&gt;
-
-    &lt;!-- The info section --&gt;
-    &lt;info&gt;
-        &lt;appname&gt;IzPack&lt;/appname&gt;
-        &lt;appversion&gt;3.11.0&lt;/appversion&gt;
-        &lt;authors&gt;
-            &lt;author email=&quot;&quot; name=&quot;Julien Ponge (maintainer and original developer)&quot;/&gt;
-            
-            &lt;author email=&quot;&quot; name=&quot;Hans Aikema (developer)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Klaus Bartz (developer)&quot;/&gt;     
-            &lt;author email=&quot;&quot; name=&quot;Marc Eppelmann (developer)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Matthew Fudge (Volantis Systems Ltd., developers)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Jeff Gordon (developer)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Dennis Reil (developer)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;JBoss/RedHat: Vladimir Ralev (developers)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Piotr Skowronek (developer)&quot; /&gt;
-
-            &lt;author email=&quot;&quot; name=&quot;Daniel Azarov (Exadel Inc, contributors)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Sergio Banos Calvo (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Loic Bardon (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Roberto Boriotti (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Kerekes Balazs (contributor)&quot; /&gt;
-	        &lt;author email=&quot;&quot; name=&quot;Xabier Cancela (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Andreas Guenther (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Michael Hagedorn (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Dick Hollenbeck (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Syed Khadeer (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Parastou Kohvaei (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Gildas Le Louarn (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Alexander Maslov (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Markus Schlegel (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Ari Voutilainen (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Pascal Wallem (contributor)&quot; /&gt;
-            &lt;author email=&quot;&quot; name=&quot;Gilles Wiart (contributor)&quot; /&gt;
-            
-            &lt;author email=&quot;&quot;
-                    name=&quot;... the (many) other developers and contributors to the previous releases!&quot;/&gt;
-        &lt;/authors&gt;
-        &lt;url&gt;<A HREF="https://izpack.github.io/&lt;/url">https://izpack.github.io/&lt;/url</A>&gt;
-        &lt;javaversion&gt;1.4&lt;/javaversion&gt;
-        &lt;requiresjdk&gt;no&lt;/requiresjdk&gt;
-        &lt;summarylogfilepath&gt;$INSTALL_PATH/installinfo/Summary.htm&lt;/summarylogfilepath&gt;
-    &lt;/info&gt;
-
-    &lt;!-- Flexible and in the screen proportions --&gt;
-    &lt;guiprefs height=&quot;650&quot; resizable=&quot;yes&quot; width=&quot;866&quot;&gt;
-        &lt;laf name=&quot;looks&quot; &gt;
-            &lt;os family=&quot;unix&quot;/&gt;
-        &lt;/laf&gt;
-        &lt;!-- GUI addaption for more informations see &quot;Modifying the GUI&quot; in the documentation --&gt;
-    	&lt;modifier key=&quot;layoutAnchor&quot; value=&quot;CENTER&quot;/&gt;
-    	&lt;modifier key=&quot;headingPanelCounter&quot; value=&quot;progressbar&quot;/&gt;
-		&lt;modifier key=&quot;headingPanelCounterPos&quot; value=&quot;inNavigationPanel&quot;/&gt;
-		&lt;modifier key=&quot;allYGap&quot; value=&quot;4&quot;/&gt;
-		&lt;modifier key=&quot;paragraphYGap&quot; value=&quot;10&quot;/&gt;
-		&lt;modifier key=&quot;filler1YGap&quot; value=&quot;5&quot;/&gt;
-		&lt;modifier key=&quot;filler3XGap&quot; value=&quot;10&quot;/&gt;
-    &lt;/guiprefs&gt;
-
-    &lt;variables&gt;
-        &lt;variable name=&quot;DesktopShortcutCheckboxEnabled&quot; value=&quot;true&quot;/&gt;
-    &lt;/variables&gt;
-
-    &lt;!-- We include every langpack --&gt;
-    &lt;locale&gt;
-        &lt;langpack iso3=&quot;eng&quot;/&gt;
-        &lt;langpack iso3=&quot;fra&quot;/&gt;
-        &lt;langpack iso3=&quot;deu&quot;/&gt;
-        &lt;langpack iso3=&quot;ita&quot;/&gt;
-        &lt;langpack iso3=&quot;jpn&quot;/&gt;
-        &lt;langpack iso3=&quot;spa&quot;/&gt;
-        &lt;langpack iso3=&quot;dan&quot;/&gt;
-        &lt;langpack iso3=&quot;ell&quot;/&gt;
-        &lt;langpack iso3=&quot;cat&quot;/&gt;
-        &lt;langpack iso3=&quot;ned&quot;/&gt;
-        &lt;langpack iso3=&quot;fin&quot;/&gt;
-        &lt;langpack iso3=&quot;swe&quot;/&gt;
-        &lt;langpack iso3=&quot;por&quot;/&gt;
-        &lt;langpack iso3=&quot;pol&quot;/&gt;
-        &lt;langpack iso3=&quot;rus&quot;/&gt;
-        &lt;langpack iso3=&quot;ukr&quot;/&gt;
-        &lt;langpack iso3=&quot;hun&quot;/&gt;
-        &lt;langpack iso3=&quot;svk&quot;/&gt;
-        &lt;langpack iso3=&quot;rom&quot;/&gt;
-        &lt;langpack iso3=&quot;mys&quot;/&gt;
-        &lt;langpack iso3=&quot;nor&quot;/&gt;
-        &lt;langpack iso3=&quot;chn&quot;/&gt;
-        &lt;langpack iso3=&quot;scg&quot;/&gt;
-        &lt;langpack iso3=&quot;cze&quot;/&gt;
-        &lt;langpack iso3=&quot;kor&quot;/&gt;
-        &lt;langpack iso3=&quot;glg&quot;/&gt;
-    &lt;/locale&gt;
-
-    &lt;!-- The resources needed by the various panels --&gt;
-    &lt;resources&gt;
-        &lt;res src=&quot;install-readme.html&quot; id=&quot;HTMLInfoPanel.info&quot;/&gt;
-        &lt;res src=&quot;license.html&quot; id=&quot;HTMLLicencePanel.licence&quot;/&gt;
-        &lt;res src=&quot;splash-3.10.png&quot; id=&quot;installer.langsel.img&quot;/&gt;
-        &lt;res src=&quot;shortcutSpec.xml&quot; id=&quot;shortcutSpec.xml&quot;/&gt;
-        &lt;res src=&quot;Unix_shortcutSpec.xml&quot; id=&quot;Unix_shortcutSpec.xml&quot;/&gt;
-        &lt;res src=&quot;info-border.png&quot; id=&quot;Installer.image.0&quot;/&gt;
-        &lt;res src=&quot;info-border.png&quot; id=&quot;Installer.image.1&quot;/&gt;
-        &lt;res src=&quot;info-border.png&quot; id=&quot;Installer.image.2&quot;/&gt;
-        &lt;res src=&quot;pack-border.png&quot; id=&quot;Installer.image.3&quot;/&gt;
-        &lt;res src=&quot;pack-border.png&quot; id=&quot;Installer.image.4&quot;/&gt;
-        &lt;res src=&quot;installing-border.png&quot; id=&quot;Installer.image.5&quot;/&gt;
-        &lt;res src=&quot;installing-border.png&quot; id=&quot;Installer.image.6&quot;/&gt;
-        &lt;res src=&quot;installing-border.png&quot; id=&quot;Installer.image.7&quot;/&gt;
-        &lt;res src=&quot;finished-border.png&quot; id=&quot;Installer.image.8&quot;/&gt;
-        &lt;res src=&quot;RegistrySpec.xml&quot; id=&quot;RegistrySpec.xml&quot;/&gt;
-    &lt;/resources&gt;
-
-    &lt;!-- The panels in a classic order --&gt;
-    &lt;panels&gt;
-        &lt;panel classname=&quot;CheckedHelloPanel&quot; id=&quot;hellopanel&quot;/&gt;
-        &lt;panel classname=&quot;HTMLInfoPanel&quot; id=&quot;infopanel&quot;/&gt;
-        &lt;panel classname=&quot;HTMLLicencePanel&quot; id=&quot;licensepanel&quot;/&gt;
-        &lt;panel classname=&quot;TargetPanel&quot; id=&quot;targetpanel&quot;/&gt;
-        &lt;panel classname=&quot;PacksPanel&quot; id=&quot;packspanel&quot;/&gt;
-        &lt;panel classname=&quot;SummaryPanel&quot; id=&quot;summarypanel&quot;/&gt;
-        &lt;panel classname=&quot;InstallPanel&quot; id=&quot;installpanel&quot;/&gt;
-        &lt;panel classname=&quot;ShortcutPanel&quot; id=&quot;shortcutpanel&quot;/&gt;
-        &lt;panel classname=&quot;FinishPanel&quot; id=&quot;finishpanel&quot;/&gt;
-    &lt;/panels&gt;
-
-    &lt;!-- The listeners section for CustomActions --&gt;
-    &lt;listeners&gt;
-        &lt;listener installer=&quot;SummaryLoggerInstallerListener&quot;/&gt;
-        &lt;listener installer=&quot;RegistryInstallerListener&quot;
-                  uninstaller=&quot;RegistryUninstallerListener&quot;&gt;
-            &lt;os family=&quot;windows&quot;/&gt;
-        &lt;/listener&gt;
-    &lt;/listeners&gt;
-
-    &lt;!-- The packs section --&gt;
-    &lt;packs&gt;
-
-        &lt;!-- The core files --&gt;
-        &lt;pack name=&quot;Core&quot; required=&quot;yes&quot;&gt;
-            &lt;description&gt;The IzPack core files.&lt;/description&gt;
-            &lt;fileset dir=&quot;&quot; targetdir=&quot;$INSTALL_PATH&quot;&gt;
-                &lt;include name=&quot;*.txt&quot;/&gt;
-                &lt;include name=&quot;bin/**/*&quot;/&gt;
-                &lt;include name=&quot;lib/**/*&quot;/&gt;
-                &lt;include name=&quot;legal/**/*&quot;/&gt;
-            &lt;/fileset&gt;
-            &lt;executable targetfile=&quot;$INSTALL_PATH/bin/compile&quot; stage=&quot;never&quot;/&gt;
-            &lt;executable targetfile=&quot;$INSTALL_PATH/bin/start.sh&quot; stage=&quot;never&quot;/&gt;
-        &lt;/pack&gt;
-
-        &lt;!-- The documentation --&gt;
-        &lt;pack name=&quot;HTML Documentation&quot; required=&quot;no&quot;&gt;
-            &lt;description&gt;The IzPack documentation (HTML version).&lt;/description&gt;
-            &lt;fileset dir=&quot;&quot; targetdir=&quot;$INSTALL_PATH&quot;&gt;
-                &lt;include name=&quot;doc/izpack/html/**/*&quot;/&gt;
-            &lt;/fileset&gt;
-        &lt;/pack&gt;
-        &lt;pack name=&quot;PDF Documentation&quot; required=&quot;no&quot;&gt;
-            &lt;description&gt;The IzPack documentation (PDF version).&lt;/description&gt;
-            &lt;fileset dir=&quot;&quot; targetdir=&quot;$INSTALL_PATH&quot;&gt;
-            &lt;include name=&quot;doc/izpack/pdf/**/*&quot; /&gt;
-            &lt;/fileset&gt;
-        &lt;/pack&gt;
-        &lt;pack name=&quot;Javadocs Documentation&quot; required=&quot;no&quot;&gt;
-            &lt;description&gt;The IzPack Java documentation (Javadocs for IzPack developers).&lt;/description&gt;
-            &lt;fileset dir=&quot;&quot; targetdir=&quot;$INSTALL_PATH&quot;&gt;
-                &lt;include name=&quot;doc/izpack/javadoc/**/*&quot;/&gt;
-            &lt;/fileset&gt;
-        &lt;/pack&gt;
-        &lt;pack name=&quot;NanoXML Documentation&quot; required=&quot;no&quot;&gt;
-            &lt;description&gt;NanoXML documentation (for IzPack developers).&lt;/description&gt;
-            &lt;fileset dir=&quot;&quot; targetdir=&quot;$INSTALL_PATH&quot;&gt;
-                &lt;include name=&quot;doc/nanoxml/**/*&quot;/&gt;
-            &lt;/fileset&gt;
-        &lt;/pack&gt;
-
-        &lt;!-- Utilities pack --&gt;
-        &lt;pack name=&quot;Utilities&quot; required=&quot;no&quot;&gt;
-            &lt;description&gt;IzPack utilities (izpack2exe, izpack2app, ...)&lt;/description&gt;
-            &lt;fileset dir=&quot;&quot; targetdir=&quot;$INSTALL_PATH&quot;&gt;
-                &lt;include name=&quot;utils/**/*&quot; /&gt;
-            &lt;/fileset&gt;
-        &lt;/pack&gt;
-
-        &lt;!-- A trivial sample to get started --&gt;
-        &lt;pack name=&quot;Sample&quot; required=&quot;no&quot;&gt;
-            &lt;description&gt;A sample installation.&lt;/description&gt;
-            &lt;fileset dir=&quot;&quot; targetdir=&quot;$INSTALL_PATH&quot;&gt;
-                &lt;include name=&quot;sample/**/*&quot;/&gt;
-            &lt;/fileset&gt;
-        &lt;/pack&gt;
-
-        &lt;!-- The source code of this version --&gt;
-        &lt;pack name=&quot;Sources&quot; required=&quot;no&quot;&gt;
-            &lt;description&gt;The full IzPack source code.&lt;/description&gt;
-            &lt;fileset dir=&quot;&quot; targetdir=&quot;$INSTALL_PATH&quot;&gt;
-                &lt;include name=&quot;src/**/*&quot;/&gt;
-                &lt;exclude name=&quot;src/*.manifest&quot;/&gt;
-            &lt;/fileset&gt;
-        &lt;/pack&gt;
-
-    &lt;/packs&gt;
-
-    &lt;!-- The native libraries to add --&gt;
-    &lt;native type=&quot;izpack&quot; name=&quot;ShellLink.dll&quot;/&gt;
-    &lt;native type=&quot;3rdparty&quot; name=&quot;COIOSHelper.dll&quot; stage=&quot;both&quot;&gt;
-        &lt;os family=&quot;windows&quot;/&gt;
-    &lt;/native&gt;
-
-
-&lt;/installation&gt;

Copied: izpack-src/tags/3.11.0/src/dist-files/IzPack-install.xml (from rev 2045, izpack-src/trunk/src/dist-files/IzPack-install.xml)

Deleted: izpack-src/tags/3.11.0/src/dist-files/Unix_shortcutSpec.xml
===================================================================
--- izpack-src/trunk/src/dist-files/Unix_shortcutSpec.xml	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/dist-files/Unix_shortcutSpec.xml	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,185 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;
-
-&lt;!-- 
-	Notes: 
-	Since there is no dtd (yet), here is a short explanation
-	of the last change.
-	- Each Shortcut has now a optional attribute
-
-	createForAll=&quot;yes|no&quot;
-	
-	new at 2006-09-06:
-	TryExec=&quot;aTryExecCommand&quot; will passes raw thru
-	Categories=&quot;Where to put in [K]-Menu&quot;
-	 
-	As root you can create Shortcuts for all users or even only for yourself.
-	This can be the case i.e. for the uninstaller.
-	If you whant to do so, set createForAll to true otherwise to false, which is the default.
-	
-	! If not explicite set or present the default is false.	
-	
-	New Attibute for Root Installation on Linux:	
-		 
-	Categories=&quot;Development;IDE&quot; 
-	   
-	TryExec=&quot;java -jar &amp;quot;$INSTALL_PATH/Uninstaller/uninstaller.jar&amp;quot;&quot;
-	   
-    Here are some Sample Categories and their apps
-		 examine *.desktop files in /usr/share/applications ...
-     Categories=&quot;Application;Network;WebDevelopment&quot;    Nvu
-	 Categories=&quot;Qt;Development;GUIDesigner&quot;    QtDesigner3
-	 Categories=&quot;Application;System;&quot;   VwareServer-console  
-	 Categories=&quot;Network;WebBrowser&quot;    Opera
-	 Categories=&quot;Development;Debugger&quot;    DDD debugger
-     Categories=&quot;Development;IDE&quot;    Eclipse IDE
-	 Categories=&quot;SystemSetup;X-SuSE-Core-System&quot; Yast2
-	 Categories=&quot;System;Archiving&quot; Sesam archiving
-    
---&gt;
-
-&lt;shortcuts&gt;
-
-  &lt;programGroup defaultName=&quot;IzForge/<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">IzPack at build.number</A>@&quot; location=&quot;applications&quot;/&gt;
-
-
-    &lt;!-- Disabled since there is no Frontend
-  shortcut
-     name=&quot;IzPack&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;yes&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;yes&quot;
-     startup=&quot;no&quot;
-     target=&quot;$INSTALL_PATH/bin/izpack-fe.sh&quot;
-     commandLine=&quot;&quot;
-     workingDirectory=&quot;$INSTALL_PATH/bin&quot;
-     description=&quot;Front-End for IzPack installation tool&quot;
-     iconFile=&quot;$INSTALL_PATH/bin/icons/izpack.png&quot;
-     iconIndex=&quot;0&quot;
-     type=&quot;Application&quot;
-     encoding=&quot;UTF-8&quot;
-     terminal=&quot;true&quot;
-     KdeSubstUID=&quot;false&quot;
-     initialState=&quot;normal&quot;&gt;   
-     &lt;createForPack name=&quot;Core&quot;/&gt;     
-   &lt;/shortcut --&gt;
-
-   &lt;shortcut
-     name=&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">IzPack at ver</A>@ XHtml Documentation&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;yes&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;yes&quot;
-     startup=&quot;no&quot;
-     target=&quot;$INSTALL_PATH/bin/start.sh&quot;
-     workingDirectory=&quot;&quot;
-     commandLine=&quot;$INSTALL_PATH/doc/izpack/xhtml/izpack-doc.html&quot;
-     initialState=&quot;noShow&quot;
-     iconFile=&quot;help&quot;
-     iconIndex=&quot;0&quot; 
-     url=&quot;$INSTALL_PATH/doc/izpack/xhtml/index.html&quot;                                
-     type=&quot;Application&quot;
-     encoding=&quot;UTF-8&quot; 
-   createForAll=&quot;true&quot;  
-     description=&quot;This opens a WebBrowser to look into the IzPack @build.number@ (HTML) user documentation&quot;&gt;
-     
-     &lt;createForPack name=&quot;XHTML Documentation&quot;/&gt;
-   &lt;/shortcut&gt;
-  
-     &lt;shortcut
-     name=&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">IzPack at ver</A>@ Java Documentation&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;yes&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;yes&quot;
-     startup=&quot;no&quot;
-     target=&quot;$INSTALL_PATH/bin/start.sh&quot;
-     workingDirectory=&quot;&quot;
-     commandLine=&quot;$INSTALL_PATH/doc/izpack/javadoc/index.html&quot;
-     initialState=&quot;noShow&quot;
-     iconFile=&quot;help&quot;
-     iconIndex=&quot;0&quot; 
-     url=&quot;$INSTALL_PATH/doc/izpack/javadoc/index.html&quot;                                
-     type=&quot;Application&quot;
-     encoding=&quot;UTF-8&quot; 
-   createForAll=&quot;true&quot;  
-     description=&quot;This opens a WebBrowser to look into the IzPack @build.number@ (HTML) Java documentation&quot;&gt;
-     
-     &lt;createForPack name=&quot;Java Documentation&quot;/&gt;
-   &lt;/shortcut&gt;
-  
-   &lt;shortcut
-     name=&quot;NanoXML Documentation&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;yes&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;yes&quot;
-     startup=&quot;no&quot;
-     target=&quot;acroread&quot;
-     workingDirectory=&quot;&quot;
-     commandLine=&quot;$INSTALL_PATH/doc/nanoxml/NanoXML-Java.pdf&quot;
-     initialState=&quot;noShow&quot;
-     iconFile=&quot;acroread&quot;
-     iconIndex=&quot;0&quot;                                      
-     type=&quot;Application&quot;
-     encoding=&quot;UTF-8&quot;   
-     createForAll=&quot;true&quot;
-     description=&quot;This opens Adobe (Acrobat) Reader (if available) to look into or print the NanoXML (PDF) user documentation&quot;&gt;
-     
-     &lt;createForPack name=&quot;NanoXML Documentation&quot;/&gt;
-   &lt;/shortcut&gt;
-
-   &lt;shortcut
-     name=&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">IzPack at ver</A>@ PDF Documentation&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;yes&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;yes&quot;
-     startup=&quot;no&quot;
-     target=&quot;acroread&quot;
-     workingDirectory=&quot;&quot;
-     commandLine=&quot;$INSTALL_PATH/doc/izpack/pdf/izpack-doc.pdf&quot;
-     initialState=&quot;noShow&quot;
-     iconFile=&quot;acroread&quot;
-     iconIndex=&quot;0&quot;                                   
-     type=&quot;Application&quot;
-     encoding=&quot;UTF-8&quot;   
-   createForAll=&quot;true&quot;
-     description=&quot;This opens Adobe (Acrobat) Reader (if available) to look into or print the IzPack @build.number@ (PDF) user documentation&quot;&gt;
-     
-     &lt;createForPack name=&quot;PDF Documentation&quot;/&gt;
-   &lt;/shortcut&gt;
-
-      
-   &lt;shortcut
-     name=&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">Izpack at ver</A>@ Uninstaller&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;yes&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;no&quot;
-     startup=&quot;no&quot;
-     target=&quot;java&quot;
-     commandLine=&quot;-jar &amp;quot;$INSTALL_PATH/Uninstaller/uninstaller.jar&amp;quot;&quot;
-     
-     initialState=&quot;noShow&quot;
-     iconFile=&quot;trashcan_full&quot;
-     iconIndex=&quot;0&quot; 
-     workingDirectory=&quot;&quot;
-     type=&quot;Application&quot;
-     encoding=&quot;UTF-8&quot;
-     KdeSubstUID=&quot;true&quot;
-     KdeUsername=&quot;root&quot;
-     createForAll=&quot;false&quot;
-	 
-	 
-	 Categories=&quot;Development;IDE&quot; 
-	   
-	 TryExec=&quot;java -jar &amp;quot;$INSTALL_PATH/Uninstaller/uninstaller.jar&amp;quot;&quot;
-	   
-     description=&quot;This uninstalls IzPack @build.number@&quot;&gt;
-
-     &lt;createForPack name=&quot;Core&quot; /&gt;
-   &lt;/shortcut&gt;
-   
-   
-&lt;/shortcuts&gt;

Copied: izpack-src/tags/3.11.0/src/dist-files/Unix_shortcutSpec.xml (from rev 2045, izpack-src/trunk/src/dist-files/Unix_shortcutSpec.xml)

Deleted: izpack-src/tags/3.11.0/src/dist-files/shortcutSpec.xml
===================================================================
--- izpack-src/trunk/src/dist-files/shortcutSpec.xml	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/dist-files/shortcutSpec.xml	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,104 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;
-
-&lt;shortcuts&gt;
-
-  &lt;skipIfNotSupported /&gt;
-
-  &lt;programGroup defaultName=&quot;IzForge\<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">IzPack at build.number</A>@&quot; location=&quot;applications&quot;/&gt;
-
-&lt;!--  
-  &lt;shortcut
-     name=&quot;IzPack&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;yes&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;no&quot;
-     startup=&quot;no&quot;
-     target=&quot;$INSTALL_PATH\bin\izpack-fe.bat&quot;
-     commandLine=&quot;&quot;
-     description=&quot;Front-End for IzPack installation tool&quot;
-     iconFile=&quot;$INSTALL_PATH\bin\icons\izpack.ico&quot;
-     iconIndex=&quot;0&quot;
-     initialState=&quot;noShow&quot;&gt;
-   
-     &lt;createForPack name=&quot;Core&quot;/&gt;
-     
-   &lt;/shortcut&gt;
---&gt;
-
-   &lt;shortcut
-     name=&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">IzPack at ver</A>@ XHtml Documentation&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;yes&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;no&quot;
-     startup=&quot;no&quot;
-     target=&quot;$INSTALL_PATH\doc\izpack\xhtml\izpack-doc.html&quot;
-     commandLine=&quot;&quot;
-     description=&quot;This opens a WebBrowser to look into the IzPack @build.number@ (HTML) user documentation&quot;&gt;
-          
-     &lt;createForPack name=&quot;XHTML Documentation&quot; /&gt;
-   &lt;/shortcut&gt;
-  
-   &lt;shortcut
-     name=&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">IzPack at ver</A>@ Java Documentation&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;yes&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;no&quot;
-     startup=&quot;no&quot;
-     target=&quot;$INSTALL_PATH\doc\izpack\javadoc\index.html&quot;
-     commandLine=&quot;&quot;
-     description=&quot;This opens a WebBrowser to look into the IzPack @build.number@ (Java) developer documentation&quot;&gt;
-          
-     &lt;createForPack name=&quot;Java Documentation&quot; /&gt;
-   &lt;/shortcut&gt;
-  
-   &lt;shortcut
-     name=&quot;NanoXML Documentation&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;yes&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;no&quot;
-     startup=&quot;no&quot;
-     target=&quot;$INSTALL_PATH\doc\nanoxml\NanoXML-Java.pdf&quot;
-     commandLine=&quot;&quot;
-     iconFile=&quot;%SystemRoot%\system32\SHELL32.dll&quot;
-     iconIndex=&quot;23&quot; 
-     description=&quot;This opens Adobe (Acrobat) Reader (if available) to look into or print the NanoXML (PDF) developer documentation&quot;&gt;
-          
-     &lt;createForPack name=&quot;NanoXML Documentation&quot; /&gt;
-   &lt;/shortcut&gt;   
-  
-   &lt;shortcut
-     name=&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">IzPack at ver</A>@ PDF Documentation&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;no&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;no&quot;
-     startup=&quot;no&quot;
-     target=&quot;$INSTALL_PATH\doc\izpack\pdf\izpack-doc.pdf&quot;
-     commandLine=&quot;&quot;
-	   iconFile=&quot;%SystemRoot%\system32\SHELL32.dll&quot;
-     iconIndex=&quot;23&quot; 
-     description=&quot;This opens Adobe (Acrobat) Reader (if available) to look into or print the IzPack @build.number@ (PDF) user documentation&quot;&gt;
-     
-     &lt;createForPack name=&quot;PDF Documentation&quot; /&gt;
-   &lt;/shortcut&gt;
-   &lt;shortcut
-     name=&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">Izpack at ver</A>@ Uninstaller&quot;
-     programGroup=&quot;yes&quot;
-     desktop=&quot;no&quot;
-     applications=&quot;no&quot;
-     startMenu=&quot;no&quot;
-     startup=&quot;no&quot;
-     target=&quot;$INSTALL_PATH\Uninstaller\uninstaller.jar&quot;     
-     commandLine=&quot;&quot;
-	 iconFile=&quot;%SystemRoot%\system32\SHELL32.dll&quot;
-     iconIndex=&quot;31&quot; 
-     description=&quot;This uninstalls IzPack @build.number@&quot;&gt;
-     
-     &lt;createForPack name=&quot;Core&quot; /&gt;
-   &lt;/shortcut&gt;
-   
-&lt;/shortcuts&gt;

Copied: izpack-src/tags/3.11.0/src/dist-files/shortcutSpec.xml (from rev 2045, izpack-src/trunk/src/dist-files/shortcutSpec.xml)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/CompilerConfig.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/compiler/CompilerConfig.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/CompilerConfig.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,2537 +0,0 @@
-/*
- * $Id$
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Copyright 2001 Johannes Lehtinen
- * Copyright 2002 Paul Wilkinson
- * Copyright 2004 Gaganis Giorgos
- * Copyright 2007 Syed Khadeer / Hans Aikema
- *
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *     
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.izforge.izpack.compiler;
-
-import com.izforge.izpack.CustomData;
-import com.izforge.izpack.ExecutableFile;
-import com.izforge.izpack.GUIPrefs;
-import com.izforge.izpack.Info;
-import com.izforge.izpack.PackFile;
-import com.izforge.izpack.Panel;
-import com.izforge.izpack.ParsableFile;
-import com.izforge.izpack.UpdateCheck;
-import com.izforge.izpack.compiler.Compiler.CmdlinePackagerListener;
-import com.izforge.izpack.event.CompilerListener;
-import com.izforge.izpack.rules.Condition;
-import com.izforge.izpack.rules.RulesEngine;
-import com.izforge.izpack.util.Debug;
-import com.izforge.izpack.util.OsConstraint;
-import com.izforge.izpack.util.VariableSubstitutor;
-import net.n3.nanoxml.IXMLParser;
-import net.n3.nanoxml.IXMLReader;
-import net.n3.nanoxml.NonValidator;
-import net.n3.nanoxml.StdXMLParser;
-import net.n3.nanoxml.StdXMLReader;
-import net.n3.nanoxml.XMLBuilderFactory;
-import net.n3.nanoxml.XMLElement;
-import net.n3.nanoxml.XMLException;
-import net.n3.nanoxml.XMLParserFactory;
-import net.n3.nanoxml.XMLWriter;
-import org.apache.tools.ant.DirectoryScanner;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.Set;
-import java.util.StringTokenizer;
-import java.util.TreeMap;
-import java.util.Vector;
-import java.util.jar.JarInputStream;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-import java.util.zip.ZipInputStream;
-
-/**
- * A parser for the installer xml configuration. This parses a document
- * conforming to the installation.dtd and populates a Compiler instance to
- * perform the install compilation. 
- * 
- * @author Scott Stark
- * @version $Revision$
- */
-public class CompilerConfig extends Thread
-{
-    /** The compiler version. */
-    public final static String VERSION = &quot;1.0&quot;;
-
-    /** Standard installer. */
-    public final static String STANDARD = &quot;standard&quot;;
-
-    /** Web installer. */
-    public final static String WEB = &quot;web&quot;;
-
-    /** Constant for checking attributes. */
-    private static boolean YES = true;
-
-    /** Constant for checking attributes. */
-    private static boolean NO = false;
-
-    private final static String IZ_TEST_FILE = &quot;ShellLink.dll&quot;;
-
-    private final static String IZ_TEST_SUBDIR = &quot;bin&quot; + File.separator + &quot;native&quot; + File.separator
-            + &quot;izpack&quot;;
-
-    /** The xml install file */
-    private String filename;
-    /** The xml install configuration text */
-    private String installText;
-    /** The base directory. */
-    protected String basedir;
-
-    /** The installer packager compiler */
-    private Compiler compiler;
-
-    /**
-     * List of CompilerListeners which should be called at packaging
-     */
-    protected List compilerListeners = new ArrayList();
-
-    /**
-     * Set the IzPack home directory
-     * @param izHome - the izpack home directory
-     */
-    public static void setIzpackHome(String izHome)
-    {
-        Compiler.setIzpackHome(izHome);
-    }
-
-    /**
-     * The constructor.
-     * 
-     * @param filename The XML filename.
-     * @param basedir The base directory.
-     * @param kind The installer kind.
-     * @param output The installer filename.
-     * @throws CompilerException
-     */
-    public CompilerConfig(String filename, String basedir, String kind, String output) throws CompilerException
-    {
-        this(filename, basedir, kind, output, null);
-    }
-    /**
-     * The constructor.
-     * 
-     * @param filename The XML filename.
-     * @param basedir The base directory.
-     * @param kind The installer kind.
-     * @param output The installer filename.
-     * @param listener The PackagerListener.
-     * @throws CompilerException
-     */
-    public CompilerConfig(String filename, String basedir, String kind, String output, PackagerListener listener) 
-    throws CompilerException
-    {
-        this(filename,basedir,kind,output, &quot;default&quot;, listener);
-    }
-
-    /**
-     * @param filename The XML filename.
-     * @param kind The installer kind.
-     * @param output The installer filename.
-     * @param compr_format The compression format to be used for packs.
-     * @param listener The PackagerListener.
-     * @throws CompilerException
-     */
-    public CompilerConfig(String filename, String base, String kind, String output, String compr_format, 
-            PackagerListener listener) throws CompilerException
-    {
-        this(filename,base,kind,output, compr_format,listener, null);
-    }
-
-    /**
-     * 
-     * @param basedir The base directory.
-     * @param kind The installer kind.
-     * @param output The installer filename.
-     * @param listener The PackagerListener.
-     * @param installText The install xml configuration text
-     * @throws CompilerException
-     */
-    public CompilerConfig(String basedir, String kind, String output, PackagerListener listener,
-            String installText) throws CompilerException
-    {
-        this(null, basedir, kind, output, &quot;default&quot;, listener, installText);
-    }
-    /**
-     * 
-     * @param filename The XML filename.
-     * @param basedir The base directory.
-     * @param kind The installer kind.
-     * @param output The installer filename.
-     * @param compr_format The compression format to be used for packs.
-     * @param listener The PackagerListener.
-     * @param installText The install xml configuration text
-     * @throws CompilerException
-     */
-    public CompilerConfig(String filename, String basedir, String kind, String output, String compr_format, 
-            PackagerListener listener, String installText) throws CompilerException
-    {
-        this( filename, basedir, kind, output, compr_format, -1, listener, installText);
-    }
-
-    /**
-     * @param filename The XML filename.
-     * @param basedir The base directory.
-     * @param kind The installer kind.
-     * @param output The installer filename.
-     * @param compr_format The compression format to be used for packs.
-     * @param compr_level Compression level to be used if supported.
-     * @param listener The PackagerListener.
-     * @param installText The install xml configuration text
-    * @throws CompilerException
-     */
-    public CompilerConfig(String filename, String basedir, String kind, String output, String compr_format, 
-            int compr_level, PackagerListener listener, String installText) throws CompilerException
-    {
-        this.filename = filename;
-        this.installText = installText;
-        this.basedir = basedir;
-        this.compiler = new Compiler(basedir, kind, output, compr_format, compr_level);
-        compiler.setPackagerListener(listener);
-    }
-
-
-
-    /**
-     * Add a name value pair to the project property set. It is &lt;i&gt;not&lt;/i&gt;
-     * replaced it is already in the set of properties.
-     * 
-     * @param name the name of the property
-     * @param value the value to set
-     * @return true if the property was not already set
-     */
-    public boolean addProperty(String name, String value)
-    {
-        return compiler.addProperty(name, value);
-    }
-
-    /**
-     * Access the install compiler
-     * @return the install compiler
-     */
-    public Compiler getCompiler()
-    {
-        return compiler;
-    }
-
-    /**
-     * Retrieves the packager listener
-     */
-    public PackagerListener getPackagerListener()
-    {
-        return compiler.getPackagerListener();
-    }
-
-    /** Compile the installation */
-    public void compile()
-    {
-        start();
-    }
-
-    /** The run() method. */
-    public void run()
-    {
-        try
-        {
-            executeCompiler();
-        }
-        catch (CompilerException ce)
-        {
-            System.out.println(ce.getMessage() + &quot;\n&quot;);
-        }
-        catch (Exception e)
-        {
-            if (Debug.stackTracing())
-            {
-                e.printStackTrace();
-            }
-            else
-            {
-                System.out.println(&quot;ERROR: &quot; + e.getMessage());
-            }
-        }
-    }
-
-    /**
-     * Compiles the installation.
-     * 
-     * @exception Exception Description of the Exception
-     */
-    public void executeCompiler() throws Exception
-    {
-        // normalize and test: TODO: may allow failure if we require write
-        // access
-        File base = new File(basedir).getAbsoluteFile();
-        if (!base.canRead() || !base.isDirectory())
-            throw new CompilerException(&quot;Invalid base directory: &quot; + base);
-
-        // add izpack built in property
-        compiler.setProperty(&quot;basedir&quot;, base.toString());
-
-        // We get the XML data tree
-        XMLElement data = getXMLTree();
-        // loads the specified packager
-        loadPackagingInformation(data);
-        
-        // Listeners to various events
-        addCustomListeners(data);
-
-        // Read the properties and perform replacement on the rest of the tree
-        substituteProperties(data);
-
-        // We add all the information
-        addVariables(data);
-        addDynamicVariables(data);
-        addConditions(data);
-        addInfo(data);
-        addGUIPrefs(data);
-        addLangpacks(data);
-        addResources(data);
-        addNativeLibraries(data);
-        addJars(data);
-        addPanels(data);
-        addPacks(data);
-
-        // We ask the packager to create the installer
-        compiler.createInstaller();
-    }
-
-    private void loadPackagingInformation(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;loadPackager&quot;, CompilerListener.BEGIN, data);
-        // Initialisation
-        XMLElement root = data.getFirstChildNamed(&quot;packaging&quot;);
-        String packagerclassname = &quot;com.izforge.izpack.compiler.Packager&quot;;
-        String unpackerclassname = &quot;com.izforge.izpack.installer.Unpacker&quot;;
-        XMLElement packager = null;
-        if (root != null){
-            packager = root.getFirstChildNamed(&quot;packager&quot;);
-            
-            if (packager != null){
-                packagerclassname = requireAttribute(packager, &quot;class&quot;);
-            }
-            
-            XMLElement unpacker = root.getFirstChildNamed(&quot;unpacker&quot;);
-            
-            if (unpacker != null){
-                unpackerclassname = requireAttribute(unpacker, &quot;class&quot;);                
-            }        
-        }
-        compiler.initPackager(packagerclassname);  
-        if (packager != null){
-            XMLElement options = packager.getFirstChildNamed(&quot;options&quot;);
-            if (options != null){
-                compiler.getPackager().addConfigurationInformation(options);
-            }
-        }
-        compiler.addProperty(&quot;UNPACKER_CLASS&quot;, unpackerclassname);
-        notifyCompilerListener(&quot;loadPackager&quot;, CompilerListener.END, data);        
-    }
-
-    public boolean wasSuccessful()
-    {
-        return compiler.wasSuccessful();
-    }
-
-    /**
-     * Returns the GUIPrefs.
-     * 
-     * @param data The XML data.
-     * @exception CompilerException Description of the Exception
-     */
-    protected void addGUIPrefs(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;addGUIPrefs&quot;, CompilerListener.BEGIN, data);
-        // We get the XMLElement &amp; the attributes
-        XMLElement gp = data.getFirstChildNamed(&quot;guiprefs&quot;);
-        GUIPrefs prefs = new GUIPrefs();
-        if (gp != null)
-        {
-            prefs.resizable = requireYesNoAttribute(gp, &quot;resizable&quot;);
-            prefs.width = requireIntAttribute(gp, &quot;width&quot;);
-            prefs.height = requireIntAttribute(gp, &quot;height&quot;);
-
-            // Look and feel mappings
-            Iterator it = gp.getChildrenNamed(&quot;laf&quot;).iterator();
-            while (it.hasNext())
-            {
-                XMLElement laf = (XMLElement) it.next();
-                String lafName = requireAttribute(laf, &quot;name&quot;);
-                requireChildNamed(laf, &quot;os&quot;);
-
-                Iterator oit = laf.getChildrenNamed(&quot;os&quot;).iterator();
-                while (oit.hasNext())
-                {
-                    XMLElement os = (XMLElement) oit.next();
-                    String osName = requireAttribute(os, &quot;family&quot;);
-                    prefs.lookAndFeelMapping.put(osName, lafName);
-                }
-
-                Iterator pit = laf.getChildrenNamed(&quot;param&quot;).iterator();
-                Map params = new TreeMap();
-                while (pit.hasNext())
-                {
-                    XMLElement param = (XMLElement) pit.next();
-                    String name = requireAttribute(param, &quot;name&quot;);
-                    String value = requireAttribute(param, &quot;value&quot;);
-                    params.put(name, value);
-                }
-                prefs.lookAndFeelParams.put(lafName, params);
-            }
-            // Load modifier
-            it = gp.getChildrenNamed(&quot;modifier&quot;).iterator();
-            while (it.hasNext())
-            {
-                XMLElement curentModifier = (XMLElement) it.next();
-                String key = requireAttribute(curentModifier, &quot;key&quot;);
-                String value = requireAttribute(curentModifier, &quot;value&quot;);
-                prefs.modifier.put(key, value);
-
-            }
-            // make sure jar contents of each are available in installer
-            // map is easier to read/modify than if tree
-            HashMap lafMap = new HashMap();
-            lafMap.put(&quot;liquid&quot;, &quot;liquidlnf.jar&quot;);
-            lafMap.put(&quot;kunststoff&quot;, &quot;kunststoff.jar&quot;);
-            lafMap.put(&quot;metouia&quot;, &quot;metouia.jar&quot;);
-            lafMap.put(&quot;looks&quot;, &quot;looks.jar&quot;);
-            lafMap.put(&quot;substance&quot;, &quot;substance.jar&quot;);
-						lafMap.put(&quot;nimbus&quot;, &quot;nimbus.jar&quot;);
-
-            // is this really what we want? a double loop? needed, since above,
-            // it's
-            // the /last/ lnf for an os which is used, so can't add during
-            // initial
-            // loop
-            Iterator kit = prefs.lookAndFeelMapping.keySet().iterator();
-            while (kit.hasNext())
-            {
-                String lafName = (String) prefs.lookAndFeelMapping.get(kit.next());
-                String lafJarName = (String) lafMap.get(lafName);
-                if (lafJarName == null) parseError(gp, &quot;Unrecognized Look and Feel: &quot; + lafName);
-
-                URL lafJarURL = findIzPackResource(&quot;lib/&quot; + lafJarName, &quot;Look and Feel Jar file&quot;,
-                        gp);
-                compiler.addJarContent(lafJarURL);
-            }
-        }
-        compiler.setGUIPrefs(prefs);
-        notifyCompilerListener(&quot;addGUIPrefs&quot;, CompilerListener.END, data);
-    }
-
-    /**
-     * Add project specific external jar files to the installer.
-     * 
-     * @param data The XML data.
-     */
-    protected void addJars(XMLElement data) throws Exception
-    {
-        notifyCompilerListener(&quot;addJars&quot;, CompilerListener.BEGIN, data);
-        Iterator iter = data.getChildrenNamed(&quot;jar&quot;).iterator();
-        while (iter.hasNext())
-        {
-            XMLElement el = (XMLElement) iter.next();
-            String src = requireAttribute(el, &quot;src&quot;);
-            URL url = findProjectResource(src, &quot;Jar file&quot;, el);
-            compiler.addJarContent(url);
-            // Additionals for mark a jar file also used in the uninstaller.
-            // The contained files will be copied from the installer into the
-            // uninstaller if needed.
-            // Therefore the contained files of the jar should be in the
-            // installer also
-            // they are used only from the uninstaller. This is the reason why
-            // the stage
-            // wiil be only observed for the uninstaller.
-            String stage = el.getAttribute(&quot;stage&quot;);
-            if (stage != null
-                    &amp;&amp; (&quot;both&quot;.equalsIgnoreCase(stage) || &quot;uninstall&quot;.equalsIgnoreCase(stage)))
-            {
-                CustomData ca = new CustomData(null, getContainedFilePaths(url), null,
-                        CustomData.UNINSTALLER_JAR);
-                compiler.addCustomJar(ca, url);
-            }
-        }
-        notifyCompilerListener(&quot;addJars&quot;, CompilerListener.END, data);
-    }
-
-    /**
-     * Add native libraries to the installer.
-     * 
-     * @param data The XML data.
-     */
-    protected void addNativeLibraries(XMLElement data) throws Exception
-    {
-        boolean needAddOns = false;
-        notifyCompilerListener(&quot;addNativeLibraries&quot;, CompilerListener.BEGIN, data);
-        Iterator iter = data.getChildrenNamed(&quot;native&quot;).iterator();
-        while (iter.hasNext())
-        {
-            XMLElement el = (XMLElement) iter.next();
-            String type = requireAttribute(el, &quot;type&quot;);
-            String name = requireAttribute(el, &quot;name&quot;);
-            String path = &quot;bin/native/&quot; + type + &quot;/&quot; + name;
-            URL url = findIzPackResource(path, &quot;Native Library&quot;, el);
-            compiler.addNativeLibrary(name, url);
-            // Additionals for mark a native lib also used in the uninstaller
-            // The lib will be copied from the installer into the uninstaller if
-            // needed.
-            // Therefore the lib should be in the installer also it is used only
-            // from
-            // the uninstaller. This is the reason why the stage wiil be only
-            // observed
-            // for the uninstaller.
-            String stage = el.getAttribute(&quot;stage&quot;);
-            List constraints = OsConstraint.getOsList(el);
-            if (stage != null
-                    &amp;&amp; (&quot;both&quot;.equalsIgnoreCase(stage) || &quot;uninstall&quot;.equalsIgnoreCase(stage)))
-            {
-                ArrayList al = new ArrayList();
-                al.add(name);
-                CustomData cad = new CustomData(null, al, constraints, CustomData.UNINSTALLER_LIB);
-                compiler.addNativeUninstallerLibrary(cad);
-                needAddOns = true;
-            }
-
-        }
-        if (needAddOns)
-        {
-            // Add the uninstaller extensions as a resource if specified
-            XMLElement root = requireChildNamed(data, &quot;info&quot;);
-            XMLElement uninstallInfo = root.getFirstChildNamed(&quot;uninstaller&quot;);
-            if (validateYesNoAttribute(uninstallInfo, &quot;write&quot;, YES))
-            {
-                URL url = findIzPackResource(&quot;lib/uninstaller-ext.jar&quot;, &quot;Uninstaller extensions&quot;,
-                        root);
-                compiler.addResource(&quot;IzPack.uninstaller-ext&quot;, url);
-            }
-
-        }
-        notifyCompilerListener(&quot;addNativeLibraries&quot;, CompilerListener.END, data);
-    }
-
-    /**
-     * Add packs and their contents to the installer.
-     * 
-     * @param data The XML data.
-     */
-    protected void addPacks(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;addPacks&quot;, CompilerListener.BEGIN, data);
-
-        // the actual adding is delegated to addPacksSingle to enable recursive
-        // parsing of refpack package definitions
-        addPacksSingle(data);
-        
-        compiler.checkDependencies();
-        compiler.checkExcludes();
-
-        notifyCompilerListener(&quot;addPacks&quot;, CompilerListener.END, data);
-    }
-
-    /**
-     * Add packs and their contents to the installer without checking 
-     * the dependencies and includes.
-     * 
-     * Helper method to recursively add more packs from refpack XML packs definitions
-     * 
-     * @param data The XML data
-     * @throws CompilerException
-     */
-    private void addPacksSingle(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;addPacksSingle&quot;, CompilerListener.BEGIN, data);
-        // Initialisation
-        XMLElement root = requireChildNamed(data, &quot;packs&quot;);
-
-        // at least one pack is required
-        Vector packElements = root.getChildrenNamed(&quot;pack&quot;);
-        Vector refPackElements = root.getChildrenNamed(&quot;refpack&quot;);
-        if (packElements.isEmpty() &amp;&amp; refPackElements.isEmpty()) parseError(root, &quot;&lt;packs&gt; requires a &lt;pack&gt; or &lt;refpack&gt;&quot;);
-
-        File baseDir = new File(basedir);
-        
-        Iterator packIter = packElements.iterator();
-        while (packIter.hasNext())
-        {
-            XMLElement el = (XMLElement) packIter.next();
-
-            // Trivial initialisations
-            String name = requireAttribute(el, &quot;name&quot;);
-            String id = el.getAttribute(&quot;id&quot;);
-            String packImgId = el.getAttribute(&quot;packImgId&quot;);
-            
-            boolean loose = &quot;true&quot;.equalsIgnoreCase(el.getAttribute(&quot;loose&quot;, &quot;false&quot;));
-            String description = requireChildNamed(el, &quot;description&quot;).getContent();
-            boolean required = requireYesNoAttribute(el, &quot;required&quot;);
-            String group = el.getAttribute(&quot;group&quot;);
-            String installGroups = el.getAttribute(&quot;installGroups&quot;);
-            String excludeGroup = el.getAttribute(&quot;excludeGroup&quot;);
-            boolean uninstall = &quot;yes&quot;.equalsIgnoreCase(el.getAttribute(&quot;uninstall&quot;, &quot;yes&quot;));
-            String parent = el.getAttribute(&quot;parent&quot;);
-            
-            String conditionid = el.getAttribute(&quot;condition&quot;);
-            
-            if(required &amp;&amp; excludeGroup != null)
-            {
-                parseError(el, &quot;Pack, which has excludeGroup can not be required.&quot;, 
-                    new Exception(&quot;Pack, which has excludeGroup can not be required.&quot;));
-            }
-            
-            PackInfo pack = new PackInfo(name, id, description, required, loose, excludeGroup, uninstall);
-            pack.setOsConstraints(OsConstraint.getOsList(el)); // TODO:
-            pack.setParent(parent);
-            pack.setCondition(conditionid);
-            
-            // unverified
-            // if the pack belongs to an excludeGroup it's not preselected by default
-            if(excludeGroup == null)
-                pack.setPreselected(validateYesNoAttribute(el, &quot;preselected&quot;, YES));
-            else
-                pack.setPreselected(validateYesNoAttribute(el, &quot;preselected&quot;, NO));
-            
-            // Set the pack group if specified
-            if (group != null)
-                pack.setGroup(group);
-            // Set the pack install groups if specified
-            if (installGroups != null)
-            {
-                StringTokenizer st = new StringTokenizer(installGroups, &quot;,&quot;);
-                while (st.hasMoreTokens())
-                {
-                    String igroup = st.nextToken();
-                    pack.addInstallGroup(igroup);
-                }
-            }
-            
-            // Set the packImgId if specified
-            if (packImgId != null) {
-                pack.setPackImgId(packImgId);
-            }
-
-            // We get the parsables list
-            Iterator iter = el.getChildrenNamed(&quot;parsable&quot;).iterator();
-            while (iter.hasNext())
-            {
-                XMLElement p = (XMLElement) iter.next();
-                String target = requireAttribute(p, &quot;targetfile&quot;);
-                String type = p.getAttribute(&quot;type&quot;, &quot;plain&quot;);
-                String encoding = p.getAttribute(&quot;encoding&quot;, null);
-                List osList = OsConstraint.getOsList(p); // TODO: unverified
-                String condition = p.getAttribute(&quot;condition&quot;);
-                ParsableFile parsable = new ParsableFile(target, type, encoding, osList);
-                parsable.setCondition(condition);
-                pack.addParsable(parsable);
-            }
-
-            // We get the executables list
-            iter = el.getChildrenNamed(&quot;executable&quot;).iterator();
-            while (iter.hasNext())
-            {
-                XMLElement e = (XMLElement) iter.next();
-                ExecutableFile executable = new ExecutableFile();
-                String val; // temp value
-                String condition = e.getAttribute(&quot;condition&quot;);
-                executable.setCondition(condition);
-                executable.path = requireAttribute(e, &quot;targetfile&quot;);
-
-                // when to execute this executable
-                val = e.getAttribute(&quot;stage&quot;, &quot;never&quot;);
-                if (&quot;postinstall&quot;.equalsIgnoreCase(val))
-                    executable.executionStage = ExecutableFile.POSTINSTALL;
-                else if (&quot;uninstall&quot;.equalsIgnoreCase(val))
-                    executable.executionStage = ExecutableFile.UNINSTALL;
-
-                // type of this executable
-                val = e.getAttribute(&quot;type&quot;, &quot;bin&quot;);
-                if (&quot;jar&quot;.equalsIgnoreCase(val))
-                {
-                    executable.type = ExecutableFile.JAR;
-                    executable.mainClass = e.getAttribute(&quot;class&quot;); // executable
-                    // class
-                }
-
-                // what to do if execution fails
-                val = e.getAttribute(&quot;failure&quot;, &quot;ask&quot;);
-                if (&quot;abort&quot;.equalsIgnoreCase(val))
-                    executable.onFailure = ExecutableFile.ABORT;
-                else if (&quot;warn&quot;.equalsIgnoreCase(val)) executable.onFailure = ExecutableFile.WARN;
-                else if (&quot;ignore&quot;.equalsIgnoreCase(val)) executable.onFailure = ExecutableFile.IGNORE;
-
-                // whether to keep the executable after executing it
-                val = e.getAttribute(&quot;keep&quot;);
-                executable.keepFile = &quot;true&quot;.equalsIgnoreCase(val);
-
-                // get arguments for this executable
-                XMLElement args = e.getFirstChildNamed(&quot;args&quot;);
-                if (null != args)
-                {
-                    Iterator argIterator = args.getChildrenNamed(&quot;arg&quot;).iterator();
-                    while (argIterator.hasNext())
-                    {
-                        XMLElement arg = (XMLElement) argIterator.next();
-                        executable.argList.add(requireAttribute(arg, &quot;value&quot;));
-                    }
-                }
-
-                executable.osList = OsConstraint.getOsList(e); // TODO:
-                // unverified
-
-                pack.addExecutable(executable);
-            }
-
-            // We get the files list
-            iter = el.getChildrenNamed(&quot;file&quot;).iterator();
-            while (iter.hasNext())
-            {
-                XMLElement f = (XMLElement) iter.next();
-                String src = requireAttribute(f, &quot;src&quot;);
-                String targetdir = requireAttribute(f, &quot;targetdir&quot;);
-                List osList = OsConstraint.getOsList(f); // TODO: unverified
-                int override = getOverrideValue(f);
-                Map additionals = getAdditionals(f);
-                boolean unpack = src.endsWith(&quot;.zip&quot;) &amp;&amp; &quot;true&quot;.equalsIgnoreCase(f.getAttribute(&quot;unpack&quot;));
-                String condition = f.getAttribute(&quot;condition&quot;);
-                
-                File file = new File(src);
-                if (!file.isAbsolute()) file = new File(basedir, src);
-
-                try
-                {
-                    if (unpack)
-                        addArchiveContent(baseDir, file, targetdir, osList, override, pack, additionals,condition);
-                    else
-                        addRecursively(baseDir, file, targetdir, osList, override, pack, additionals,condition);
-                }
-                catch (Exception x)
-                {
-                    parseError(f, x.getMessage(), x);
-                }
-            }
-
-            // We get the singlefiles list
-            iter = el.getChildrenNamed(&quot;singlefile&quot;).iterator();
-            while (iter.hasNext())
-            {
-                XMLElement f = (XMLElement) iter.next();
-                String src = requireAttribute(f, &quot;src&quot;);
-                String target = requireAttribute(f, &quot;target&quot;);
-                List osList = OsConstraint.getOsList(f); // TODO: unverified
-                int override = getOverrideValue(f);
-                Map additionals = getAdditionals(f);
-                String condition = f.getAttribute(&quot;condition&quot;);
-                File file = new File(src);
-                if (!file.isAbsolute()) file = new File(basedir, src);
-
-                try
-                {
-                    pack.addFile(baseDir, file, target, osList, override, additionals,condition);
-                }
-                catch (FileNotFoundException x)
-                {
-                    parseError(f, x.getMessage(), x);
-                }
-            }
-
-            // We get the fileset list
-            iter = el.getChildrenNamed(&quot;fileset&quot;).iterator();
-            while (iter.hasNext())
-            {
-                XMLElement f = (XMLElement) iter.next();
-                String dir_attr = requireAttribute(f, &quot;dir&quot;);
-
-                File dir = new File(dir_attr);
-                if (!dir.isAbsolute()) dir = new File(basedir, dir_attr);
-                if (!dir.isDirectory()) // also tests '.exists()'
-                    parseError(f, &quot;Invalid directory 'dir': &quot; + dir_attr);
-
-                boolean casesensitive = validateYesNoAttribute(f, &quot;casesensitive&quot;, YES);
-                boolean defexcludes = validateYesNoAttribute(f, &quot;defaultexcludes&quot;, YES);
-                String targetdir = requireAttribute(f, &quot;targetdir&quot;);
-                List osList = OsConstraint.getOsList(f); // TODO: unverified
-                int override = getOverrideValue(f);
-                Map additionals = getAdditionals(f);
-                String condition = f.getAttribute(&quot;condition&quot;);
-
-                // get includes and excludes
-                Vector xcludesList = null;
-                String[] includes = null;
-                xcludesList = f.getChildrenNamed(&quot;include&quot;);
-                if (!xcludesList.isEmpty())
-                {
-                    includes = new String[xcludesList.size()];
-                    for (int j = 0; j &lt; xcludesList.size(); j++)
-                    {
-                        XMLElement xclude = (XMLElement) xcludesList.get(j);
-                        includes[j] = requireAttribute(xclude, &quot;name&quot;);
-                    }
-                }
-                String[] excludes = null;
-                xcludesList = f.getChildrenNamed(&quot;exclude&quot;);
-                if (!xcludesList.isEmpty())
-                {
-                    excludes = new String[xcludesList.size()];
-                    for (int j = 0; j &lt; xcludesList.size(); j++)
-                    {
-                        XMLElement xclude = (XMLElement) xcludesList.get(j);
-                        excludes[j] = requireAttribute(xclude, &quot;name&quot;);
-                    }
-                }
-
-                // parse additional fileset attributes &quot;includes&quot; and &quot;excludes&quot;
-                String[] toDo = new String[] { &quot;includes&quot;, &quot;excludes&quot;};
-                // use the existing containers filled from include and exclude
-                // and add the includes and excludes to it
-                String[][] containers = new String[][] { includes, excludes};
-                for (int j = 0; j &lt; toDo.length; ++j)
-                {
-                    String inex = f.getAttribute(toDo[j]);
-                    if (inex != null &amp;&amp; inex.length() &gt; 0)
-                    { // This is the same &quot;splitting&quot; as ant PatternSet do ...
-                        StringTokenizer tok = new StringTokenizer(inex, &quot;, &quot;, false);
-                        int newSize = tok.countTokens();
-                        int k = 0;
-                        String[] nCont = null;
-                        if (containers[j] != null &amp;&amp; containers[j].length &gt; 0)
-                        { // old container exist; create a new which can hold
-                            // all values
-                            // and copy the old stuff to the front
-                            newSize += containers[j].length;
-                            nCont = new String[newSize];
-                            for (; k &lt; containers[j].length; ++k)
-                                nCont[k] = containers[j][k];
-                        }
-                        if (nCont == null) // No container for old values
-                            // created,
-                            // create a new one.
-                            nCont = new String[newSize];
-                        for (; k &lt; newSize; ++k)
-                            // Fill the new one or expand the existent container
-                            nCont[k] = tok.nextToken();
-                        containers[j] = nCont;
-                    }
-                }
-                includes = containers[0]; // push the new includes to the
-                // local var
-                excludes = containers[1]; // push the new excludes to the
-                // local var
-
-                // scan and add fileset
-                DirectoryScanner ds = new DirectoryScanner();
-                ds.setIncludes(includes);
-                ds.setExcludes(excludes);
-                if (defexcludes) ds.addDefaultExcludes();
-                ds.setBasedir(dir);
-                ds.setCaseSensitive(casesensitive);
-                ds.scan();
-
-                String[] files = ds.getIncludedFiles();
-                String[] dirs = ds.getIncludedDirectories();
-
-                // Directory scanner has done recursion, add files and
-                // directories
-                for (int i = 0; i &lt; files.length; ++i)
-                {
-                    try
-                    {
-                        String target = new File(targetdir, files[i]).getPath();
-                        pack.addFile(baseDir, new File(dir, files[i]), target, osList, override,additionals,condition);
-                    }
-                    catch (FileNotFoundException x)
-                    {
-                        parseError(f, x.getMessage(), x);
-                    }
-                }
-                for (int i = 0; i &lt; dirs.length; ++i)
-                {
-                    try
-                    {
-                        String target = new File(targetdir, dirs[i]).getPath();
-                        pack.addFile(baseDir, new File(dir, dirs[i]), target, osList, override, additionals,condition);
-                    }
-                    catch (FileNotFoundException x)
-                    {
-                        parseError(f, x.getMessage(), x);
-                    }
-                }
-            }
-
-            // get the updatechecks list
-            iter = el.getChildrenNamed(&quot;updatecheck&quot;).iterator();
-            while (iter.hasNext())
-            {
-                XMLElement f = (XMLElement) iter.next();
-
-                String casesensitive = f.getAttribute(&quot;casesensitive&quot;);
-
-                // get includes and excludes
-                ArrayList includesList = new ArrayList();
-                ArrayList excludesList = new ArrayList();
-
-                // get includes and excludes
-                Iterator include_it = f.getChildrenNamed(&quot;include&quot;).iterator();
-                while (include_it.hasNext())
-                {
-                    XMLElement inc_el = (XMLElement) include_it.next();
-                    includesList.add(requireAttribute(inc_el, &quot;name&quot;));
-                }
-
-                Iterator exclude_it = f.getChildrenNamed(&quot;exclude&quot;).iterator();
-                while (exclude_it.hasNext())
-                {
-                    XMLElement excl_el = (XMLElement) exclude_it.next();
-                    excludesList.add(requireAttribute(excl_el, &quot;name&quot;));
-                }
-
-                pack.addUpdateCheck(new UpdateCheck(includesList, excludesList, casesensitive));
-            }
-            // We get the dependencies
-            iter = el.getChildrenNamed(&quot;depends&quot;).iterator();
-            while (iter.hasNext())
-            {
-                XMLElement dep = (XMLElement) iter.next();
-                String depName = requireAttribute(dep, &quot;packname&quot;);
-                pack.addDependency(depName);
-
-            }
-            // We add the pack
-            compiler.addPack(pack);
-        }
-        
-        Iterator refPackIter = refPackElements.iterator();
-        while (refPackIter.hasNext())
-        {
-        	XMLElement el = (XMLElement) refPackIter.next();
-
-            // get the name of reference xml file
-        	String refFileName = requireAttribute(el, &quot;file&quot;);
-        	String selfcontained = el.getAttribute(&quot;selfcontained&quot;);
-        	boolean isselfcontained = Boolean.valueOf(selfcontained).booleanValue();
-        	
-        	
-        	File refXMLFile = new File(refFileName);
-            if (!refXMLFile.isAbsolute()) refXMLFile = new File(basedir, refFileName);
-            if (!refXMLFile.canRead()) {
-                throw new CompilerException(&quot;Invalid file: &quot; + refXMLFile);
-            }
-            
-            InputStream specin = null;
-            
-        	if (isselfcontained){
-        	    if (!refXMLFile.getAbsolutePath().endsWith(&quot;.zip&quot;)) {
-        	        throw new CompilerException(&quot;Invalid file: &quot; + refXMLFile + &quot;. Selfcontained files can only be of type zip.&quot;);
-        	    }
-        	    ZipFile zip;
-                try
-                {
-                    zip = new ZipFile(refXMLFile,ZipFile.OPEN_READ);
-                    ZipEntry specentry = zip.getEntry(&quot;META-INF/izpack.xml&quot;);
-                    specin = zip.getInputStream(specentry);
-                }
-                catch (IOException e)
-                {
-                    throw new CompilerException(&quot;Error reading META-INF/izpack.xml in &quot; + refXMLFile);
-                }        	    
-        	}
-        	else {
-        	    try
-                {
-                    specin = new FileInputStream(refXMLFile.getAbsolutePath());
-                }
-                catch (FileNotFoundException e)
-                {
-                    throw new CompilerException(&quot;FileNotFoundException exception while reading refXMLFile&quot;);
-                }
-        	}
-        	
-        	// Initialises the parser
-            IXMLReader refXMLReader = null;
-            
-            // Load the reference XML file                        
-            try
-            {
-            	refXMLReader = new StdXMLReader(specin);
-            }
-            catch (CompilerException c)
-            {
-            	throw new CompilerException(&quot;Compiler exception while reading refXMLFile&quot;);
-            }
-            catch (IOException io)
-            {
-            	throw new CompilerException(&quot;IOException exception while reading refXMLFile&quot;);
-            }
-            
-            StdXMLParser refXMLParser = new StdXMLParser();
-            refXMLParser.setBuilder(XMLBuilderFactory.createXMLBuilder());
-            refXMLParser.setReader(refXMLReader);
-            refXMLParser.setValidator(new NonValidator());
-
-            // We get it
-            XMLElement refXMLData = null;
-            try
-            {
-                refXMLData = (XMLElement) refXMLParser.parse();
-                
-            }
-            catch (XMLException x)
-            {
-                throw new CompilerException(&quot;Error parsing installation file&quot;, x);
-            }
-            
-            // Now checked the loaded XML file for basic syntax
-            // We check it
-            if (!&quot;installation&quot;.equalsIgnoreCase(refXMLData.getName())) {
-                parseError(refXMLData, &quot;this is not an IzPack XML installation file&quot;);
-            }
-            if (!VERSION.equalsIgnoreCase(requireAttribute(refXMLData, &quot;version&quot;))) {
-                parseError(refXMLData, &quot;the file version is different from the compiler version&quot;);
-            }
-            
-            // Read the properties and perform replacement on the rest of the tree
-            substituteProperties(refXMLData);
-            
-            // call addResources to add the referenced XML resources to this installation
-            addResources(refXMLData);
-            
-            try
-            {
-                specin.close();
-            }
-            catch (IOException e)
-            {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
-            // Recursively call myself to add all packs and refpacks from the reference XML
-            addPacksSingle(refXMLData);
-        }
-        notifyCompilerListener(&quot;addPacksSingle&quot;, CompilerListener.END, data);
-    }
-
-    /**
-     * Checks whether the dependencies stated in the configuration file are correct. Specifically it
-     * checks that no pack point to a non existent pack and also that there are no circular
-     * dependencies in the packs.
-     */
-    public void checkDependencies(List packs) throws CompilerException
-    {
-        // Because we use package names in the configuration file we assosiate
-        // the names with the objects
-        Map names = new HashMap();
-        for (int i = 0; i &lt; packs.size(); i++)
-        {
-            PackInfo pack = (PackInfo) packs.get(i);
-            names.put(pack.getPack().name, pack);
-        }
-        int result = dfs(packs, names);
-        // @todo More informative messages to include the source of the error
-        if (result == -2)
-            parseError(&quot;Circular dependency detected&quot;);
-        else if (result == -1) parseError(&quot;A dependency doesn't exist&quot;);
-    }
-
-    /**
-     * We use the dfs graph search algorithm to check whether the graph is acyclic as described in:
-     * Thomas H. Cormen, Charles Leiserson, Ronald Rivest and Clifford Stein. Introduction to
-     * algorithms 2nd Edition 540-549,MIT Press, 2001
-     * 
-     * @param packs The graph
-     * @param names The name map
-     */
-    private int dfs(List packs, Map names)
-    {
-        Map edges = new HashMap();
-        for (int i = 0; i &lt; packs.size(); i++)
-        {
-            PackInfo pack = (PackInfo) packs.get(i);
-            if (pack.colour == PackInfo.WHITE)
-            {
-                if (dfsVisit(pack, names, edges) != 0) return -1;
-            }
-
-        }
-        return checkBackEdges(edges);
-    }
-
-    /**
-     * This function checks for the existence of back edges.
-     */
-    private int checkBackEdges(Map edges)
-    {
-        Set keys = edges.keySet();
-        for (Iterator iterator = keys.iterator(); iterator.hasNext();)
-        {
-            final Object key = iterator.next();
-            int color = ((Integer) edges.get(key)).intValue();
-            if (color == PackInfo.GREY) { return -2; }
-        }
-        return 0;
-
-    }
-
-    /**
-     * This class is used for the classification of the edges
-     */
-    private class Edge
-    {
-
-        PackInfo u;
-
-        PackInfo v;
-
-        Edge(PackInfo u, PackInfo v)
-        {
-            this.u = u;
-            this.v = v;
-        }
-    }
-
-    private int dfsVisit(PackInfo u, Map names, Map edges)
-    {
-        u.colour = PackInfo.GREY;
-        List deps = u.getDependencies();
-        if (deps != null)
-        {
-            for (int i = 0; i &lt; deps.size(); i++)
-            {
-                String name = (String) deps.get(i);
-                PackInfo v = (PackInfo) names.get(name);
-                if (v == null)
-                {
-                    System.out.println(&quot;Failed to find dependency: &quot;+name);
-                    return -1;
-                }
-                Edge edge = new Edge(u, v);
-                if (edges.get(edge) == null) edges.put(edge, new Integer(v.colour));
-
-                if (v.colour == PackInfo.WHITE)
-                {
-
-                    final int result = dfsVisit(v, names, edges);
-                    if (result != 0) return result;
-                }
-            }
-        }
-        u.colour = PackInfo.BLACK;
-        return 0;
-    }
-
-    /**
-     * Add files in an archive to a pack
-     * @param archive the archive file to unpack
-     * @parm targetdir the target directory where the content of the archive will be installed
-     * @param osList The target OS constraints.
-     * @param override Overriding behaviour.
-     * @param pack Pack to be packed into
-     * @param additionals Map which contains additional data
-     * @param condition 
-     */
-    protected void addArchiveContent(File baseDir, File archive, String targetdir, List osList, int override, PackInfo pack, Map additionals, String condition) throws IOException {
-      
-      FileInputStream fin = new FileInputStream(archive);
-      ZipInputStream zin = new ZipInputStream(fin);
-      while (true) {
-        ZipEntry zentry = zin.getNextEntry();
-        if (zentry==null) break;
-        if (zentry.isDirectory()) continue;
-        
-        try {
-            File temp = File.createTempFile(&quot;izpack&quot;, null);
-            temp.deleteOnExit();
-            
-            FileOutputStream out = new FileOutputStream(temp);
-            PackagerHelper.copyStream(zin, out);
-            out.close();
-        
-            pack.addFile(baseDir, temp, targetdir + &quot;/&quot; + zentry.getName(), osList, override, additionals,condition);
-        } catch (IOException e) {
-            throw new IOException(&quot;Couldn't create temporary file for &quot;+zentry.getName()+&quot; in archive &quot;+archive+&quot; (&quot;+e.getMessage()+&quot;)&quot;);
-        }
-        
-      }
-      fin.close();
-    }
-    
-    /**
-     * Recursive method to add files in a pack.
-     * 
-     * @param file The file to add.
-     * @param targetdir The relative path to the parent.
-     * @param osList The target OS constraints.
-     * @param override Overriding behaviour.
-     * @param pack Pack to be packed into
-     * @param additionals Map which contains additional data
-     * @param condition 
-     * @exception FileNotFoundException if the file does not exist
-     */
-    protected void addRecursively(File baseDir, File file, String targetdir, List osList, int override,
-            PackInfo pack, Map additionals, String condition) throws IOException
-    {
-        String targetfile = targetdir + &quot;/&quot; + file.getName();
-        if (!file.isDirectory())
-            pack.addFile(baseDir, file, targetfile, osList, override, additionals,condition);
-        else
-        {
-            File[] files = file.listFiles();
-            if (files.length == 0) // The directory is empty so must be added
-                pack.addFile(baseDir, file, targetfile, osList, override, additionals,condition);
-            else
-            {
-                // new targetdir = targetfile;
-                for (int i = 0; i &lt; files.length; i++)
-                    addRecursively(baseDir, files[i], targetfile, osList, override, pack, additionals,condition);
-            }
-        }
-    }
-
-    /**
-     * Parse panels and their paramters, locate the panels resources and add to the Packager.
-     * 
-     * @param data The XML data.
-     * @exception CompilerException Description of the Exception
-     */
-    protected void addPanels(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;addPanels&quot;, CompilerListener.BEGIN, data);
-        XMLElement root = requireChildNamed(data, &quot;panels&quot;);
-
-        // at least one panel is required
-        Vector panels = root.getChildrenNamed(&quot;panel&quot;);
-        if (panels.isEmpty()) parseError(root, &quot;&lt;panels&gt; requires a &lt;panel&gt;&quot;);
-
-        // We process each panel markup
-        Iterator iter = panels.iterator();
-        while (iter.hasNext())
-        {
-            XMLElement xmlPanel = (XMLElement) iter.next();
-
-            // create the serialized Panel data
-            Panel panel = new Panel();
-            panel.osConstraints = OsConstraint.getOsList(xmlPanel);
-            String className = xmlPanel.getAttribute(&quot;classname&quot;);
-            // add an id
-            String panelid = xmlPanel.getAttribute(&quot;id&quot;);
-            panel.setPanelid(panelid);                   
-            String condition = xmlPanel.getAttribute(&quot;condition&quot;);
-            panel.setCondition(condition);
-            
-            // Panel files come in jars packaged w/ IzPack
-            String jarPath = &quot;bin/panels/&quot; + className + &quot;.jar&quot;;
-            URL url = findIzPackResource(jarPath, &quot;Panel jar file&quot;, xmlPanel);
-            String fullClassName = null;
-            try
-            {
-                fullClassName = getFullClassName(url, className);
-            }
-            catch (IOException e)
-            {
-            }
-            if (fullClassName != null)
-                panel.className = fullClassName;
-            else
-                panel.className = className;
-            // insert into the packager
-            compiler.addPanelJar(panel, url);
-        }
-        notifyCompilerListener(&quot;addPanels&quot;, CompilerListener.END, data);
-    }
-
-    /**
-     * Adds the resources.
-     * 
-     * @param data The XML data.
-     * @exception CompilerException Description of the Exception
-     */
-    protected void addResources(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;addResources&quot;, CompilerListener.BEGIN, data);
-        XMLElement root = data.getFirstChildNamed(&quot;resources&quot;);
-        if (root == null) return;
-
-        // We process each res markup
-        Iterator iter = root.getChildrenNamed(&quot;res&quot;).iterator();
-        while (iter.hasNext())
-        {
-            XMLElement res = (XMLElement) iter.next();
-            String id = requireAttribute(res, &quot;id&quot;);
-            String src = requireAttribute(res, &quot;src&quot;);
-            // the parse attribute causes substitution to occur
-            boolean substitute = validateYesNoAttribute(res, &quot;parse&quot;, NO);
-            // the parsexml attribute causes the xml document to be parsed 
-            boolean parsexml = validateYesNoAttribute(res, &quot;parsexml&quot;, NO);
-
-            // basedir is not prepended if src is already an absolute path
-            URL originalUrl = findProjectResource(src, &quot;Resource&quot;, res);
-            URL url = originalUrl;
-
-            InputStream is = null;
-            OutputStream os = null;
-            try
-            {
-                if (parsexml ||
-                    (substitute &amp;&amp; !compiler.getVariables().isEmpty()))
-                {
-                    // make the substitutions into a temp file
-                    File parsedFile = File.createTempFile(&quot;izpp&quot;, null);
-                    parsedFile.deleteOnExit();
-                    FileOutputStream outFile = new FileOutputStream(parsedFile);
-                    os = new BufferedOutputStream(outFile);
-                    // and specify the substituted file to be added to the
-                    // packager
-                    url = parsedFile.toURL();
-                }
-
-                if (parsexml)
-                {               
-                    IXMLParser parser = XMLParserFactory.createDefaultXMLParser();
-                    // this constructor will open the specified url (this is
-                    // why the InputStream is not handled in a similar manner
-                    // to the OutputStream)
-                    IXMLReader reader = new StdXMLReader(null, url.toExternalForm());
-                    parser.setReader(reader);
-                    XMLElement xml = (XMLElement) parser.parse();
-
-                    if (substitute &amp;&amp; !compiler.getVariables().isEmpty()) {
-                        // if we are also performing substitutions on the file
-                        // then create an in-memory copy to pass to the
-                        // substitutor
-                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                        XMLWriter xmlWriter = new XMLWriter(baos);
-                        xmlWriter.write(xml);
-                        is = new ByteArrayInputStream(baos.toByteArray());
-                    } else {
-                        // otherwise write direct to the temp file
-                        XMLWriter xmlWriter = new XMLWriter(os);
-                        xmlWriter.write(xml);
-                    }
-                }
-
-                // substitute variable values in the resource if parsed
-                if (substitute)
-                {
-                    if (compiler.getVariables().isEmpty())
-                    {
-                        // reset url to original.
-                        url = originalUrl;
-                        parseWarn(res, &quot;No variables defined. &quot; + url.getPath() + &quot; not parsed.&quot;);
-                    }
-                    else
-                    {
-                        String type = res.getAttribute(&quot;type&quot;);
-                        String encoding = res.getAttribute(&quot;encoding&quot;);
-
-                        // if the xml parser did not open the url
-                        // ('parsexml' was not enabled)
-                        if (null == is) {
-                            is = new BufferedInputStream(url.openStream());
-                        }
-                        VariableSubstitutor vs = new VariableSubstitutor(compiler.getVariables());
-                        vs.substitute(is, os, type, encoding);
-                    }
-                }
-
-            } catch (Exception e)
-            {
-                parseError(res, e.getMessage(), e);
-            } finally {
-                if (null != os) {
-                    try {
-                        os.close();
-                    } catch (IOException e) {
-                        // ignore as there is nothing we can realistically do
-                        // so lets at least try to close the input stream
-                    }
-                }
-                if (null != is) {
-                    try {
-                        is.close();
-                    } catch (IOException e) {
-                        // ignore as there is nothing we can realistically do
-                    }
-                }
-            }
-
-            compiler.addResource(id, url);
-        }
-        notifyCompilerListener(&quot;addResources&quot;, CompilerListener.END, data);
-    }
-
-    /**
-     * Adds the ISO3 codes of the langpacks and associated resources.
-     * 
-     * @param data The XML data.
-     * @exception CompilerException Description of the Exception
-     */
-    protected void addLangpacks(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;addLangpacks&quot;, CompilerListener.BEGIN, data);
-        XMLElement root = requireChildNamed(data, &quot;locale&quot;);
-
-        // at least one langpack is required
-        Vector locals = root.getChildrenNamed(&quot;langpack&quot;);
-        if (locals.isEmpty()) parseError(root, &quot;&lt;locale&gt; requires a &lt;langpack&gt;&quot;);
-
-        // We process each langpack markup
-        Iterator iter = locals.iterator();
-        while (iter.hasNext())
-        {
-            XMLElement el = (XMLElement) iter.next();
-            String iso3 = requireAttribute(el, &quot;iso3&quot;);
-            String path;
-
-            path = &quot;bin/langpacks/installer/&quot; + iso3 + &quot;.xml&quot;;
-            URL iso3xmlURL = findIzPackResource(path, &quot;ISO3 file&quot;, el);
-
-            path = &quot;bin/langpacks/flags/&quot; + iso3 + &quot;.gif&quot;;
-            URL iso3FlagURL = findIzPackResource(path, &quot;ISO3 flag image&quot;, el);
-
-            compiler.addLangPack(iso3, iso3xmlURL, iso3FlagURL);
-        }
-        notifyCompilerListener(&quot;addLangpacks&quot;, CompilerListener.END, data);
-    }
-
-    /**
-     * Builds the Info class from the XML tree.
-     * 
-     * @param data The XML data. return The Info.
-     * @exception Exception Description of the Exception
-     */
-    protected void addInfo(XMLElement data) throws Exception
-    {
-        notifyCompilerListener(&quot;addInfo&quot;, CompilerListener.BEGIN, data);
-        // Initialisation
-        XMLElement root = requireChildNamed(data, &quot;info&quot;);
-
-        Info info = new Info();
-        info.setAppName(requireContent(requireChildNamed(root, &quot;appname&quot;)));
-        info.setAppVersion(requireContent(requireChildNamed(root, &quot;appversion&quot;)));
-        // We get the installation subpath
-        XMLElement subpath = root.getFirstChildNamed(&quot;appsubpath&quot;);
-        if (subpath != null)
-        {
-            info.setInstallationSubPath(requireContent(subpath));
-        }
-
-        // validate and insert app URL
-        final XMLElement URLElem = root.getFirstChildNamed(&quot;url&quot;);
-        if (URLElem != null)
-        {
-            URL appURL = requireURLContent(URLElem);
-            info.setAppURL(appURL.toString());
-        }
-
-        // We get the authors list
-        XMLElement authors = root.getFirstChildNamed(&quot;authors&quot;);
-        if (authors != null)
-        {
-            Iterator iter = authors.getChildrenNamed(&quot;author&quot;).iterator();
-            while (iter.hasNext())
-            {
-                XMLElement author = (XMLElement) iter.next();
-                String name = requireAttribute(author, &quot;name&quot;);
-                String email = requireAttribute(author, &quot;email&quot;);
-                info.addAuthor(new Info.Author(name, email));
-            }
-        }
-
-        // We get the java version required
-        XMLElement javaVersion = root.getFirstChildNamed(&quot;javaversion&quot;);
-        if (javaVersion != null) info.setJavaVersion(requireContent(javaVersion));
-
-        // Is a JDK required?
-        XMLElement jdkRequired = root.getFirstChildNamed(&quot;requiresjdk&quot;);
-        if (jdkRequired != null) info.setJdkRequired(&quot;yes&quot;.equals(jdkRequired.getContent()));
-
-        // validate and insert (and require if -web kind) web dir
-        XMLElement webDirURL = root.getFirstChildNamed(&quot;webdir&quot;);
-        if (webDirURL != null) info.setWebDirURL(requireURLContent(webDirURL).toString());
-        String kind = compiler.getKind();
-        if (kind != null)
-        {
-            if (kind.equalsIgnoreCase(WEB) &amp;&amp; webDirURL == null)
-            {
-                parseError(root, &quot;&lt;webdir&gt; required when \&quot;WEB\&quot; installer requested&quot;);
-            }
-            else if (kind.equalsIgnoreCase(STANDARD) &amp;&amp; webDirURL != null)
-            {
-                // Need a Warning? parseWarn(webDirURL, &quot;Not creating web
-                // installer.&quot;);
-                info.setWebDirURL(null);
-            }
-        }
-
-        // Add the uninstaller as a resource if specified
-        XMLElement uninstallInfo = root.getFirstChildNamed(&quot;uninstaller&quot;);
-        if (validateYesNoAttribute(uninstallInfo, &quot;write&quot;, YES))
-        {
-            URL url = findIzPackResource(&quot;lib/uninstaller.jar&quot;, &quot;Uninstaller&quot;, root);
-            compiler.addResource(&quot;IzPack.uninstaller&quot;, url);
-
-            if (uninstallInfo != null)
-            {
-                String uninstallerName = uninstallInfo.getAttribute(&quot;name&quot;);
-                if (uninstallerName != null &amp;&amp; uninstallerName.length() &gt; &quot;.jar&quot;.length())
-                    info.setUninstallerName(uninstallerName);
-            }
-        }
-        // Add the path for the summary log file if specified
-        XMLElement slfPath = root.getFirstChildNamed(&quot;summarylogfilepath&quot;);
-        if (slfPath != null) info.setSummaryLogFilePath(requireContent(slfPath));
-
-        // look for an unpacker class
-        String unpackerclass = compiler.getProperty(&quot;UNPACKER_CLASS&quot;);
-        info.setUnpackerClassName(unpackerclass);
-        compiler.setInfo(info);
-        notifyCompilerListener(&quot;addInfo&quot;, CompilerListener.END, data);
-    }
-
-    /**
-     * Variable declaration is a fragment of the xml file. For example:
-     * 
-     * &lt;pre&gt;
-     * 
-     *  
-     *   
-     *    
-     *        &amp;lt;variables&amp;gt;
-     *          &amp;lt;variable name=&amp;quot;nom&amp;quot; value=&amp;quot;value&amp;quot;/&amp;gt;
-     *          &amp;lt;variable name=&amp;quot;foo&amp;quot; value=&amp;quot;pippo&amp;quot;/&amp;gt;
-     *        &amp;lt;/variables&amp;gt;
-     *      
-     *    
-     *   
-     *  
-     * &lt;/pre&gt;
-     * 
-     * variable declared in this can be referred to in parsable files.
-     * 
-     * @param data The XML data.
-     * @exception CompilerException Description of the Exception
-     */
-    protected void addVariables(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;addVariables&quot;, CompilerListener.BEGIN, data);
-        // We get the varible list
-        XMLElement root = data.getFirstChildNamed(&quot;variables&quot;);
-        if (root == null) return;
-
-        Properties variables = compiler.getVariables();
-
-        Iterator iter = root.getChildrenNamed(&quot;variable&quot;).iterator();
-        while (iter.hasNext())
-        {
-            XMLElement var = (XMLElement) iter.next();
-            String name = requireAttribute(var, &quot;name&quot;);
-            String value = requireAttribute(var, &quot;value&quot;);
-            if (variables.contains(name))
-                parseWarn(var, &quot;Variable '&quot; + name + &quot;' being overwritten&quot;);
-            variables.setProperty(name, value);
-        }
-        notifyCompilerListener(&quot;addVariables&quot;, CompilerListener.END, data);
-    }
-    
-    protected void addDynamicVariables(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;addDynamicVariables&quot;, CompilerListener.BEGIN, data);
-        // We get the dynamic variable list
-        XMLElement root = data.getFirstChildNamed(&quot;dynamicvariables&quot;);
-        if (root == null) return;
-
-        Map dynamicvariables = compiler.getDynamicVariables();
-
-        Iterator iter = root.getChildrenNamed(&quot;variable&quot;).iterator();
-        while (iter.hasNext())
-        {
-            XMLElement var = (XMLElement) iter.next();
-            String name = requireAttribute(var, &quot;name&quot;);
-            String value = requireAttribute(var, &quot;value&quot;);
-            String conditionid = var.getAttribute(&quot;condition&quot;);
-            if (dynamicvariables.containsKey(name))
-                parseWarn(var, &quot;DynamicVariable '&quot; + name + &quot;' being overwritten&quot;);
-            DynamicVariable dynvar = new DynamicVariable();
-            dynvar.setName(name);
-            dynvar.setValue(value);
-            dynvar.setConditionid(conditionid);
-            dynamicvariables.put(name, dynvar);
-        }
-        notifyCompilerListener(&quot;addDynamicVariables&quot;, CompilerListener.END, data);
-    }
-    
-    /**
-     * Parse conditions and add them to the compiler.
-     * @param data
-     * @throws CompilerException
-     */
-    protected void addConditions(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;addConditions&quot;, CompilerListener.BEGIN, data);
-        // We get the condition list
-        XMLElement root = data.getFirstChildNamed(&quot;conditions&quot;);
-        Map conditions = compiler.getConditions();
-        if (root != null) {               
-            Iterator iter = root.getChildrenNamed(&quot;condition&quot;).iterator();
-            while (iter.hasNext())
-            {
-                XMLElement conditionel = (XMLElement) iter.next();
-                Condition condition = RulesEngine.analyzeCondition(conditionel);
-                if (condition != null) {
-                    String conditionid = condition.getId();
-                    if (conditions.containsKey(conditionid))
-                    {
-                        parseWarn(conditionel, &quot;Condition with id '&quot; + conditionid + &quot;' will be overwritten&quot;);
-                    }
-                    conditions.put(conditionid, condition);
-                    
-                }
-                else {
-                    parseWarn(conditionel, &quot;Condition couldn't be instantiated.&quot;);
-                }
-            }
-        }        
-        notifyCompilerListener(&quot;addConditions&quot;, CompilerListener.END, data);
-    }
-    
-
-    /**
-     * Properties declaration is a fragment of the xml file. For example:
-     * 
-     * &lt;pre&gt;
-     * 
-     *  
-     *   
-     *    
-     *        &amp;lt;properties&amp;gt;
-     *          &amp;lt;property name=&amp;quot;app.name&amp;quot; value=&amp;quot;Property Laden Installer&amp;quot;/&amp;gt;
-     *          &amp;lt;!-- Ant styles 'location' and 'refid' are not yet supported --&amp;gt;
-     *          &amp;lt;property file=&amp;quot;filename-relative-to-install?&amp;quot;/&amp;gt;
-     *          &amp;lt;property file=&amp;quot;filename-relative-to-install?&amp;quot; prefix=&amp;quot;prefix&amp;quot;/&amp;gt;
-     *          &amp;lt;!-- Ant style 'url' and 'resource' are not yet supported --&amp;gt;
-     *          &amp;lt;property environment=&amp;quot;prefix&amp;quot;/&amp;gt;
-     *        &amp;lt;/properties&amp;gt;
-     *      
-     *    
-     *   
-     *  
-     * &lt;/pre&gt;
-     * 
-     * variable declared in this can be referred to in parsable files.
-     * 
-     * @param data The XML data.
-     * @exception CompilerException Description of the Exception
-     */
-    protected void substituteProperties(XMLElement data) throws CompilerException
-    {
-        notifyCompilerListener(&quot;substituteProperties&quot;, CompilerListener.BEGIN, data);
-
-        XMLElement root = data.getFirstChildNamed(&quot;properties&quot;);
-        if (root != null)
-        {
-            // add individual properties
-            Iterator iter = root.getChildrenNamed(&quot;property&quot;).iterator();
-            while (iter.hasNext())
-            {
-                XMLElement prop = (XMLElement) iter.next();
-                Property property = new Property(prop, this);
-                property.execute();
-            }
-        }
-
-        // temporarily remove the 'properties' branch, replace all properties in
-        // the remaining DOM, and replace properties branch.
-        // TODO: enhance XMLElement with an &quot;indexOf(XMLElement)&quot; method
-        // and addChild(XMLElement, int) so returns to the same place.
-        if (root != null) data.removeChild(root);
-
-        substituteAllProperties(data);
-        if (root != null) data.addChild(root);
-
-        notifyCompilerListener(&quot;substituteProperties&quot;, CompilerListener.END, data);
-    }
-
-    /**
-     * Perform recursive substitution on all properties
-     */
-    protected void substituteAllProperties(XMLElement element) throws CompilerException
-    {
-        Enumeration attributes = element.enumerateAttributeNames();
-        while (attributes.hasMoreElements())
-        {
-            String name = (String) attributes.nextElement();
-            String value = compiler.replaceProperties(element.getAttribute(name));
-            element.setAttribute(name, value);
-        }
-
-        String content = element.getContent();
-        if (content != null)
-        {
-            element.setContent(compiler.replaceProperties(content));
-        }
-
-        Enumeration children = element.enumerateChildren();
-        while (children.hasMoreElements())
-        {
-            XMLElement child = (XMLElement) children.nextElement();
-            substituteAllProperties(child);
-        }
-    }
-
-    /**
-     * Returns the XMLElement representing the installation XML file.
-     * 
-     * @return The XML tree.
-     * @exception CompilerException For problems with the installation file
-     * @exception IOException for errors reading the installation file
-     */
-    protected XMLElement getXMLTree() throws CompilerException, IOException
-    {
-        // Initialises the parser
-        IXMLReader reader = null;
-        if( filename != null )
-        {
-            File file = new File(filename).getAbsoluteFile();
-            if (!file.canRead()) throw new CompilerException(&quot;Invalid file: &quot; + file);
-            reader = new StdXMLReader(new FileInputStream(filename));
-            // add izpack built in property
-            compiler.setProperty(&quot;izpack.file&quot;, file.toString());
-        }
-        else if( installText != null )
-        {
-            reader = StdXMLReader.stringReader(installText);
-        }
-        else
-        {
-            throw new CompilerException(&quot;Neither install file nor text specified&quot;);
-        }
-
-        StdXMLParser parser = new StdXMLParser();
-        parser.setBuilder(XMLBuilderFactory.createXMLBuilder());
-        parser.setReader(reader);
-        parser.setValidator(new NonValidator());
-
-        // We get it
-        XMLElement data = null;
-        try
-        {
-            data = (XMLElement) parser.parse();
-        }
-        catch (Exception x)
-        {
-            throw new CompilerException(&quot;Error parsing installation file&quot;, x);
-        }
-
-        // We check it
-        if (!&quot;installation&quot;.equalsIgnoreCase(data.getName()))
-            parseError(data, &quot;this is not an IzPack XML installation file&quot;);
-        if (!VERSION.equalsIgnoreCase(requireAttribute(data, &quot;version&quot;)))
-            parseError(data, &quot;the file version is different from the compiler version&quot;);
-
-        // We finally return the tree
-        return data;
-    }
-
-    protected int getOverrideValue(XMLElement f) throws CompilerException
-    {
-        int override = PackFile.OVERRIDE_UPDATE;
-
-        String override_val = f.getAttribute(&quot;override&quot;);
-        if (override_val != null)
-        {
-            if (&quot;true&quot;.equalsIgnoreCase(override_val))
-            {
-                override = PackFile.OVERRIDE_TRUE;
-            }
-            else if (&quot;false&quot;.equalsIgnoreCase(override_val))
-            {
-                override = PackFile.OVERRIDE_FALSE;
-            }
-            else if (&quot;asktrue&quot;.equalsIgnoreCase(override_val))
-            {
-                override = PackFile.OVERRIDE_ASK_TRUE;
-            }
-            else if (&quot;askfalse&quot;.equalsIgnoreCase(override_val))
-            {
-                override = PackFile.OVERRIDE_ASK_FALSE;
-            }
-            else if (&quot;update&quot;.equalsIgnoreCase(override_val))
-            {
-                override = PackFile.OVERRIDE_UPDATE;
-            }
-            else
-                parseError(f, &quot;invalid value for attribute \&quot;override\&quot;&quot;);
-        }
-
-        return override;
-    }
-
-    /**
-     * Look for a project specified resources, which, if not absolute, are sought relative to the
-     * projects basedir. The path should use '/' as the fileSeparator. If the resource is not found,
-     * a CompilerException is thrown indicating fault in the parent element.
-     * 
-     * @param path the relative path (using '/' as separator) to the resource.
-     * @param desc the description of the resource used to report errors
-     * @param parent the XMLElement the resource is specified in, used to report errors
-     * @return a URL to the resource.
-     */
-    private URL findProjectResource(String path, String desc, XMLElement parent)
-            throws CompilerException
-    {
-        URL url = null;
-        File resource = new File(path);
-        if (!resource.isAbsolute()) resource = new File(basedir, path);
-
-        if (!resource.exists()) // fatal
-            parseError(parent, desc + &quot; not found: &quot; + resource);
-
-        try
-        {
-            url = resource.toURL();
-        }
-        catch (MalformedURLException how)
-        {
-            parseError(parent, desc + &quot;(&quot; + resource + &quot;)&quot;, how);
-        }
-
-        return url;
-    }
-
-    /**
-     * Look for an IzPack resource either in the compiler jar, or within IZPACK_HOME. The path must
-     * not be absolute. The path must use '/' as the fileSeparator (it's used to access the jar
-     * file). If the resource is not found, a CompilerException is thrown indicating fault in the
-     * parent element.
-     * 
-     * @param path the relative path (using '/' as separator) to the resource.
-     * @param desc the description of the resource used to report errors
-     * @param parent the XMLElement the resource is specified in, used to report errors
-     * @return a URL to the resource.
-     */
-    private URL findIzPackResource(String path, String desc, XMLElement parent)
-            throws CompilerException
-    {
-        URL url = getClass().getResource(&quot;/&quot; + path);
-        if (url == null)
-        {
-            File resource = new File(path);
-
-            if (!resource.isAbsolute()) resource = new File(Compiler.IZPACK_HOME, path);
-
-            if (!resource.exists()) // fatal
-                parseError(parent, desc + &quot; not found: &quot; + resource);
-
-            try
-            {
-                url = resource.toURL();
-            }
-            catch (MalformedURLException how)
-            {
-                parseError(parent, desc + &quot;(&quot; + resource + &quot;)&quot;, how);
-            }
-        }
-
-        return url;
-    }
-
-    /**
-     * Create parse error with consistent messages. Includes file name. For use When parent is
-     * unknown.
-     * 
-     * @param message Brief message explaining error
-     */
-    protected void parseError(String message) throws CompilerException
-    {
-        throw new CompilerException(filename + &quot;:&quot; + message);
-    }
-
-    /**
-     * Create parse error with consistent messages. Includes file name and line # of parent. It is
-     * an error for 'parent' to be null.
-     * 
-     * @param parent The element in which the error occured
-     * @param message Brief message explaining error
-     */
-    protected void parseError(XMLElement parent, String message) throws CompilerException
-    {
-        throw new CompilerException(filename + &quot;:&quot; + parent.getLineNr() + &quot;: &quot; + message);
-    }
-
-    /**
-     * Create a chained parse error with consistent messages. Includes file name and line # of
-     * parent. It is an error for 'parent' to be null.
-     * 
-     * @param parent The element in which the error occured
-     * @param message Brief message explaining error
-     */
-    protected void parseError(XMLElement parent, String message, Throwable cause)
-            throws CompilerException
-    {
-        throw new CompilerException(filename + &quot;:&quot; + parent.getLineNr() + &quot;: &quot; + message, cause);
-    }
-
-    /**
-     * Create a parse warning with consistent messages. Includes file name and line # of parent. It
-     * is an error for 'parent' to be null.
-     * 
-     * @param parent The element in which the warning occured
-     * @param message Warning message
-     */
-    protected void parseWarn(XMLElement parent, String message)
-    {
-        System.out.println(filename + &quot;:&quot; + parent.getLineNr() + &quot;: &quot; + message);
-    }
-
-    /**
-     * Call getFirstChildNamed on the parent, producing a meaningful error message on failure. It is
-     * an error for 'parent' to be null.
-     * 
-     * @param parent The element to search for a child
-     * @param name Name of the child element to get
-     */
-    protected XMLElement requireChildNamed(XMLElement parent, String name) throws CompilerException
-    {
-        XMLElement child = parent.getFirstChildNamed(name);
-        if (child == null)
-            parseError(parent, &quot;&lt;&quot; + parent.getName() + &quot;&gt; requires child &lt;&quot; + name + &quot;&gt;&quot;);
-        return child;
-    }
-
-    /**
-     * Call getContent on an element, producing a meaningful error message if not present, or empty,
-     * or a valid URL. It is an error for 'element' to be null.
-     * 
-     * @param element The element to get content of
-     */
-    protected URL requireURLContent(XMLElement element) throws CompilerException
-    {
-        URL url = null;
-        try
-        {
-            url = new URL(requireContent(element));
-        }
-        catch (MalformedURLException x)
-        {
-            parseError(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; requires valid URL&quot;, x);
-        }
-        return url;
-    }
-
-    /**
-     * Call getContent on an element, producing a meaningful error message if not present, or empty.
-     * It is an error for 'element' to be null.
-     * 
-     * @param element The element to get content of
-     */
-    protected String requireContent(XMLElement element) throws CompilerException
-    {
-        String content = element.getContent();
-        if (content == null || content.length() == 0)
-            parseError(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; requires content&quot;);
-        return content;
-    }
-
-    /**
-     * Call getAttribute on an element, producing a meaningful error message if not present, or
-     * empty. It is an error for 'element' or 'attribute' to be null.
-     * 
-     * @param element The element to get the attribute value of
-     * @param attribute The name of the attribute to get
-     */
-    protected String requireAttribute(XMLElement element, String attribute)
-            throws CompilerException
-    {
-        String value = element.getAttribute(attribute);
-        if (value == null)
-            parseError(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; requires attribute '&quot; + attribute
-                    + &quot;'&quot;);
-        return value;
-    }
-
-    /**
-     * Get a required attribute of an element, ensuring it is an integer. A meaningful error message
-     * is generated as a CompilerException if not present or parseable as an int. It is an error for
-     * 'element' or 'attribute' to be null.
-     * 
-     * @param element The element to get the attribute value of
-     * @param attribute The name of the attribute to get
-     */
-    protected int requireIntAttribute(XMLElement element, String attribute)
-            throws CompilerException
-    {
-        String value = element.getAttribute(attribute);
-        if (value == null || value.length() == 0)
-            parseError(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; requires attribute '&quot; + attribute
-                    + &quot;'&quot;);
-        try
-        {
-            return Integer.parseInt(value);
-        }
-        catch (NumberFormatException x)
-        {
-            parseError(element, &quot;'&quot; + attribute + &quot;' must be an integer&quot;);
-        }
-        return 0; // never happens
-    }
-
-    /**
-     * Call getAttribute on an element, producing a meaningful error message if not present, or one
-     * of &quot;yes&quot; or &quot;no&quot;. It is an error for 'element' or 'attribute' to be null.
-     * 
-     * @param element The element to get the attribute value of
-     * @param attribute The name of the attribute to get
-     */
-    protected boolean requireYesNoAttribute(XMLElement element, String attribute)
-            throws CompilerException
-    {
-        String value = requireAttribute(element, attribute);
-        if (&quot;yes&quot;.equalsIgnoreCase(value)) return true;
-        if (&quot;no&quot;.equalsIgnoreCase(value)) return false;
-
-        parseError(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; invalid attribute '&quot; + attribute
-                + &quot;': Expected (yes|no)&quot;);
-
-        return false; // never happens
-    }
-
-    /**
-     * Call getAttribute on an element, producing a meaningful warning if not &quot;yes&quot; or &quot;no&quot;. If the
-     * 'element' or 'attribute' are null, the default value is returned.
-     * 
-     * @param element The element to get the attribute value of
-     * @param attribute The name of the attribute to get
-     * @param defaultValue Value returned if attribute not present or invalid
-     */
-    protected boolean validateYesNoAttribute(XMLElement element, String attribute,
-            boolean defaultValue)
-    {
-        if (element == null) return defaultValue;
-
-        String value = element.getAttribute(attribute, (defaultValue ? &quot;yes&quot; : &quot;no&quot;));
-        if (&quot;yes&quot;.equalsIgnoreCase(value)) return true;
-        if (&quot;no&quot;.equalsIgnoreCase(value)) return false;
-
-        // TODO: should this be an error if it's present but &quot;none of the
-        // above&quot;?
-        parseWarn(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; invalid attribute '&quot; + attribute
-                + &quot;': Expected (yes|no) if present&quot;);
-
-        return defaultValue;
-    }
-
-    /**
-     * The main method if the compiler is invoked by a command-line call.
-     * 
-     * @param args The arguments passed on the command-line.
-     */
-    public static void main(String[] args)
-    {
-        // Outputs some informations
-        System.out.println(&quot;&quot;);
-        System.out.println(&quot;.::  IzPack - Version &quot; + Compiler.IZPACK_VERSION + &quot; ::.&quot;);
-        System.out.println(&quot;&quot;);
-        System.out.println(&quot;&lt; compiler specifications version: &quot; + VERSION + &quot; &gt;&quot;);
-        System.out.println(&quot;&quot;);
-        System.out.println(&quot;- Copyright (c) 2001-2008 Julien Ponge&quot;);
-        System.out.println(&quot;- Visit <A HREF="https://izpack.github.io/">https://izpack.github.io/</A> for the latest releases&quot;);
-        System.out.println(&quot;- Released under the terms of the Apache Software License version 2.0.&quot;);
-        System.out.println(&quot;&quot;);
-
-        // exit code 1 means: error
-        int exitCode = 1;
-        String home = &quot;.&quot;;
-        // We get the IzPack home directory 
-        String izHome = System.getProperty(&quot;IZPACK_HOME&quot;);
-        if (izHome != null) home = izHome;
-                    
-        // We analyse the command line parameters
-        try
-        {
-            // Our arguments
-            String filename;
-            String base = &quot;.&quot;;
-            String kind = &quot;standard&quot;;
-            String output;
-            String compr_format = &quot;default&quot;;
-            int compr_level = -1;
-
-            // First check
-            int nArgs = args.length;
-            if (nArgs &lt; 1) throw new Exception(&quot;no arguments given&quot;);
-
-            // The users wants to know the command line parameters
-            if (&quot;-?&quot;.equalsIgnoreCase(args[0]))
-            {
-                System.out.println(&quot;-&gt; Command line parameters are : (xml file) [args]&quot;);
-                System.out.println(&quot;   (xml file): the xml file describing the installation&quot;);
-                System.out.println(&quot;   -h (IzPack home) : the root path of IzPack. This will be needed&quot;);
-                System.out.println(&quot;               if the compiler is not called in the root directory  of IzPack.&quot;);
-                System.out.println(&quot;               Do not forget quotations if there are blanks in the path.&quot;);
-                         System.out
-                          .println(&quot;   -b (base) : indicates the base path that the compiler will use for filenames&quot;);
-                System.out.println(&quot;               of sources. Default is the current path. Attend to -h.&quot;);
-                System.out.println(&quot;   -k (kind) : indicates the kind of installer to generate&quot;);
-                System.out.println(&quot;               default is standard&quot;);
-                System.out.println(&quot;   -o (out)  : indicates the output file name&quot;);
-                System.out.println(&quot;               default is the xml file name\n&quot;);
-                System.out
-                        .println(&quot;   -c (compression)  : indicates the compression format to be used for packs&quot;);
-                System.out.println(&quot;               default is the internal deflate compression\n&quot;);
-                System.out
-                        .println(&quot;   -l (compression-level)  : indicates the level for the used compression format&quot;);
-                System.out.println(&quot;                if supported. Only integer are valid\n&quot;);
-
-                System.out
-                        .println(&quot;   When using vm option -DSTACKTRACE=true there is all kind of debug info &quot;);
-                System.out.println(&quot;&quot;);
-                exitCode = 0;
-            }
-            else
-            {
-                // We can parse the other parameters &amp; try to compile the
-                // installation
-
-                // We get the input file name and we initialize the output file
-                // name
-                filename = args[0];
-                // default jar files names are based on input file name
-                output = filename.substring(0, filename.length() - 3) + &quot;jar&quot;;
-
-                // We parse the other ones
-                int pos = 1;
-                while (pos &lt; nArgs)
-                    if ((args[pos].startsWith(&quot;-&quot;)) &amp;&amp; (args[pos].length() == 2))
-                    {
-                        switch (args[pos].toLowerCase().charAt(1))
-                        {
-                        case 'b':
-                            if ((pos + 1) &lt; nArgs)
-                            {
-                                pos++;
-                                base = args[pos];
-                            }
-                            else
-                                throw new Exception(&quot;base argument missing&quot;);
-                            break;
-                        case 'k':
-                            if ((pos + 1) &lt; nArgs)
-                            {
-                                pos++;
-                                kind = args[pos];
-                            }
-                            else
-                                throw new Exception(&quot;kind argument missing&quot;);
-                            break;
-                        case 'o':
-                            if ((pos + 1) &lt; nArgs)
-                            {
-                                pos++;
-                                output = args[pos];
-                            }
-                            else
-                                throw new Exception(&quot;output argument missing&quot;);
-                            break;
-                        case 'c':
-                            if ((pos + 1) &lt; nArgs)
-                            {
-                                pos++;
-                                compr_format = args[pos];
-                            }
-                            else
-                                throw new Exception(&quot;compression format argument missing&quot;);
-                            break;
-                        case 'l':
-                            if ((pos + 1) &lt; nArgs)
-                            {
-                                pos++;
-                                compr_level = Integer.parseInt(args[pos]);
-                            }
-                            else
-                                throw new Exception(&quot;compression level argument missing&quot;);
-                            break;
-                        case 'h':
-                            if ((pos + 1) &lt; nArgs)
-                            {
-                                pos++;
-                                home = args[pos];
-                            }
-                            else
-                                throw new Exception(&quot;IzPack home path argument missing&quot;);
-                            break;
-                        default:
-                            throw new Exception(&quot;unknown argument&quot;);
-                        }
-                        pos++;
-                    }
-                    else
-                        throw new Exception(&quot;bad argument&quot;);
-
-                home = resolveIzPackHome(home);
-                // Outputs what we are going to do
-                System.out.println(&quot;-&gt; Processing  : &quot; + filename);
-                System.out.println(&quot;-&gt; Output      : &quot; + output);
-                System.out.println(&quot;-&gt; Base path   : &quot; + base);
-                System.out.println(&quot;-&gt; Kind        : &quot; + kind);
-                System.out.println(&quot;-&gt; Compression : &quot; + compr_format);
-                System.out.println(&quot;-&gt; Compr. level: &quot; + compr_level);
-                System.out.println(&quot;-&gt; IzPack home : &quot; + home);
-                System.out.println(&quot;&quot;);
-
-                
-                Compiler.setIzpackHome(home);
-
-
-                // Calls the compiler
-                CmdlinePackagerListener listener = new CmdlinePackagerListener();
-                CompilerConfig compiler = new CompilerConfig(filename, base, kind, output, 
-                        compr_format, compr_level, listener, null);
-                compiler.executeCompiler();
-
-                // Waits
-                while (compiler.isAlive())
-                    Thread.sleep(100);
-
-                if (compiler.wasSuccessful()) exitCode = 0;
-
-                System.out.println(&quot;Build time: &quot; + new Date());
-            }
-        }
-        catch (Exception err)
-        {
-            // Something bad has happened
-            System.err.println(&quot;-&gt; Fatal error :&quot;);
-            System.err.println(&quot;   &quot; + err.getMessage());
-            err.printStackTrace();
-            System.err.println(&quot;&quot;);
-            System.err.println(&quot;(tip : use -? to get the commmand line parameters)&quot;);
-        }
-
-        // Closes the JVM
-        System.exit(exitCode);
-    }
-
-    private static String resolveIzPackHome(String home)
-    {
-        File test = new File(home, IZ_TEST_SUBDIR + File.separator + IZ_TEST_FILE);
-        if(test.exists())
-            return( home);
-        // Try to resolve the path using compiler.jar which also should be under
-        // IZPACK_HOME.
-        String self = Compiler.class.getName();
-        self = self.replace('.', '/');
-        self = &quot;/&quot; + self + &quot;.class&quot;;
-        URL url = Compiler.class.getResource(self);
-        String np = url.getFile();
-        int start = np.indexOf(self);
-        np = np.substring(0, start);
-        if( np.endsWith(&quot;!&quot;))
-        {   // Where shut IZPACK_HOME at the standalone-compiler be??
-            // No idea.
-            if(np.endsWith(&quot;standalone-compiler.jar!&quot;))
-                return(&quot;.&quot;);
-            np = np.substring(0, np.length() - 1);
-        }
-        File root = null;
-        if( URI.create(np).isAbsolute())
-            root = new File(URI.create(np));
-        else 
-            root = new File(np);
-        while(true)
-        {
-            if( root == null )
-                throw new IllegalArgumentException(&quot;No valid IzPack home directory found&quot;);
-            test =  new File(root, IZ_TEST_SUBDIR + File.separator + IZ_TEST_FILE);
-            if( test.exists())
-                return(root.getAbsolutePath());
-            root = root.getParentFile();
-        }
-    }
-
-    // -------------------------------------------------------------------------
-    // ------------- Listener stuff ------------------------- START ------------
-
-    /**
-     * This method parses install.xml for defined listeners and put them in the right position. If
-     * posible, the listeners will be validated. Listener declaration is a fragmention in
-     * install.xml like : &lt;listeners&gt; &lt;listener compiler=&quot;PermissionCompilerListener&quot;
-     * installer=&quot;PermissionInstallerListener&quot;/&gt; &lt;/&lt;listeners&gt;
-     * 
-     * @param data the XML data
-     * @exception Exception Description of the Exception
-     */
-    private void addCustomListeners(XMLElement data) throws Exception
-    {
-        // We get the listeners
-        XMLElement root = data.getFirstChildNamed(&quot;listeners&quot;);
-        if (root == null) return;
-        Iterator iter = root.getChildrenNamed(&quot;listener&quot;).iterator();
-        while (iter.hasNext())
-        {
-            XMLElement xmlAction = (XMLElement) iter.next();
-            Object[] listener = getCompilerListenerInstance(xmlAction);
-            if (listener != null)
-                addCompilerListener((CompilerListener) listener[0]);
-            String[] typeNames = new String[] { &quot;installer&quot;, &quot;uninstaller&quot;};
-            int[] types = new int[] { CustomData.INSTALLER_LISTENER,
-                    CustomData.UNINSTALLER_LISTENER};
-            for (int i = 0; i &lt; typeNames.length; ++i)
-            {
-                String className = xmlAction.getAttribute(typeNames[i]);
-                if (className != null)
-                {
-                    // Check for a jar attribute on the listener
-                    String jarPath = xmlAction.getAttribute(&quot;jar&quot;);
-                    jarPath = compiler.replaceProperties(jarPath);
-                    if( jarPath == null )
-                        jarPath = &quot;bin/customActions/&quot; + className + &quot;.jar&quot;;
-                    List constraints = OsConstraint.getOsList(xmlAction);
-                    compiler.addCustomListener(types[i], className, jarPath, constraints);
-                }
-            }
-        }
-
-    }
-
-    /**
-     * Returns a list which contains the pathes of all files which are included in the given url.
-     * This method expects as the url param a jar.
-     * 
-     * @param url url of the jar file
-     * @return full qualified paths of the contained files
-     * @throws Exception
-     */
-    private List getContainedFilePaths(URL url) throws Exception
-    {
-        JarInputStream jis = new JarInputStream(url.openStream());
-        ZipEntry zentry = null;
-        ArrayList fullNames = new ArrayList();
-        while ((zentry = jis.getNextEntry()) != null)
-        {
-            String name = zentry.getName();
-            // Add only files, no directory entries.
-            if (!zentry.isDirectory()) fullNames.add(name);
-        }
-        jis.close();
-        return (fullNames);
-    }
-
-    /**
-     * Returns the qualified class name for the given class. This method expects as the url param a
-     * jar file which contains the given class. It scans the zip entries of the jar file.
-     * 
-     * @param url url of the jar file which contains the class
-     * @param className short name of the class for which the full name should be resolved
-     * @return full qualified class name
-     * @throws IOException 
-     */
-    private String getFullClassName(URL url, String className) throws IOException //throws Exception
-    {
-        JarInputStream jis = new JarInputStream(url.openStream());
-        ZipEntry zentry = null;
-        while ((zentry = jis.getNextEntry()) != null)
-        {
-            String name = zentry.getName();
-            int lastPos = name.lastIndexOf(&quot;.class&quot;);
-            if (lastPos &lt; 0)
-            {
-                continue; // No class file.
-            }
-            name = name.replace('/', '.');
-            int pos = -1;
-            int nonCasePos = -1;
-            if (className != null)
-            {
-                pos = name.indexOf(className);
-                nonCasePos = name.toLowerCase().indexOf(className.toLowerCase());
-            }
-            if (pos != -1 &amp;&amp; name.length() == pos + className.length() + 6) // &quot;Main&quot; class found
-            {
-                jis.close();
-                return (name.substring(0, lastPos));
-            }
-            
-            if (nonCasePos != -1 &amp;&amp; name.length() == nonCasePos + className.length() + 6)
-                // &quot;Main&quot; class with different case found
-                throw new IllegalArgumentException(&quot;Fatal error! The declared panel name in the xml file (&quot;
-                        + className + &quot;) differs in case to the founded class file (&quot; + name + &quot;).&quot;);
-        }
-        jis.close();
-        return (null);
-    }
-
-    /**
-     * Returns the compiler listener which is defined in the xml element. As
-     * xml element a &quot;listner&quot; node will be expected. Additional it is expected,
-     * that either &quot;findIzPackResource&quot; returns an url based on
-     * &quot;bin/customActions/[className].jar&quot;, or that the listener element has
-     * a jar attribute specifying the listener jar path. The class will be
-     * loaded via an URLClassLoader.
-     * 
-     * @param var the xml element of the &quot;listener&quot; node
-     * @return instance of the defined compiler listener
-     * @throws Exception
-     */
-    private Object[] getCompilerListenerInstance(XMLElement var) throws Exception
-    {
-        String className = var.getAttribute(&quot;compiler&quot;);
-        Class listener = null;
-        Object instance = null;
-        if (className == null) return (null);
-
-        // CustomAction files come in jars packaged IzPack, or they can be
-        // specified via a jar attribute on the listener
-        String jarPath = var.getAttribute(&quot;jar&quot;);
-        jarPath = compiler.replaceProperties(jarPath);
-        if( jarPath == null )
-            jarPath = &quot;bin/customActions/&quot; + className + &quot;.jar&quot;;
-        URL url = findIzPackResource(jarPath, &quot;CustomAction jar file&quot;, var);
-        String fullName = getFullClassName(url, className);
-        if (fullName == null){
-            // class not found
-            return null;
-        }
-        if (url != null)
-        {
-            if (getClass().getResource(&quot;/&quot; + jarPath) != null)
-            { // Oops, standalone, URLClassLoader will not work ...
-                // Write the jar to a temp file.
-                InputStream in = null;
-                FileOutputStream outFile = null;
-                byte[] buffer = new byte[5120];
-                File tf = null;
-                try
-                {
-                    tf = File.createTempFile(&quot;izpj&quot;, &quot;.jar&quot;);
-                    tf.deleteOnExit();
-                    outFile = new FileOutputStream(tf);
-                    in = getClass().getResourceAsStream(&quot;/&quot; + jarPath);
-                    long bytesCopied = 0;
-                    int bytesInBuffer;
-                    while ((bytesInBuffer = in.read(buffer)) != -1)
-                    {
-                        outFile.write(buffer, 0, bytesInBuffer);
-                        bytesCopied += bytesInBuffer;
-                    }
-                }
-                finally
-                {
-                    if (in != null) in.close();
-                    if (outFile != null) outFile.close();
-                }
-                url = tf.toURL();
-
-            }
-            // Use the class loader of the interface as parent, else
-            // compile will fail at using it via an Ant task.
-            URLClassLoader ucl = new URLClassLoader(new URL[] { url}, CompilerListener.class
-                    .getClassLoader());
-            listener = ucl.loadClass(fullName);
-        }
-        if (listener != null)
-            instance = listener.newInstance();
-        else
-            parseError(var, &quot;Cannot find defined compiler listener &quot; + className);
-        if (!CompilerListener.class.isInstance(instance))
-            parseError(var, &quot;'&quot; + className + &quot;' must be implemented &quot;
-                    + CompilerListener.class.toString());
-        List constraints = OsConstraint.getOsList(var);
-        return (new Object[] { instance, className, constraints});
-    }
-
-    /**
-     * Add a CompilerListener. A registered CompilerListener will be called at every enhancmend
-     * point of compiling.
-     * 
-     * @param pe CompilerListener which should be added
-     */
-    private void addCompilerListener(CompilerListener pe)
-    {
-        compilerListeners.add(pe);
-    }
-
-    /**
-     * Calls all defined compile listeners notify method with the given data
-     * 
-     * @param callerName name of the calling method as string
-     * @param state CompileListener.BEGIN or END
-     * @param data current install data
-     * @throws CompilerException
-     */
-    private void notifyCompilerListener(String callerName, int state, XMLElement data)
-            throws CompilerException
-    {
-        Iterator i = compilerListeners.iterator();
-        IPackager packager = compiler.getPackager();
-        while (i != null &amp;&amp; i.hasNext())
-        {
-            CompilerListener listener = (CompilerListener) i.next();
-            listener.notify(callerName, state, data, packager);
-        }
-
-    }
-
-    /**
-     * Calls the reviseAdditionalDataMap method of all registered CompilerListener's.
-     * 
-     * @param f file releated XML node
-     * @return a map with the additional attributes
-     */
-    private Map getAdditionals(XMLElement f) throws CompilerException
-    {
-        Iterator i = compilerListeners.iterator();
-        Map retval = null;
-        try
-        {
-            while (i != null &amp;&amp; i.hasNext())
-            {
-                retval = ((CompilerListener) i.next()).reviseAdditionalDataMap(retval, f);
-            }
-        }
-        catch (CompilerException ce)
-        {
-            parseError(f, ce.getMessage());
-        }
-        return (retval);
-    }
-}

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/CompilerConfig.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/compiler/CompilerConfig.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/IPackager.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/compiler/IPackager.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/IPackager.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,208 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *     
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.izforge.izpack.compiler;
-
-import java.io.File;
-import java.net.URL;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-
-import net.n3.nanoxml.XMLElement;
-
-import com.izforge.izpack.CustomData;
-import com.izforge.izpack.GUIPrefs;
-import com.izforge.izpack.Info;
-import com.izforge.izpack.Panel;
-import com.izforge.izpack.compressor.PackCompressor;
-
-/**
- * Interface for all packager implementations
- * 
- * @author Dennis Reil, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">Dennis.Reil at reddot.de</A>&gt;
- */
-public interface IPackager
-{
-
-    /**
-     * Create the installer, beginning with the specified jar. If the name specified does not end in
-     * &quot;.jar&quot;, it is appended. If secondary jars are created for packs (if the Info object added has
-     * a webDirURL set), they are created in the same directory, named sequentially by inserting
-     * &quot;.pack#&quot; (where '#' is the pack number) &quot;.jar&quot; suffix: e.g. &quot;foo.pack1.jar&quot;. If any file
-     * exists, it is overwritten.
-     */
-    public abstract void createInstaller(File primaryFile) throws Exception;
-
-    /**
-     * Get the PackagerListener.
-     * @return the current PackagerListener
-     */
-    public abstract PackagerListener getPackagerListener();
-
-    /**
-     * Adds a listener.
-     * 
-     * @param listener The listener.
-     */
-    public abstract void setPackagerListener(PackagerListener listener);
-
-    /**
-     * Sets the informations related to this installation.
-     * 
-     * @param info The info section.
-     * @exception Exception Description of the Exception
-     */
-    public abstract void setInfo(Info info) throws Exception;
-
-    /**
-     * Sets the GUI preferences.
-     * 
-     * @param prefs The new gUIPrefs value
-     */
-    public abstract void setGUIPrefs(GUIPrefs prefs);
-
-    /**
-     * Allows access to add, remove and update the variables for the project, which are maintained
-     * in the packager.
-     * 
-     * @return map of variable names to values
-     */
-    public abstract Properties getVariables();
-
-    /**
-     * Add a panel, where order is important. Only one copy of the class files neeed are inserted in
-     * the installer.
-     */
-    public abstract void addPanelJar(Panel panel, URL jarURL);
-
-    /**
-     * Add a custom data like custom actions, where order is important. Only one copy of the class
-     * files neeed are inserted in the installer.
-     * 
-     * @param ca custom action object
-     * @param url the URL to include once
-     */
-    public abstract void addCustomJar(CustomData ca, URL url);
-
-    /**
-     * Adds a pack, order is mostly irrelevant.
-     * 
-     * @param pack contains all the files and items that go with a pack
-     */
-    public abstract void addPack(PackInfo pack);
-
-    /**
-     * Gets the packages list
-     */
-    public abstract List getPacksList();
-
-    /**
-     * Adds a language pack.
-     * 
-     * @param iso3 The ISO3 code.
-     * @param xmlURL The location of the xml local info
-     * @param flagURL The location of the flag image resource
-     */
-    public abstract void addLangPack(String iso3, URL xmlURL, URL flagURL);
-
-    /**
-     * Adds a resource.
-     * 
-     * @param resId The resource Id.
-     * @param url The location of the data
-     */
-    public abstract void addResource(String resId, URL url);
-
-    /**
-     * Adds a native library.
-     * 
-     * @param name The native library name.
-     * @param url The url to get the data from.
-     * @exception Exception Description of the Exception
-     */
-    public abstract void addNativeLibrary(String name, URL url) throws Exception;
-
-    /**
-     * Adds a jar file content to the installer. Package structure is maintained. Need mechanism to
-     * copy over signed entry information.
-     * 
-     * @param jarURL The url of the jar to add to the installer. We use a URL so the jar may be
-     * nested within another.
-     */
-    public abstract void addJarContent(URL jarURL);
-
-    /**
-     * Adds a jar file content to the installer. Package structure is maintained. Need mechanism to
-     * copy over signed entry information. If the given file list is null the hole contents of the
-     * jar file will be copied else only the listed.
-     * 
-     * @param jarURL The url of the jar to add to the installer. We use a URL so the jar may be
-     * nested within another.
-     * @param files to be copied
-     */
-    public abstract void addJarContent(URL jarURL, List files);
-
-    /**
-     * Marks a native library to be added to the uninstaller.
-     * 
-     * @param data the describing custom action data object
-     */
-    public abstract void addNativeUninstallerLibrary(CustomData data);
-
-    /**
-     * Returns the current pack compressor
-     * @return Returns the current pack compressor.
-     */
-    public abstract PackCompressor getCompressor();     
-    
-    /**
-     * Initializes a pack compressor if supported by the packager
-     * @param compr_format
-     * @param compr_level
-     */
-    public abstract void initPackCompressor(String compr_format, int compr_level) throws CompilerException;
-    
-    /**
-     * Adds configuration information to the packager.
-     * @param data - the xml-element packaging from the install.xml
-     */
-    public abstract void addConfigurationInformation(XMLElement data);
-    
-    /**
-     * @return the rules
-     */
-    public abstract Map getRules();    
-    
-    /**
-     * @param rules the rules to set
-     */
-    public abstract void setRules(Map rules);
-    
-    /**
-     * Returns a map of dynamically refreshed variables
-     * @return
-     */
-    public abstract Map getDynamicVariables();
-    
-    /**
-     * 
-     * @param dynamicvariables
-     */
-    public abstract void setDynamicVariables(Map dynamicvariables);
-}
\ No newline at end of file

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/IPackager.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/compiler/IPackager.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/MultiVolumePackager.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/compiler/MultiVolumePackager.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/MultiVolumePackager.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,650 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A> <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Copyright 2007 Dennis Reil
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- * 
- * <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-package com.izforge.izpack.compiler;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectOutputStream;
-import java.io.OutputStream;
-import java.io.StringReader;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.zip.Deflater;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipException;
-import java.util.zip.ZipInputStream;
-import java.util.zip.ZipOutputStream;
-
-import net.n3.nanoxml.XMLElement;
-
-import com.izforge.izpack.Pack;
-import com.izforge.izpack.PackFile;
-import com.izforge.izpack.XPackFile;
-import com.izforge.izpack.io.FileSpanningOutputStream;
-import com.izforge.izpack.util.Debug;
-import com.izforge.izpack.util.FileUtil;
-
-/**
- * The packager class. The packager is used by the compiler to put files into an installer, and
- * create the actual installer files.
- * 
- * This is a packager, which packs everything into multi volumes.
- * 
- * @author Dennis Reil, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">Dennis.Reil at reddot.de</A>&gt;
- */
-public class MultiVolumePackager extends PackagerBase
-{
-
-    public static final String INSTALLER_PAK_NAME = &quot;installer&quot;;
-
-    /** Executable zipped output stream. First to open, last to close. */
-    private ZipOutputStream primaryJarStream;
-
-
-    private XMLElement configdata = null;
-
-    /**
-     * The constructor.
-     * 
-     * @throws CompilerException
-     */
-    public MultiVolumePackager() throws CompilerException
-    {
-        this(&quot;default&quot;);
-    }
-
-    /**
-     * Extended constructor.
-     * 
-     * @param compr_format Compression format to be used for packs compression format (if supported)
-     * @throws CompilerException
-     */
-    public MultiVolumePackager(String compr_format) throws CompilerException
-    {
-        this(compr_format, -1);
-    }
-
-    /**
-     * Extended constructor.
-     * 
-     * @param compr_format Compression format to be used for packs
-     * @param compr_level Compression level to be used with the chosen compression format (if
-     * supported)
-     * @throws CompilerException
-     */
-    public MultiVolumePackager(String compr_format, int compr_level) throws CompilerException
-    {
-        initPackCompressor(compr_format, compr_level);
-    }
-
-    /**
-     * Create the installer, beginning with the specified jar. If the name specified does not end in
-     * &quot;.jar&quot;, it is appended. If secondary jars are created for packs (if the Info object added has
-     * a webDirURL set), they are created in the same directory, named sequentially by inserting
-     * &quot;.pack#&quot; (where '#' is the pack number) &quot;.jar&quot; suffix: e.g. &quot;foo.pack1.jar&quot;. If any file
-     * exists, it is overwritten.
-     */
-    public void createInstaller(File primaryFile) throws Exception
-    {
-        // first analyze the configuration
-        this.analyzeConfigurationInformation();
-        
-        // preliminary work
-        String baseName = primaryFile.getName();
-        if (baseName.endsWith(&quot;.jar&quot;))
-        {
-            baseName = baseName.substring(0, baseName.length() - 4);
-            baseFile = new File(primaryFile.getParentFile(), baseName);
-        }
-        else
-            baseFile = primaryFile;
-
-        info.setInstallerBase(baseFile.getName());
-        packJarsSeparate = (info.getWebDirURL() != null);
-
-        // primary (possibly only) jar. -1 indicates primary
-        primaryJarStream = getJarOutputStream(baseFile.getName() + &quot;.jar&quot;);
-
-        sendStart();
-
-        writeInstaller();
-
-        // Pack File Data may be written to separate jars
-        String packfile = baseFile.getParent() + File.separator + INSTALLER_PAK_NAME;
-        writePacks(new File(packfile));
-
-        // Finish up. closeAlways is a hack for pack compressions other than
-        // default. Some of it (e.g. BZip2) closes the slave of it also.
-        // But this should not be because the jar stream should be open
-        // for the next pack. Therefore an own JarOutputStream will be used
-        // which close method will be blocked.
-        // primaryJarStream.closeAlways();
-        primaryJarStream.close();
-
-        sendStop();
-    }
-
-    /***********************************************************************************************
-     * Listener assistance
-     **********************************************************************************************/
-
-    private void analyzeConfigurationInformation()
-    {
-        String classname = this.getClass().getName();
-        String sizeprop = classname + &quot;.volumesize&quot;;
-        String freespaceprop = classname + &quot;.firstvolumefreespace&quot;; 
-        
-        if (this.configdata == null){
-            // no configdata given, set default values
-            this.variables.setProperty(sizeprop, Long.toString(FileSpanningOutputStream.DEFAULT_VOLUME_SIZE));
-            this.variables.setProperty(freespaceprop, Long.toString(FileSpanningOutputStream.DEFAULT_ADDITIONAL_FIRST_VOLUME_FREE_SPACE_SIZE));            
-        }
-        else {            
-            // configdata was set
-            String volumesize = configdata.getAttribute(&quot;volumesize&quot;, Long.toString(FileSpanningOutputStream.DEFAULT_VOLUME_SIZE));
-            String freespace = configdata.getAttribute(&quot;firstvolumefreespace&quot;, Long.toString(FileSpanningOutputStream.DEFAULT_ADDITIONAL_FIRST_VOLUME_FREE_SPACE_SIZE));
-            this.variables.setProperty(sizeprop, volumesize);
-            this.variables.setProperty(freespaceprop, freespace);
-        }         
-    }
-
-    /***********************************************************************************************
-     * Private methods used when writing out the installer to jar files.
-     **********************************************************************************************/
-
-    /**
-     * Write skeleton installer to primary jar. It is just an included jar, except that we copy the
-     * META-INF as well.
-     */
-    protected void writeSkeletonInstaller() throws IOException
-    {
-        sendMsg(&quot;Copying the skeleton installer&quot;, PackagerListener.MSG_VERBOSE);
-        
-        
-        InputStream is = MultiVolumePackager.class.getResourceAsStream(&quot;/&quot; + SKELETON_SUBPATH);
-        if (is == null)
-        {
-            File skeleton = new File(Compiler.IZPACK_HOME, SKELETON_SUBPATH);
-            is = new FileInputStream(skeleton);
-        }
-        ZipInputStream inJarStream = new ZipInputStream(is);
-        
-        // copy anything except the manifest.mf
-        List excludes = new ArrayList();
-        excludes.add(&quot;META-INF.MANIFEST.MF&quot;);
-        copyZipWithoutExcludes(inJarStream, primaryJarStream,excludes);
-
-        // ugly code to modify the manifest-file to set MultiVolumeInstaller as main class
-        // reopen Stream
-        is = MultiVolumePackager.class.getResourceAsStream(&quot;/&quot; + SKELETON_SUBPATH);
-        if (is == null)
-        {
-            File skeleton = new File(Compiler.IZPACK_HOME, SKELETON_SUBPATH);
-            is = new FileInputStream(skeleton);
-        }
-        inJarStream = new ZipInputStream(is);                
-        boolean found = false;
-        ZipEntry ze = null;
-        String modifiedmanifest = null;
-        while (((ze = inJarStream.getNextEntry()) != null) &amp;&amp; !found){            
-            if (&quot;META-INF/MANIFEST.MF&quot;.equals(ze.getName())){
-                long size = ze.getSize();
-                byte[] buffer = new byte[4096];
-                int readbytes = 0;
-                int totalreadbytes = 0;
-                StringBuffer manifest = new StringBuffer();
-                while (((readbytes = inJarStream.read(buffer)) &gt; 0) &amp;&amp; (totalreadbytes &lt; size)){
-                    totalreadbytes += readbytes;
-                    String tmp = new String(buffer,0,readbytes,&quot;utf-8&quot;);
-                    manifest.append(tmp);
-                }
-                
-                
-                StringReader stringreader = new StringReader(manifest.toString());
-                BufferedReader reader = new BufferedReader(stringreader);
-                String line = null;
-                StringBuffer modified = new StringBuffer();
-                while ((line = reader.readLine()) != null){
-                    if (line.startsWith(&quot;Main-Class:&quot;)){
-                        line = &quot;Main-Class: com.izforge.izpack.installer.MultiVolumeInstaller&quot;;
-                    }
-                    modified.append(line);
-                    modified.append(&quot;\r\n&quot;);
-                }                
-                reader.close();
-                modifiedmanifest = modified.toString();
-                /*
-                System.out.println(&quot;Manifest:&quot;);
-                System.out.println(manifest.toString());
-                System.out.println(&quot;Modified Manifest:&quot;);
-                System.out.println(modified.toString());
-                */
-                break;
-            }
-        }
-        
-        primaryJarStream.putNextEntry(new ZipEntry(&quot;META-INF/MANIFEST.MF&quot;));        
-        primaryJarStream.write(modifiedmanifest.getBytes());
-        primaryJarStream.closeEntry();
-    }
-
-    /**
-     * Write an arbitrary object to primary jar.
-     */
-    protected void writeInstallerObject(String entryName, Object object) throws IOException
-    {
-        primaryJarStream.putNextEntry(new ZipEntry(entryName));
-        ObjectOutputStream out = new ObjectOutputStream(primaryJarStream);
-        out.writeObject(object);
-        out.flush();
-        primaryJarStream.closeEntry();
-    }
-
-    /** Write the data referenced by URL to primary jar. */
-    protected void writeInstallerResources() throws IOException
-    {
-        sendMsg(&quot;Copying &quot; + installerResourceURLMap.size() + &quot; files into installer&quot;);
-
-        Iterator i = installerResourceURLMap.keySet().iterator();
-        while (i.hasNext())
-        {
-            String name = (String) i.next();
-            InputStream in = ((URL) installerResourceURLMap.get(name)).openStream();
-
-            org.apache.tools.zip.ZipEntry newEntry = new org.apache.tools.zip.ZipEntry(name);
-            long dateTime = FileUtil.getFileDateTime((URL) installerResourceURLMap.get(name));
-            if (dateTime != -1)
-                newEntry.setTime(dateTime);
-            primaryJarStream.putNextEntry(newEntry);
-
-            copyStream(in, primaryJarStream);
-            primaryJarStream.closeEntry();
-            in.close();
-        }
-    }
-
-    /** Copy included jars to primary jar. */
-    protected void writeIncludedJars() throws IOException
-    {
-        sendMsg(&quot;Merging &quot; + includedJarURLs.size() + &quot; jars into installer&quot;);
-
-        Iterator i = includedJarURLs.iterator();
-        while (i.hasNext())
-        {
-            Object[] current = (Object[]) i.next();
-            InputStream is = ((URL) current[0]).openStream();
-            ZipInputStream inJarStream = new ZipInputStream(is);
-            copyZip(inJarStream, primaryJarStream, (List) current[1]);
-        }
-    }
-
-    /**
-     * Write Packs to primary jar or each to a separate jar.
-     */
-    private void writePacks(File primaryfile) throws Exception
-    {
-
-        final int num = packsList.size();
-        sendMsg(&quot;Writing &quot; + num + &quot; Pack&quot; + (num &gt; 1 ? &quot;s&quot; : &quot;&quot;) + &quot; into installer&quot;);
-        Debug.trace(&quot;Writing &quot; + num + &quot; Pack&quot; + (num &gt; 1 ? &quot;s&quot; : &quot;&quot;) + &quot; into installer&quot;);
-        // Map to remember pack number and bytes offsets of back references
-        Map storedFiles = new HashMap();
-
-        // First write the serialized files and file metadata data for each pack
-        // while counting bytes.
-
-        String classname = this.getClass().getName();
-        String volumesize = this.getVariables().getProperty(classname + &quot;.volumesize&quot;);
-        String extraspace = this.getVariables().getProperty(classname + &quot;.firstvolumefreespace&quot;);
-
-        long volumesizel = FileSpanningOutputStream.DEFAULT_VOLUME_SIZE;
-        long extraspacel = FileSpanningOutputStream.DEFAULT_ADDITIONAL_FIRST_VOLUME_FREE_SPACE_SIZE;
-
-        if (volumesize != null)
-        {
-            volumesizel = Long.parseLong(volumesize);
-        }
-        if (extraspace != null)
-        {
-            extraspacel = Long.parseLong(extraspace);
-        }
-        Debug.trace(&quot;Volumesize: &quot; + volumesizel);
-        Debug.trace(&quot;Extra space on first volume: &quot; + extraspacel);
-        FileSpanningOutputStream fout = new FileSpanningOutputStream(primaryfile.getParent()
-                + File.separator + primaryfile.getName() + &quot;.pak&quot;, volumesizel);
-        fout.setFirstvolumefreespacesize(extraspacel);
-
-        int packNumber = 0;
-        Iterator packIter = packsList.iterator();
-        while (packIter.hasNext())
-        {
-            PackInfo packInfo = (PackInfo) packIter.next();
-            Pack pack = packInfo.getPack();
-            pack.nbytes = 0;
-
-            sendMsg(&quot;Writing Pack &quot; + packNumber + &quot;: &quot; + pack.name, PackagerListener.MSG_VERBOSE);
-            Debug.trace(&quot;Writing Pack &quot; + packNumber + &quot;: &quot; + pack.name);
-            ZipEntry entry = new ZipEntry(&quot;packs/pack&quot; + packNumber);
-            // write the metadata as uncompressed object stream to primaryJarStream
-            // first write a packs entry
-
-            primaryJarStream.putNextEntry(entry);
-            ObjectOutputStream objOut = new ObjectOutputStream(primaryJarStream);
-
-            // We write the actual pack files
-            objOut.writeInt(packInfo.getPackFiles().size());
-
-            Iterator iter = packInfo.getPackFiles().iterator();
-            while (iter.hasNext())
-            {
-                boolean addFile = !pack.loose;
-                XPackFile pf = new XPackFile((PackFile) iter.next());
-                File file = packInfo.getFile(pf.getPackfile());
-                Debug.trace(&quot;Next file: &quot; + file.getAbsolutePath());
-                // use a back reference if file was in previous pack, and in
-                // same jar
-                Object[] info = (Object[]) storedFiles.get(file);
-                if (info != null &amp;&amp; !packJarsSeparate)
-                {
-                    Debug.trace(&quot;File already included in other pack&quot;);
-                    pf.setPreviousPackFileRef((String) info[0], (Long)info[1]);
-                    addFile = false;
-                }
-
-                if (addFile &amp;&amp; !pf.isDirectory())
-                {
-                    long pos = fout.getFilepointer();
-
-                    pf.setArchivefileposition(pos);
-
-                    // write out the filepointer
-                    int volumecountbeforewrite = fout.getVolumeCount();
-
-                    FileInputStream inStream = new FileInputStream(file);
-                    long bytesWritten = copyStream(inStream, fout);
-                    fout.flush();
-
-                    long posafterwrite = fout.getFilepointer();
-                    Debug.trace(&quot;File (&quot; + pf.sourcePath + &quot;) &quot; + pos + &quot; &lt;-&gt; &quot; + posafterwrite);
-
-                    if (fout.getFilepointer() != (pos + bytesWritten))
-                    {
-                        Debug.trace(&quot;file: &quot; + file.getName());
-                        Debug.trace(&quot;(Filepos/BytesWritten/ExpectedNewFilePos/NewFilePointer) (&quot;
-                                        + pos + &quot;/&quot; + bytesWritten + &quot;/&quot; + (pos + bytesWritten)
-                                        + &quot;/&quot; + fout.getFilepointer() + &quot;)&quot;);
-                        Debug.trace(&quot;Volumecount (before/after) (&quot;
-                                + volumecountbeforewrite + &quot;/&quot; + fout.getVolumeCount() + &quot;)&quot;);
-                        throw new IOException(&quot;Error new filepointer is illegal&quot;);
-                    }
-
-                    if (bytesWritten != pf.length()) { throw new IOException(
-                            &quot;File size mismatch when reading &quot; + file); }
-                    inStream.close();
-                    // keine backreferences m&#246;glich
-                    // storedFiles.put(file, new long[] { packNumber, pos});
-                }
-
-                objOut.writeObject(pf); // base info
-                objOut.flush(); // make sure it is written
-                // even if not written, it counts towards pack size
-                pack.nbytes += pf.length();
-            }
-            // Write out information about parsable files
-            objOut.writeInt(packInfo.getParsables().size());
-            iter = packInfo.getParsables().iterator();
-            while (iter.hasNext())
-                objOut.writeObject(iter.next());
-
-            // Write out information about executable files
-            objOut.writeInt(packInfo.getExecutables().size());
-            iter = packInfo.getExecutables().iterator();
-            while (iter.hasNext())
-                objOut.writeObject(iter.next());
-
-            // Write out information about updatecheck files
-            objOut.writeInt(packInfo.getUpdateChecks().size());
-            iter = packInfo.getUpdateChecks().iterator();
-            while (iter.hasNext())
-                objOut.writeObject(iter.next());
-
-            // Cleanup
-            objOut.flush();
-            packNumber++;
-        }
-
-        // write metadata for reading in volumes
-        int volumes = fout.getVolumeCount();
-        Debug.trace(&quot;Written &quot; + volumes + &quot; volumes&quot;);
-        String volumename = primaryfile.getName() + &quot;.pak&quot;;
-
-        fout.flush();
-        fout.close();
-
-        primaryJarStream.putNextEntry(new ZipEntry(&quot;volumes.info&quot;));
-        ObjectOutputStream out = new ObjectOutputStream(primaryJarStream);
-        out.writeInt(volumes);
-        out.writeUTF(volumename);
-        out.flush();
-        primaryJarStream.closeEntry();
-
-        // Now that we know sizes, write pack metadata to primary jar.
-        primaryJarStream.putNextEntry(new ZipEntry(&quot;packs.info&quot;));
-        out = new ObjectOutputStream(primaryJarStream);
-        out.writeInt(packsList.size());
-
-        Iterator i = packsList.iterator();
-        while (i.hasNext())
-        {
-            PackInfo pack = (PackInfo) i.next();
-            out.writeObject(pack.getPack());
-        }
-        out.flush();
-        primaryJarStream.closeEntry();
-    }
-
-    /***********************************************************************************************
-     * Stream utilites for creation of the installer.
-     **********************************************************************************************/
-
-    /** Return a stream for the next jar. */
-    private ZipOutputStream getJarOutputStream(String name) throws IOException
-    {
-        File file = new File(baseFile.getParentFile(), name);
-        sendMsg(&quot;Building installer jar: &quot; + file.getAbsolutePath());
-        Debug.trace(&quot;Building installer jar: &quot; + file.getAbsolutePath());
-        ZipOutputStream jar = new ZipOutputStream(new FileOutputStream(file));
-        jar.setLevel(Deflater.BEST_COMPRESSION);
-        // jar.setPreventClose(true); // Needed at using FilterOutputStreams which
-        // calls close
-        // of the slave at finalizing.
-
-        return jar;
-    }
-    
-    /**
-     * Copies specified contents of one jar to another.
-     * 
-     * &lt;p&gt;
-     * TODO: it would be useful to be able to keep signature information from signed jar files, can
-     * we combine manifests and still have their content signed?
-     * 
-     * @see #copyStream(InputStream, OutputStream)
-     */
-    private void copyZip(ZipInputStream zin, ZipOutputStream out, List files) throws IOException
-    {
-        java.util.zip.ZipEntry zentry;
-        if (!alreadyWrittenFiles.containsKey(out)) alreadyWrittenFiles.put(out, new HashSet());
-        HashSet currentSet = (HashSet) alreadyWrittenFiles.get(out);
-        while ((zentry = zin.getNextEntry()) != null)
-        {
-            String currentName = zentry.getName();
-            String testName = currentName.replace('/', '.');
-            testName = testName.replace('\\', '.');
-            if (files != null)
-            {
-                Iterator i = files.iterator();
-                boolean founded = false;
-                while (i.hasNext())
-                { // Make &quot;includes&quot; self to support regex.
-                    String doInclude = (String) i.next();
-                    if (testName.matches(doInclude))
-                    {
-                        founded = true;
-                        break;
-                    }
-                }
-                if (!founded) continue;
-            }
-            if (currentSet.contains(currentName)) continue;
-            try
-            {
-                // Create new entry for zip file.
-                ZipEntry newEntry = new ZipEntry(currentName);
-                // Get input file date and time.
-                long fileTime = zentry.getTime();
-                // Make sure there is date and time set.
-                if (fileTime != -1)
-                    newEntry.setTime(fileTime); // If found set it into output file.
-                out.putNextEntry(newEntry);
-
-                copyStream(zin, out);
-                out.closeEntry();
-                zin.closeEntry();
-                currentSet.add(currentName);
-            }
-            catch (ZipException x)
-            {
-                // This avoids any problem that can occur with duplicate
-                // directories. for instance all META-INF data in jars
-                // unfortunately this do not work with the apache ZipOutputStream...
-            }
-        }
-    }
-    
-    /**
-     * Copies specified contents of one jar to another without the specified files
-     * 
-     * &lt;p&gt;
-     * TODO: it would be useful to be able to keep signature information from signed jar files, can
-     * we combine manifests and still have their content signed?
-     * 
-     * @see #copyStream(InputStream, OutputStream)
-     */
-    private void copyZipWithoutExcludes(ZipInputStream zin, ZipOutputStream out, List excludes) throws IOException
-    {
-        java.util.zip.ZipEntry zentry;
-        if (!alreadyWrittenFiles.containsKey(out)) alreadyWrittenFiles.put(out, new HashSet());
-        HashSet currentSet = (HashSet) alreadyWrittenFiles.get(out);
-        while ((zentry = zin.getNextEntry()) != null)
-        {
-            String currentName = zentry.getName();
-            String testName = currentName.replace('/', '.');
-            testName = testName.replace('\\', '.');
-            if (excludes != null)
-            {
-                Iterator i = excludes.iterator();
-                boolean skip = false;
-                while (i.hasNext())
-                { 
-                    // Make &quot;excludes&quot; self to support regex.
-                    String doExclude = (String) i.next();                    
-                    if (testName.matches(doExclude))
-                    {                        
-                        skip = true;
-                        break;
-                    }
-                }           
-                if (skip){
-                    continue;
-                }
-            }
-            if (currentSet.contains(currentName)) continue;
-            try
-            {
-                // Create new entry for zip file.
-                ZipEntry newEntry = new ZipEntry(currentName);
-                // Get input file date and time.
-                long fileTime = zentry.getTime();
-                // Make sure there is date and time set.
-                if (fileTime != -1)
-                    newEntry.setTime(fileTime); // If found set it into output file.
-                out.putNextEntry(newEntry);
-
-                copyStream(zin, out);
-                out.closeEntry();
-                zin.closeEntry();
-                currentSet.add(currentName);
-            }
-            catch (ZipException x)
-            {
-                // This avoids any problem that can occur with duplicate
-                // directories. for instance all META-INF data in jars
-                // unfortunately this do not work with the apache ZipOutputStream...
-            }
-        }
-    }
-
-    /**
-     * Copies all the data from the specified input stream to the specified output stream.
-     * 
-     * @param in the input stream to read
-     * @param out the output stream to write
-     * @return the total number of bytes copied
-     * @exception IOException if an I/O error occurs
-     */
-    private long copyStream(InputStream in, OutputStream out) throws IOException
-    {
-        byte[] buffer = new byte[5120];
-        long bytesCopied = 0;
-        int bytesInBuffer;
-        while ((bytesInBuffer = in.read(buffer)) != -1)
-        {
-            out.write(buffer, 0, bytesInBuffer);
-            bytesCopied += bytesInBuffer;
-        }
-        return bytesCopied;
-    }
-
-    /* (non-Javadoc)
-     * @see com.izforge.izpack.compiler.IPackager#addConfigurationInformation(net.n3.nanoxml.XMLElement)
-     */
-    public void addConfigurationInformation(XMLElement data)
-    {
-       this.configdata = data;        
-    }
-
-    /* (non-Javadoc)
-     * @see com.izforge.izpack.compiler.PackagerBase#writePacks()
-     */
-    protected void writePacks() throws Exception
-    {
-        // TODO Auto-generated method stub
-        
-    }
-
-}
\ No newline at end of file

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/MultiVolumePackager.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/compiler/MultiVolumePackager.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/Packager.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/compiler/Packager.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/Packager.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,474 +0,0 @@
-/*
- * $Id$
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *     
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.izforge.izpack.compiler;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectOutputStream;
-import java.io.OutputStream;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.zip.Deflater;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipException;
-import java.util.zip.ZipInputStream;
-
-import net.n3.nanoxml.XMLElement;
-import net.n3.nanoxml.XMLWriter;
-
-import com.izforge.izpack.Pack;
-import com.izforge.izpack.PackFile;
-import com.izforge.izpack.util.FileUtil;
-
-/**
- * The packager class. The packager is used by the compiler to put files into an installer, and
- * create the actual installer files.
- * 
- * @author Julien Ponge
- * @author Chadwick McHenry
- */
-public class Packager extends PackagerBase
-{
-
-    /** Executable zipped output stream. First to open, last to close. 
-     *  Attention! This is our own JarOutputStream, not the java standard! */
-    private com.izforge.izpack.util.JarOutputStream primaryJarStream;
-
-    /** The constructor. 
-     * @throws CompilerException*/
-    public Packager() throws CompilerException
-    {
-        this(&quot;default&quot;);
-    }
-
-    /**
-     * Extended constructor.
-     * @param compr_format Compression format to be used for packs
-     * compression format (if supported)
-     * @throws CompilerException
-     */
-    public Packager(String compr_format) throws CompilerException
-    {
-        this( compr_format, -1);
-    }
-
-    /**
-     * Extended constructor.
-     * @param compr_format Compression format to be used for packs
-     * @param compr_level Compression level to be used with the chosen
-     * compression format (if supported)
-     * @throws CompilerException
-     */
-    public Packager(String compr_format, int compr_level) throws CompilerException
-    {
-        initPackCompressor(compr_format, compr_level);
-    }
-    
-    
-
-    /* (non-Javadoc)
-     * @see com.izforge.izpack.compiler.IPackager#createInstaller(java.io.File)
-     */
-    public void createInstaller(File primaryFile) throws Exception
-    {
-        // preliminary work
-        String baseName = primaryFile.getName();
-        if (baseName.endsWith(&quot;.jar&quot;))
-        {
-            baseName = baseName.substring(0, baseName.length() - 4);
-            baseFile = new File(primaryFile.getParentFile(), baseName);
-        }
-        else
-            baseFile = primaryFile;
-
-        info.setInstallerBase(baseFile.getName());
-        packJarsSeparate = (info.getWebDirURL() != null);
-
-        // primary (possibly only) jar. -1 indicates primary
-        primaryJarStream = getJarOutputStream(baseFile.getName() + &quot;.jar&quot;);
-
-        sendStart();
-        
-        writeInstaller();
-
-        // Finish up. closeAlways is a hack for pack compressions other than
-        // default. Some of it (e.g. BZip2) closes the slave of it also.
-        // But this should not be because the jar stream should be open 
-        // for the next pack. Therefore an own JarOutputStream will be used
-        // which close method will be blocked.
-        primaryJarStream.closeAlways();
-
-        sendStop();
-    }
-
-    /***********************************************************************************************
-     * Private methods used when writing out the installer to jar files.
-     **********************************************************************************************/
-
-    /**
-     * Write skeleton installer to primary jar. It is just an included jar, except that we copy the
-     * META-INF as well.
-     */
-    protected void writeSkeletonInstaller() throws IOException
-    {
-        sendMsg(&quot;Copying the skeleton installer&quot;, PackagerListener.MSG_VERBOSE);
-
-        InputStream is = Packager.class.getResourceAsStream(&quot;/&quot; + SKELETON_SUBPATH);
-        if (is == null)
-        {
-            File skeleton = new File(Compiler.IZPACK_HOME, SKELETON_SUBPATH);
-            is = new FileInputStream(skeleton);
-        }
-        ZipInputStream inJarStream = new ZipInputStream(is);
-        copyZip(inJarStream, primaryJarStream);
-    }
-
-    /**
-     * Write an arbitrary object to primary jar.
-     */
-    protected void writeInstallerObject(String entryName, Object object) throws IOException
-    {
-        primaryJarStream.putNextEntry(new org.apache.tools.zip.ZipEntry(entryName));
-        ObjectOutputStream out = new ObjectOutputStream(primaryJarStream);
-        out.writeObject(object);
-        out.flush();
-        primaryJarStream.closeEntry();
-    }
-
-    /** Write the data referenced by URL to primary jar. */
-    protected void writeInstallerResources() throws IOException
-    {
-        sendMsg(&quot;Copying &quot; + installerResourceURLMap.size() + &quot; files into installer&quot;);
-
-        Iterator i = installerResourceURLMap.keySet().iterator();
-        while (i.hasNext())
-        {
-            String name = (String) i.next();
-            InputStream in = ((URL) installerResourceURLMap.get(name)).openStream();
-            
-            org.apache.tools.zip.ZipEntry newEntry = new org.apache.tools.zip.ZipEntry(name);
-            long dateTime = FileUtil.getFileDateTime((URL) installerResourceURLMap.get(name));
-            if (dateTime != -1)
-                newEntry.setTime(dateTime);
-            primaryJarStream.putNextEntry(newEntry);
-
-            PackagerHelper.copyStream(in, primaryJarStream);
-            primaryJarStream.closeEntry();
-            in.close();
-        }
-    }
-
-    /** Copy included jars to primary jar. */
-    protected void writeIncludedJars() throws IOException
-    {
-        sendMsg(&quot;Merging &quot; + includedJarURLs.size() + &quot; jars into installer&quot;);
-
-        Iterator i = includedJarURLs.iterator();
-        while (i.hasNext())
-        {
-            Object [] current = (Object []) i.next();
-            InputStream is = ((URL) current[0]).openStream();
-            ZipInputStream inJarStream = new ZipInputStream(is);
-            copyZip(inJarStream, primaryJarStream, (List) current[1]);
-        }
-    }
-
-    /**
-     * Write Packs to primary jar or each to a separate jar.
-     */
-    protected void writePacks() throws Exception
-    {
-        final int num = packsList.size();
-        sendMsg(&quot;Writing &quot; + num + &quot; Pack&quot; + (num &gt; 1 ? &quot;s&quot; : &quot;&quot;) + &quot; into installer&quot;);
-
-        // Map to remember pack number and bytes offsets of back references
-        Map storedFiles = new HashMap();
-
-        // First write the serialized files and file metadata data for each pack
-        // while counting bytes.
-        
-        int packNumber = 0;
-        Iterator packIter = packsList.iterator();
-        
-        XMLElement root = new XMLElement(&quot;packs&quot;);
-        
-        while (packIter.hasNext())
-        {
-            PackInfo packInfo = (PackInfo) packIter.next();
-            Pack pack = packInfo.getPack();
-            pack.nbytes = 0;
-            if ((pack.id == null) || (pack.id.length() == 0)) {
-                pack.id=pack.name;
-            }
-
-            // create a pack specific jar if required
-            com.izforge.izpack.util.JarOutputStream packStream = primaryJarStream;
-            if (packJarsSeparate)
-            {
-                // See installer.Unpacker#getPackAsStream for the counterpart
-                String name = baseFile.getName() + &quot;.pack-&quot; + pack.id + &quot;.jar&quot;;
-                packStream = getJarOutputStream(name);
-            }
-            OutputStream comprStream = packStream;
-
-            sendMsg(&quot;Writing Pack &quot; + packNumber + &quot;: &quot; + pack.name, PackagerListener.MSG_VERBOSE);
-
-            // Retrieve the correct output stream
-            org.apache.tools.zip.ZipEntry entry = new org.apache.tools.zip.ZipEntry(&quot;packs/pack-&quot; + pack.id);
-            if( ! compressor.useStandardCompression())
-            {
-                entry.setMethod(ZipEntry.STORED);
-                entry.setComment(compressor.getCompressionFormatSymbols()[0]);
-                // We must set the entry before we get the compressed stream
-                // because some writes initialize data (e.g. bzip2).
-                packStream.putNextEntry(entry);
-                packStream.flush(); // flush before we start counting
-                comprStream = compressor.getOutputStream(packStream);
-            }
-            else
-            {
-                int level = compressor.getCompressionLevel();
-                if( level &gt;= 0 &amp;&amp; level &lt; 10 )
-                    packStream.setLevel(level);
-                packStream.putNextEntry(entry);
-                packStream.flush(); // flush before we start counting
-            }
-
-            ByteCountingOutputStream dos = new ByteCountingOutputStream(comprStream);
-            ObjectOutputStream objOut = new ObjectOutputStream(dos);
-
-            // We write the actual pack files
-            objOut.writeInt(packInfo.getPackFiles().size());
-
-            Iterator iter = packInfo.getPackFiles().iterator();
-            while (iter.hasNext())
-            {
-                boolean addFile = !pack.loose;
-                PackFile pf = (PackFile) iter.next();
-                File file = packInfo.getFile(pf);
-
-                // use a back reference if file was in previous pack, and in
-                // same jar
-                Object[] info = (Object[]) storedFiles.get(file);
-                if (info != null &amp;&amp; !packJarsSeparate)
-                {
-                    pf.setPreviousPackFileRef((String) info[0], (Long)info[1]);
-                    addFile = false;
-                }
-
-                objOut.writeObject(pf); // base info
-                objOut.flush(); // make sure it is written
-
-                if (addFile &amp;&amp; !pf.isDirectory())
-                {
-                    long pos = dos.getByteCount(); // get the position
-
-                    FileInputStream inStream = new FileInputStream(file);
-                    long bytesWritten = PackagerHelper.copyStream(inStream, objOut);
-
-                    if (bytesWritten != pf.length())
-                        throw new IOException(&quot;File size mismatch when reading &quot; + file);
-
-                    inStream.close();
-                    storedFiles.put(file, new Object[] { pack.id, new Long(pos)});
-                }
-
-                // even if not written, it counts towards pack size
-                pack.nbytes += pf.length();
-            }
-
-            // Write out information about parsable files
-            objOut.writeInt(packInfo.getParsables().size());
-            iter = packInfo.getParsables().iterator();
-            while (iter.hasNext())
-                objOut.writeObject(iter.next());
-
-            // Write out information about executable files
-            objOut.writeInt(packInfo.getExecutables().size());
-            iter = packInfo.getExecutables().iterator();
-            while (iter.hasNext())
-                objOut.writeObject(iter.next());
-
-            // Write out information about updatecheck files
-            objOut.writeInt(packInfo.getUpdateChecks().size());
-            iter = packInfo.getUpdateChecks().iterator();
-            while (iter.hasNext())
-                objOut.writeObject(iter.next());
-
-            // Cleanup
-            objOut.flush();
-            if( ! compressor.useStandardCompression())
-            {
-                comprStream.close();
-            }
-
-            packStream.closeEntry();
-
-            // close pack specific jar if required
-            if (packJarsSeparate) packStream.closeAlways();
-
-            XMLElement child = new XMLElement(&quot;pack&quot;);
-            child.setAttribute(&quot;nbytes&quot;, Long.toString(pack.nbytes));
-            child.setAttribute(&quot;name&quot;, pack.name);
-            if(pack.id != null) child.setAttribute(&quot;id&quot;, pack.id);
-            root.addChild(child);
-            
-            packNumber++;
-        }
-        
-        // Write packsinfo for web installers
-		if (packJarsSeparate)
-        {
-			FileWriter writer = new FileWriter(baseFile.getParent()
-              + File.separator + &quot;packsinfo.xml&quot;);
-        	XMLWriter xmlwriter = new XMLWriter(writer);
-        	xmlwriter.write(root);
-		}
-        
-        // Now that we know sizes, write pack metadata to primary jar.
-        primaryJarStream.putNextEntry(new org.apache.tools.zip.ZipEntry(&quot;packs.info&quot;));
-        ObjectOutputStream out = new ObjectOutputStream(primaryJarStream);
-        out.writeInt(packsList.size());
-
-        Iterator i = packsList.iterator();
-        while (i.hasNext())
-        {
-            PackInfo pack = (PackInfo) i.next();
-            out.writeObject(pack.getPack());
-        }
-        out.flush();
-        primaryJarStream.closeEntry();
-    }
-
-    /***********************************************************************************************
-     * Stream utilites for creation of the installer.
-     **********************************************************************************************/
-
-    /** Return a stream for the next jar. */
-    private com.izforge.izpack.util.JarOutputStream getJarOutputStream(String name) throws IOException
-    {
-        File file = new File(baseFile.getParentFile(), name);
-        sendMsg(&quot;Building installer jar: &quot; + file.getAbsolutePath());
-
-        com.izforge.izpack.util.JarOutputStream jar = 
-            new com.izforge.izpack.util.JarOutputStream(file);
-        jar.setLevel(Deflater.BEST_COMPRESSION);
-        jar.setPreventClose(true); // Needed at using FilterOutputStreams which calls close
-                                    // of the slave at finalizing.
-
-        return jar;
-    }
-
-    /**
-     * Copies contents of one jar to another.
-     * 
-     * &lt;p&gt;
-     * TODO: it would be useful to be able to keep signature information from signed jar files, can
-     * we combine manifests and still have their content signed?
-     * 
-     * @see #copyStream(InputStream, OutputStream)
-     */
-    private void copyZip(ZipInputStream zin, org.apache.tools.zip.ZipOutputStream out) throws IOException
-    {
-        copyZip( zin, out, null );
-    }
-
-    /**
-     * Copies specified contents of one jar to another.
-     * 
-     * &lt;p&gt;
-     * TODO: it would be useful to be able to keep signature information from signed jar files, can
-     * we combine manifests and still have their content signed?
-     * 
-     * @see #copyStream(InputStream, OutputStream)
-     */
-    private void copyZip(ZipInputStream zin, org.apache.tools.zip.ZipOutputStream out,
-            List files) 
-    throws IOException
-    {
-        java.util.zip.ZipEntry zentry;
-        if( ! alreadyWrittenFiles.containsKey( out ))
-            alreadyWrittenFiles.put(out, new HashSet());
-        HashSet currentSet = (HashSet) alreadyWrittenFiles.get(out);
-        while ((zentry = zin.getNextEntry()) != null)
-        {
-            String currentName = zentry.getName();
-            String testName = currentName.replace('/', '.');
-            testName = testName.replace('\\', '.');
-            if( files != null )
-            {
-                Iterator i = files.iterator();
-                boolean founded = false;
-                while( i.hasNext())
-                {   // Make &quot;includes&quot; self to support regex.
-                    String doInclude = (String) i.next();
-                    if( testName.matches( doInclude  ) )
-                    {
-                        founded = true;
-                        break;
-                    }
-                }
-                if( ! founded )
-                    continue;
-            }
-            if( currentSet.contains(currentName))
-                continue;
-            try
-            {
-                // Create new entry for zip file.
-                org.apache.tools.zip.ZipEntry newEntry = new org.apache.tools.zip.ZipEntry(currentName);
-                // Get input file date and time.
-                long fileTime = zentry.getTime();
-                // Make sure there is date and time set.
-                if (fileTime != -1)
-                    newEntry.setTime(fileTime); // If found set it into output file.
-                out.putNextEntry(newEntry);
-
-                PackagerHelper.copyStream(zin, out);
-                out.closeEntry();
-                zin.closeEntry();
-                currentSet.add(currentName);
-            }
-            catch (ZipException x)
-            {
-                // This avoids any problem that can occur with duplicate
-                // directories. for instance all META-INF data in jars
-                // unfortunately this do not work with the apache ZipOutputStream...
-            }
-        }
-    }
-    
-    /* (non-Javadoc)
-     * @see com.izforge.izpack.compiler.IPackager#addConfigurationInformation(net.n3.nanoxml.XMLElement)
-     */
-    public void addConfigurationInformation(XMLElement data)
-    {
-        // TODO Auto-generated method stub
-        
-    }
-}

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/Packager.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/compiler/Packager.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/PackagerFactory.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/compiler/PackagerFactory.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/PackagerFactory.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,42 +0,0 @@
-/*
- * $Id: Packager.java 1671 2007-01-02 10:28:58Z dreil $
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- *
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- *
- * Copyright 2006 Dennis Reil
- *
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.izforge.izpack.compiler;
-
-/**
- * Factory class for handling the packager classes 
- * @author Dennis Reil, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">Dennis.Reil at reddot.de</A>&gt;
- */
-public class PackagerFactory
-{
-    /**
-     * Returns a new instantiation of the specified packager
-     * @param classname
-     * @return
-     * @throws InstantiationException
-     * @throws IllegalAccessException
-     * @throws ClassNotFoundException
-     */
-    public static IPackager getPackager(String classname) throws InstantiationException, IllegalAccessException, ClassNotFoundException{
-        return (IPackager) Class.forName(classname).newInstance();
-    }
-}

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/compiler/PackagerFactory.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/compiler/PackagerFactory.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/CompileWorker.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/installer/CompileWorker.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/CompileWorker.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,1451 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Copyright 2003 Tino Schwarze
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *     
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.izforge.izpack.installer;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.PrintStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.StringTokenizer;
-import java.util.Vector;
-
-import net.n3.nanoxml.NonValidator;
-import net.n3.nanoxml.StdXMLParser;
-import net.n3.nanoxml.StdXMLReader;
-import net.n3.nanoxml.XMLElement;
-import net.n3.nanoxml.XMLBuilderFactory;
-
-import com.izforge.izpack.LocaleDatabase;
-import com.izforge.izpack.util.Debug;
-import com.izforge.izpack.util.FileExecutor;
-import com.izforge.izpack.util.OsConstraint;
-import com.izforge.izpack.util.VariableSubstitutor;
-
-/**
- * This class does alle the work for compiling sources.
- * 
- * It responsible for
- * &lt;ul&gt;
- * &lt;li&gt;parsing the compilation spec XML file
- * &lt;li&gt;collecting and creating all jobs
- * &lt;li&gt;doing the actual compilation
- * &lt;/ul&gt;
- * 
- * @author Tino Schwarze
- */
-public class CompileWorker implements Runnable
-{
-
-    /** Compilation jobs */
-    private ArrayList jobs;
-
-    /** Name of resource for specifying compilation parameters. */
-    private static final String SPEC_RESOURCE_NAME = &quot;CompilePanel.Spec.xml&quot;;
-
-    private static final String ECLIPSE_COMPILER_NAME = &quot;Integrated Eclipse JDT Compiler&quot;;
-    
-    private static final String ECLIPSE_COMPILER_CLASS = &quot;org.eclipse.jdt.internal.compiler.batch.Main&quot;;
-    
-    private VariableSubstitutor vs;
-
-    private XMLElement spec;
-
-    private AutomatedInstallData idata;
-
-    private CompileHandler handler;
-
-    private XMLElement compilerSpec;
-
-    private ArrayList compilerList;
-
-    private String compilerToUse;
-
-    private XMLElement compilerArgumentsSpec;
-
-    private ArrayList compilerArgumentsList;
-
-    private String compilerArgumentsToUse;
-
-    private CompileResult result = null;
-
-    /**
-     * The constructor.
-     * 
-     * @param idata The installation data.
-     * @param handler The handler to notify of progress.
-     * 
-     * @throws IOException 
-     */
-    public CompileWorker(AutomatedInstallData idata, CompileHandler handler) throws IOException
-    {
-        this.idata = idata;
-        this.handler = handler;
-        this.vs = new VariableSubstitutor(idata.getVariables());
-        if (!readSpec()) throw new IOException(&quot;Error reading compilation specification&quot;);
-    }
-
-    /**
-     * Return list of compilers to choose from.
-     * 
-     * @return ArrayList of String
-     */
-    public ArrayList getAvailableCompilers()
-    {
-        readChoices(this.compilerSpec, this.compilerList);
-        return this.compilerList;
-    }
-
-    /**
-     * Set the compiler to use.
-     * 
-     * The compiler is checked before compilation starts.
-     * 
-     * @param compiler compiler to use (not checked)
-     */
-    public void setCompiler(String compiler)
-    {
-        this.compilerToUse = compiler;
-    }
-
-    /** 
-     * Get the compiler used.
-     * 
-     * @return the compiler.
-     */
-    public String getCompiler()
-    {
-        return this.compilerToUse;
-    }
-
-    /**
-     * Return list of compiler arguments to choose from.
-     * 
-     * @return ArrayList of String
-     */
-    public ArrayList getAvailableArguments()
-    {
-        readChoices(this.compilerArgumentsSpec, this.compilerArgumentsList);
-        return this.compilerArgumentsList;
-    }
-
-    /** 
-     * Set the compiler arguments to use.
-     * 
-     *  @param arguments The argument to use.
-     */
-    public void setCompilerArguments(String arguments)
-    {
-        this.compilerArgumentsToUse = arguments;
-    }
-
-    /** 
-     * Get the compiler arguments used.
-     * 
-     * @return The arguments used for compiling.
-     */
-    public String getCompilerArguments()
-    {
-        return this.compilerArgumentsToUse;
-    }
-
-    /** 
-     * Get the result of the compilation. 
-     *
-     * @return The result.
-     */
-    public CompileResult getResult()
-    {
-        return this.result;
-    }
-
-    /** Start the compilation in a separate thread. */
-    public void startThread()
-    {
-        Thread compilationThread = new Thread(this, &quot;compilation thread&quot;);
-        // will call this.run()
-        compilationThread.start();
-    }
-
-    /**
-     * This is called when the compilation thread is activated.
-     * 
-     * Can also be called directly if asynchronous processing is not desired.
-     */
-    public void run()
-    {
-        try
-        {
-            if (!collectJobs())
-            {
-                List args = new ArrayList();
-                args.add (&quot;nothing to do&quot;);
-
-                this.result = new CompileResult(this.idata.langpack
-                        .getString(&quot;CompilePanel.worker.nofiles&quot;), args, &quot;&quot;, &quot;&quot;);
-            }
-            else
-            {
-                this.result = compileJobs();
-            }
-        }
-        catch (Exception e)
-        {
-            this.result = new CompileResult(e);
-        }
-
-        this.handler.stopAction();
-    }
-
-    private boolean readSpec()
-    {
-        InputStream input;
-        try
-        {
-            input = ResourceManager.getInstance().getInputStream(SPEC_RESOURCE_NAME);
-        }
-        catch (Exception e)
-        {
-            e.printStackTrace();
-            return false;
-        }
-
-        StdXMLParser parser = new StdXMLParser();
-        parser.setBuilder(XMLBuilderFactory.createXMLBuilder());
-        parser.setValidator(new NonValidator());
-
-        try
-        {
-            parser.setReader(new StdXMLReader(input));
-
-            this.spec = (XMLElement) parser.parse();
-        }
-        catch (Exception e)
-        {
-            System.out.println(&quot;Error parsing XML specification for compilation.&quot;);
-            e.printStackTrace();
-            return false;
-        }
-
-        if (!this.spec.hasChildren()) return false;
-
-        this.compilerArgumentsList = new ArrayList();
-        this.compilerList = new ArrayList();
-
-        // read &lt;global&gt; information
-        XMLElement global = this.spec.getFirstChildNamed(&quot;global&quot;);
-
-        // use some default values if no &lt;global&gt; section found
-        if (global != null)
-        {
-
-            // get list of compilers
-            this.compilerSpec = global.getFirstChildNamed(&quot;compiler&quot;);
-
-            if (this.compilerSpec != null)
-            {
-                readChoices(this.compilerSpec, this.compilerList);
-            }
-
-            this.compilerArgumentsSpec = global.getFirstChildNamed(&quot;arguments&quot;);
-
-            if (this.compilerArgumentsSpec != null)
-            {
-                // basicly perform sanity check
-                readChoices(this.compilerArgumentsSpec, this.compilerArgumentsList);
-            }
-
-        }
-
-        // supply default values if no useful ones where found
-        if (this.compilerList.size() == 0)
-        {
-            this.compilerList.add(&quot;javac&quot;);
-            this.compilerList.add(&quot;jikes&quot;);
-        }
-
-        if (this.compilerArgumentsList.size() == 0)
-        {
-            this.compilerArgumentsList.add(&quot;-O -g:none&quot;);
-            this.compilerArgumentsList.add(&quot;-O&quot;);
-            this.compilerArgumentsList.add(&quot;-g&quot;);
-            this.compilerArgumentsList.add(&quot;&quot;);
-        }
-
-        return true;
-    }
-
-    // helper function
-    private void readChoices(XMLElement element, ArrayList choiceList)
-    {
-        Vector choices = element.getChildrenNamed(&quot;choice&quot;);
-
-        if (choices == null) return;
-
-        choiceList.clear();
-
-        Iterator choice_it = choices.iterator();
-
-        while (choice_it.hasNext())
-        {
-            XMLElement choice = (XMLElement) choice_it.next();
-
-            String value = choice.getAttribute(&quot;value&quot;);
-
-            if (value != null)
-            {
-                List osconstraints = OsConstraint.getOsList(choice);
-
-                if (OsConstraint.oneMatchesCurrentSystem(osconstraints))
-                {
-                    if (value.equalsIgnoreCase(ECLIPSE_COMPILER_NAME))
-                    {
-                        // check for availability of eclipse compiler
-                        try
-                        {
-                            Class.forName(ECLIPSE_COMPILER_CLASS);
-                            choiceList.add(value);
-                        }
-                        catch (ExceptionInInitializerError eiie)
-                        {
-                            // ignore, just don't add it as a choice                            
-                        }
-                        catch (ClassNotFoundException cnfe)
-                        {
-                            // ignore, just don't add it as a choice
-                        }
-                    }
-                    else
-                        choiceList.add(this.vs.substitute(value, &quot;plain&quot;));
-                }
-            }
-
-        }
-
-    }
-
-    /**
-     * Parse the compilation specification file and create jobs.
-     */
-    private boolean collectJobs() throws Exception
-    {
-        XMLElement data = this.spec.getFirstChildNamed(&quot;jobs&quot;);
-
-        if (data == null) return false;
-
-        // list of classpath entries
-        ArrayList classpath = new ArrayList();
-
-        this.jobs = new ArrayList();
-
-        // we throw away the toplevel compilation job
-        // (all jobs are collected in this.jobs)
-        collectJobsRecursive(data, classpath);
-
-        return true;
-    }
-
-    /** perform the actual compilation */
-    private CompileResult compileJobs()
-    {
-        ArrayList args = new ArrayList();
-        StringTokenizer tokenizer = new StringTokenizer(this.compilerArgumentsToUse);
-
-        while (tokenizer.hasMoreTokens())
-        {
-            args.add(tokenizer.nextToken());
-        }
-
-        Iterator job_it = this.jobs.iterator();
-
-        this.handler.startAction(&quot;Compilation&quot;, this.jobs.size());
-
-        // check whether compiler is valid (but only if there are jobs)
-        if (job_it.hasNext())
-        {
-            CompilationJob first_job = (CompilationJob) this.jobs.get(0);
-
-            CompileResult check_result = first_job.checkCompiler(this.compilerToUse, args);
-            if (!check_result.isContinue()) { return check_result; }
-
-        }
-
-        int job_no = 0;
-
-        while (job_it.hasNext())
-        {
-            CompilationJob job = (CompilationJob) job_it.next();
-
-            this.handler.nextStep(job.getName(), job.getSize(), job_no++);
-
-            CompileResult job_result = job.perform(this.compilerToUse, args);
-
-            if (!job_result.isContinue()) return job_result;
-        }
-
-        Debug.trace(&quot;compilation finished.&quot;);
-        return new CompileResult();
-    }
-
-    private CompilationJob collectJobsRecursive(XMLElement node, ArrayList classpath)
-            throws Exception
-    {
-        Enumeration toplevel_tags = node.enumerateChildren();
-        ArrayList ourclasspath = (ArrayList) classpath.clone();
-        ArrayList files = new ArrayList();
-
-        while (toplevel_tags.hasMoreElements())
-        {
-            XMLElement child = (XMLElement) toplevel_tags.nextElement();
-
-            if (&quot;classpath&quot;.equals(child.getName()))
-            {
-                changeClassPath(ourclasspath, child);
-            }
-            else if (&quot;job&quot;.equals(child.getName()))
-            {
-                CompilationJob subjob = collectJobsRecursive(child, ourclasspath);
-                if (subjob != null) this.jobs.add(subjob);
-            }
-            else if (&quot;directory&quot;.equals(child.getName()))
-            {
-                String name = child.getAttribute(&quot;name&quot;);
-
-                if (name != null)
-                {
-                    // substitute variables
-                    String finalname = this.vs.substitute(name, &quot;plain&quot;);
-
-                    files.addAll(scanDirectory(new File(finalname)));
-                }
-
-            }
-            else if (&quot;file&quot;.equals(child.getName()))
-            {
-                String name = child.getAttribute(&quot;name&quot;);
-
-                if (name != null)
-                {
-                    // substitute variables
-                    String finalname = this.vs.substitute(name, &quot;plain&quot;);
-
-                    files.add(new File(finalname));
-                }
-
-            }
-            else if (&quot;packdepency&quot;.equals(child.getName()))
-            {
-                String name = child.getAttribute(&quot;name&quot;);
-
-                if (name == null)
-                {
-                    System.out
-                            .println(&quot;invalid compilation spec: &lt;packdepency&gt; without name attribute&quot;);
-                    return null;
-                }
-
-                // check whether the wanted pack was selected for installation
-                Iterator pack_it = this.idata.selectedPacks.iterator();
-                boolean found = false;
-
-                while (pack_it.hasNext())
-                {
-                    com.izforge.izpack.Pack pack = (com.izforge.izpack.Pack) pack_it.next();
-
-                    if (pack.name.equals(name))
-                    {
-                        found = true;
-                        break;
-                    }
-                }
-
-                if (!found)
-                {
-                    Debug.trace(&quot;skipping job because pack &quot; + name + &quot; was not selected.&quot;);
-                    return null;
-                }
-
-            }
-
-        }
-
-        if (files.size() &gt; 0)
-            return new CompilationJob(this.handler, this.idata, node.getAttribute(&quot;name&quot;), files, ourclasspath);
-
-        return null;
-    }
-
-    /** helper: process a &lt;code&gt;&amp;lt;classpath&amp;gt;&lt;/code&gt; tag. */
-    private void changeClassPath(ArrayList classpath, XMLElement child) throws Exception
-    {
-        String add = child.getAttribute(&quot;add&quot;);
-        if (add != null)
-        {
-            add = this.vs.substitute(add, &quot;plain&quot;);
-            if (!new File(add).exists())
-            {
-                if (!this.handler.emitWarning(&quot;Invalid classpath&quot;, &quot;The path &quot; + add
-                        + &quot; could not be found.\nCompilation may fail.&quot;))
-                    throw new Exception(&quot;Classpath &quot; + add + &quot; does not exist.&quot;);
-            }
-            else
-            {
-                classpath.add(this.vs.substitute(add, &quot;plain&quot;));
-            }
-
-        }
-
-        String sub = child.getAttribute(&quot;sub&quot;);
-        if (sub != null)
-        {
-            int cpidx = -1;
-            sub = this.vs.substitute(sub, &quot;plain&quot;);
-
-            do
-            {
-                cpidx = classpath.indexOf(sub);
-                classpath.remove(cpidx);
-            }
-            while (cpidx &gt;= 0);
-
-        }
-
-    }
-
-    /**
-     * helper: recursively scan given directory.
-     * 
-     * @return list of files found (might be empty)
-     */
-    private ArrayList scanDirectory(File path)
-    {
-        Debug.trace(&quot;scanning directory &quot; + path.getAbsolutePath());
-
-        ArrayList scan_result = new ArrayList();
-
-        if (!path.isDirectory()) return scan_result;
-
-        File[] entries = path.listFiles();
-
-        for (int i = 0; i &lt; entries.length; i++)
-        {
-            File f = entries[i];
-
-            if (f == null) continue;
-
-            if (f.isDirectory())
-            {
-                scan_result.addAll(scanDirectory(f));
-            }
-            else if ((f.isFile()) &amp;&amp; (f.getName().toLowerCase().endsWith(&quot;.java&quot;)))
-            {
-                scan_result.add(f);
-            }
-
-        }
-
-        return scan_result;
-    }
-
-    /** a compilation job */
-    private static class CompilationJob
-    {
-
-        private CompileHandler listener;
-
-        private String name;
-
-        private ArrayList files;
-
-        private ArrayList classpath;
-
-        private LocaleDatabase langpack;
-
-        private AutomatedInstallData idata;
-        
-        // XXX: figure that out (on runtime?)
-        private static final int MAX_CMDLINE_SIZE = 4096;
-
-        /**
-         * Construct new compilation job.
-         * 
-         * @param listener The listener to report progress to.
-         * @param idata The installation data.
-         * @param name The name of the job.
-         * @param files The files to compile.
-         * @param classpath The class path to use.
-         */
-        public CompilationJob(CompileHandler listener, AutomatedInstallData idata, String name,
-                ArrayList files, ArrayList classpath)
-        {
-            this.listener = listener;
-            this.idata = idata;
-            this.langpack = idata.langpack;
-            this.name = name;
-            this.files = files;
-            this.classpath = classpath;
-        }
-
-        /**
-         * Get the name of the job.
-         * 
-         * @return The name or an empty string if there is no name.
-         */
-        public String getName()
-        {
-            if (this.name != null) return this.name;
-
-            return &quot;&quot;;
-        }
-
-        /**
-         * Get the number of files in this job.
-         * 
-         * @return The number of files to compile.
-         */
-        public int getSize()
-        {
-            return this.files.size();
-        }
-
-        /**
-         * Perform this job - start compilation.
-         * 
-         * @param compiler The compiler to use.
-         * @param arguments The compiler arguments to use.
-         * @return The result.
-         */
-        public CompileResult perform(String compiler, ArrayList arguments)
-        {
-            Debug.trace(&quot;starting job &quot; + this.name);
-            // we have some maximum command line length - need to count
-            int cmdline_len = 0;
-
-            // used to collect the arguments for executing the compiler
-            LinkedList args = new LinkedList(arguments);
-
-            {
-                Iterator arg_it = args.iterator();
-                while (arg_it.hasNext())
-                    cmdline_len += ((String) arg_it.next()).length() + 1;
-            }
-
-            boolean isEclipseCompiler = compiler.equalsIgnoreCase(ECLIPSE_COMPILER_NAME);
-            
-            // add compiler in front of arguments
-            args.add(0, compiler);
-            cmdline_len += compiler.length() + 1;
-
-            // construct classpath argument for compiler
-            // - collect all classpaths
-            StringBuffer classpath_sb = new StringBuffer();
-            Iterator cp_it = this.classpath.iterator();
-            while (cp_it.hasNext())
-            {
-                String cp = (String) cp_it.next();
-                if (classpath_sb.length() &gt; 0) classpath_sb.append(File.pathSeparatorChar);
-                classpath_sb.append(new File(cp).getAbsolutePath());
-            }
-
-            String classpath_str = classpath_sb.toString();
-
-            // - add classpath argument to command line
-            if (classpath_str.length() &gt; 0)
-            {
-                args.add(&quot;-classpath&quot;);
-                cmdline_len += 11;
-                args.add(classpath_str);
-                cmdline_len += classpath_str.length() + 1;
-            }
-
-            // remember how many arguments we have which don't change for the
-            // job
-            int common_args_no = args.size();
-            // remember how long the common command line is
-            int common_args_len = cmdline_len;
-
-            // used for execution
-            FileExecutor executor = new FileExecutor();
-            String output[] = new String[2];
-
-            // used for displaying the progress bar
-            String jobfiles = &quot;&quot;;
-            int fileno = 0;
-            int last_fileno = 0;
-
-            // now iterate over all files of this job
-            Iterator file_it = this.files.iterator();
-
-            while (file_it.hasNext())
-            {
-                File f = (File) file_it.next();
-
-                String fpath = f.getAbsolutePath();
-
-                Debug.trace(&quot;processing &quot; + fpath);
-
-                // we add the file _first_ to the arguments to have a better
-                // chance to get something done if the command line is almost
-                // MAX_CMDLINE_SIZE or even above
-                fileno++;
-                jobfiles += f.getName() + &quot; &quot;;
-                args.add(fpath);
-                cmdline_len += fpath.length();
-
-                // start compilation if maximum command line length reached
-                if (! isEclipseCompiler &amp;&amp; cmdline_len &gt;= MAX_CMDLINE_SIZE)
-                {
-                    Debug.trace(&quot;compiling &quot; + jobfiles);
-
-                    // display useful progress bar (avoid showing 100% while
-                    // still compiling a lot)
-                    this.listener.progress(last_fileno, jobfiles);
-                    last_fileno = fileno;
-
-                    int retval = runCompiler(executor, output, args);
-
-                    // update progress bar: compilation of fileno files done
-                    this.listener.progress(fileno, jobfiles);
-
-                    if (retval != 0)
-                    {
-                        CompileResult result = new CompileResult(this.langpack
-                                .getString(&quot;CompilePanel.error&quot;), args, output[0],
-                                output[1]);
-                        this.listener.handleCompileError(result);
-                        if (!result.isContinue()) return result;
-                    }
-                    else
-                    {
-                        // verify that all files have been compiled successfully
-                        // I found that sometimes, no error code is returned
-                        // although compilation failed.
-                        Iterator arg_it = args.listIterator(common_args_no);
-                        while (arg_it.hasNext())
-                        {
-                            File java_file = new File((String) arg_it.next());
-
-                            String basename = java_file.getName();
-                            int dotpos = basename.lastIndexOf('.');
-                            basename = basename.substring(0, dotpos) + &quot;.class&quot;;
-                            File class_file = new File(java_file.getParentFile(), basename);
-
-                            if (!class_file.exists())
-                            {
-                                CompileResult result = new CompileResult(this.langpack
-                                        .getString(&quot;CompilePanel.error.noclassfile&quot;)
-                                        + java_file.getAbsolutePath(), args, output[0],
-                                        output[1]);
-                                this.listener.handleCompileError(result);
-                                if (!result.isContinue()) return result;
-                                // don't continue any further
-                                break;
-                            }
-
-                        }
-
-                    }
-
-                    // clean command line: remove files we just compiled
-                    for (int i = args.size() - 1; i &gt;= common_args_no; i--)
-                    {
-                        args.removeLast();
-                    }
-
-                    cmdline_len = common_args_len;
-                    jobfiles = &quot;&quot;;
-                }
-
-            }
-
-            if (cmdline_len &gt; common_args_len)
-            {
-                this.listener.progress(last_fileno, jobfiles);
-
-                int retval = runCompiler(executor, output, args);
-
-                if (! isEclipseCompiler)
-                    this.listener.progress(fileno, jobfiles);
-
-                if (retval != 0)
-                {
-                    CompileResult result = new CompileResult(this.langpack
-                            .getString(&quot;CompilePanel.error&quot;), args, output[0], output[1]);
-                    this.listener.handleCompileError(result);
-                    if (!result.isContinue()) return result;
-                }
-                else
-                {
-                    // verify that all files have been compiled successfully
-                    // I found that sometimes, no error code is returned
-                    // although compilation failed.
-                    Iterator arg_it = args.listIterator(common_args_no);
-                    while (arg_it.hasNext())
-                    {
-                        File java_file = new File((String) arg_it.next());
-
-                        String basename = java_file.getName();
-                        int dotpos = basename.lastIndexOf('.');
-                        basename = basename.substring(0, dotpos) + &quot;.class&quot;;
-                        File class_file = new File(java_file.getParentFile(), basename);
-
-                        if (!class_file.exists())
-                        {
-                            CompileResult result = new CompileResult(this.langpack
-                                    .getString(&quot;CompilePanel.error.noclassfile&quot;)
-                                    + java_file.getAbsolutePath(), args, output[0],
-                                    output[1]);
-                            this.listener.handleCompileError(result);
-                            if (!result.isContinue()) return result;
-                            // don't continue any further
-                            break;
-                        }
-
-                    }
-
-                }
-
-            }
-
-            Debug.trace(&quot;job &quot; + this.name + &quot; done (&quot; + fileno + &quot; files compiled)&quot;);
-
-            return new CompileResult();
-        }
-
-        /**
-         * Internal helper method.
-         * 
-         * @param executor The executor, only used when using external compiler.
-         * @param output The output from the compiler ([0] = stdout, [1] = stderr)
-         * @param full_cmdline The command line, first argument is the compiler.
-         * 
-         * @return The result of the compilation.
-         */
-        private int runCompiler(FileExecutor executor, String[] output, List cmdline)
-        {
-            if (cmdline.get(0).equals (ECLIPSE_COMPILER_NAME))
-                return runEclipseCompiler(output, cmdline);
-            
-            return executor.executeCommand((String[])cmdline.toArray(new String[cmdline.size()]), output);
-        }
-
-        private int runEclipseCompiler (String[] output, List cmdline)
-        {
-            try
-            {
-                List final_cmdline = new LinkedList (cmdline);
-
-                // remove compiler name from argument list
-                final_cmdline.remove(0);
-                
-                Class eclipseCompiler = Class.forName (ECLIPSE_COMPILER_CLASS);
-                
-                Method compileMethod = eclipseCompiler.getMethod(&quot;main&quot;, new Class[] { String[].class });
-                
-                final_cmdline.add (0, &quot;-noExit&quot;);
-                final_cmdline.add (0, &quot;-progress&quot;);
-                final_cmdline.add (0, &quot;-verbose&quot;);
-                
-                File _logfile = new File (this.idata.getInstallPath(), &quot;compile-&quot;+getName()+&quot;.log&quot;);
-                
-                if (Debug.isTRACE())
-                {                    
-                    final_cmdline.add(0, _logfile.getPath());
-                    final_cmdline.add(0, &quot;-log&quot;);
-                }
-                
-                // get log files / determine results...
-                try
-                {
-                    // capture stdout and stderr
-                    PrintStream _orgStdout = System.out;
-                    PrintStream _orgStderr = System.err;
-                    int error_count = 0;
-                    
-                    try
-                    {                    
-                        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
-                        EclipseStdOutHandler ownStdout = new EclipseStdOutHandler (outStream, this.listener);
-                        System.setOut (ownStdout);
-                        ByteArrayOutputStream errStream = new ByteArrayOutputStream();
-                        EclipseStdErrHandler ownStderr = new EclipseStdErrHandler (errStream, this.listener);
-                        System.setErr (ownStderr);
-                        
-                        compileMethod.invoke(null, new Object[] { final_cmdline.toArray(new String[final_cmdline.size()])});
-                        
-                        // TODO: launch thread which updates the progress
-                        output[0] = outStream.toString();
-                        output[1] = errStream.toString();
-                        error_count = ownStderr.getErrorCount();
-                        // for debugging: write output to log files
-                        if (error_count &gt; 0 || Debug.isTRACE())
-                        {
-                            File _out = new File (_logfile.getPath()+&quot;.stdout&quot;);
-                            FileOutputStream _fout = new FileOutputStream (_out);
-                            _fout.write(outStream.toByteArray());
-                            _fout.close();
-                            _out = new File (_logfile.getPath()+&quot;.stderr&quot;);
-                            _fout = new FileOutputStream (_out);
-                            _fout.write (errStream.toByteArray());
-                            _fout.close();
-                        }
-                        
-                    }
-                    finally
-                    {
-                        System.setOut(_orgStdout);
-                        System.setErr(_orgStderr);                    
-                    }
-                    
-                    if (error_count == 0)
-                        return 0;
-                    
-                    // TODO: construct human readable error message from log
-                    this.listener.emitNotification(&quot;Compiler reported &quot;+error_count+&quot; errors&quot;);
-                    
-                    return 1;
-                }
-                catch (FileNotFoundException fnfe)
-                {
-                    this.listener.emitError(&quot;error compiling&quot;, fnfe.getMessage());
-                    return -1;
-                }
-                catch (IOException ioe)
-                {
-                    this.listener.emitError(&quot;error compiling&quot;, ioe.getMessage());                        
-                    return -1;
-                }
-
-            }
-            catch (ClassNotFoundException cnfe)
-            {
-                output[0] = &quot;error getting eclipse compiler&quot;;
-                output[1] = cnfe.getMessage();
-                return -1;
-            }
-            catch (NoSuchMethodException nsme)
-            {
-                output[0] = &quot;error getting eclipse compiler method&quot;;
-                output[1] = nsme.getMessage();
-                return -1;                    
-            }
-            catch (IllegalAccessException iae)
-            {
-                output[0] = &quot;error calling eclipse compiler&quot;;
-                output[1] = iae.getMessage();
-                return -1;                                        
-            }
-            catch (InvocationTargetException ite)
-            {
-                output[0] = &quot;error calling eclipse compiler&quot;;
-                output[1] = ite.getMessage();
-                return -1;                                        
-            }
-
-        }
-        
-        /**
-         * Check whether the given compiler works.
-         * 
-         * This performs two steps:
-         * &lt;ol&gt;
-         * &lt;li&gt;check whether we can successfully call &quot;compiler -help&quot;&lt;/li&gt;
-         * &lt;li&gt;check whether we can successfully call &quot;compiler -help arguments&quot; (not all compilers
-         * return an error here)&lt;/li&gt;
-         * &lt;/ol&gt;
-         * 
-         * On failure, the method CompileHandler#errorCompile is called with a descriptive error
-         * message.
-         * 
-         * @param compiler the compiler to use
-         * @param arguments additional arguments to pass to the compiler
-         * @return false on error
-         */
-        public CompileResult checkCompiler(String compiler, ArrayList arguments)
-        {
-            // don't do further checks for eclipse compiler - it would exit
-            if (compiler.equalsIgnoreCase(ECLIPSE_COMPILER_NAME))
-                return new CompileResult();
-            
-            int retval = 0;
-            FileExecutor executor = new FileExecutor();
-            String[] output = new String[2];
-
-            Debug.trace(&quot;checking whether \&quot;&quot; + compiler + &quot; -help\&quot; works&quot;);
-
-            {
-                List args = new ArrayList();
-                args.add (compiler);
-                args.add (&quot;-help&quot;);
-
-                retval = runCompiler(executor, output, args);
-
-                if (retval != 0)
-                {
-                    CompileResult result = new CompileResult(this.langpack
-                            .getString(&quot;CompilePanel.error.compilernotfound&quot;), args, output[0],
-                            output[1]);
-                    this.listener.handleCompileError(result);
-                    if (!result.isContinue()) return result;
-                }
-            }
-
-            Debug.trace(&quot;checking whether \&quot;&quot; + compiler + &quot; -help +arguments\&quot; works&quot;);
-
-            // used to collect the arguments for executing the compiler
-            LinkedList args = new LinkedList(arguments);
-
-            // add -help argument to prevent the compiler from doing anything
-            args.add(0, &quot;-help&quot;);
-
-            // add compiler in front of arguments
-            args.add(0, compiler);
-
-            // construct classpath argument for compiler
-            // - collect all classpaths
-            StringBuffer classpath_sb = new StringBuffer();
-            Iterator cp_it = this.classpath.iterator();
-            while (cp_it.hasNext())
-            {
-                String cp = (String) cp_it.next();
-                if (classpath_sb.length() &gt; 0) classpath_sb.append(File.pathSeparatorChar);
-                classpath_sb.append(new File(cp).getAbsolutePath());
-            }
-
-            String classpath_str = classpath_sb.toString();
-
-            // - add classpath argument to command line
-            if (classpath_str.length() &gt; 0)
-            {
-                args.add(&quot;-classpath&quot;);
-                args.add(classpath_str);
-            }
-
-            retval = runCompiler(executor, output, args);
-
-            if (retval != 0)
-            {
-                CompileResult result = new CompileResult(this.langpack
-                        .getString(&quot;CompilePanel.error.invalidarguments&quot;), args, output[0],
-                        output[1]);
-                this.listener.handleCompileError(result);
-                if (!result.isContinue()) return result;
-            }
-
-            return new CompileResult();
-        }
-
-    }
-
-    /**
-     * This PrintStream is used to track the Eclipse compiler output.
-     * 
-     * It will pass on all println requests and report progress to the listener.
-     */
-    private static class EclipseStdOutHandler extends PrintStream
-    {   
-        private CompileHandler listener;
-        private StdOutParser parser;
-        
-        /**
-         * Default constructor.
-         * 
-         * @param anOutputStream The stream to wrap.
-         * @param aHandler the handler to use.
-         */
-        public EclipseStdOutHandler(final OutputStream anOutputStream, final CompileHandler aHandler)     
-        {
-            // initialize with dummy stream (PrintStream needs it)
-            super(anOutputStream);
-            this.listener = aHandler;
-            this.parser = new StdOutParser();
-        }
-        
-        /**
-         * Eclipse compiler hopefully only uses println(String).
-         * 
-         * {@inheritDoc}
-         */
-        public void println(String x)
-        {
-            if (x.startsWith (&quot;[completed &quot;))
-            {
-                int pos = x.lastIndexOf (&quot;#&quot;);
-                int endpos = x.lastIndexOf (&quot;/&quot;);
-                String fileno_str = x.substring (pos+1, endpos-pos-1);
-                try
-                {
-                    int fileno = Integer.parseInt(fileno_str);
-                    this.listener.progress(fileno, x);
-                }
-                catch (NumberFormatException _nfe)
-                {
-                    Debug.log(&quot;could not parse eclipse compiler output: '&quot;+x+&quot;': &quot;+_nfe.getMessage());
-                }
-            }
-            
-            super.println(x);
-        }
-     
-        /**
-         * Unfortunately, the Eclipse compiler wraps System.out into a BufferedWriter.
-         * 
-         * So we get whole buffers here and cannot do anything about it.
-         * 
-         * {@inheritDoc}
-         */
-        public void write(byte[] buf, int off, int len)
-        {
-            super.write(buf, off, len);
-            // we cannot convert back to string because the buffer might start
-            // _inside_ a multibyte character
-            // so we build a simple parser.
-            int _fileno = this.parser.parse (buf, off, len);
-            if (_fileno &gt; -1)
-            {
-                this.listener.setSubStepNo(this.parser.getJobSize());
-                this.listener.progress(_fileno, this.parser.getLastFilename());
-            }
-        }
-        
-    }
-    
-    /**
-     * This PrintStream is used to track the Eclipse compiler error output.
-     * 
-     * It will pass on all println requests and report progress to the listener.
-     */
-    private static class EclipseStdErrHandler extends PrintStream
-    {   
-        // private CompileHandler listener;   // Unused
-        private int errorCount = 0;
-        private StdErrParser parser;
-        
-        /**
-         * Default constructor.
-         * 
-         * @param anOutputStream The stream to wrap.
-         * @param aHandler the handler to use.
-         */
-        public EclipseStdErrHandler(final OutputStream anOutputStream, final CompileHandler aHandler)     
-        {
-            // initialize with dummy stream (PrintStream needs it)
-            super(anOutputStream);
-            // this.listener = aHandler; // TODO : reactivate this when we want to do something with it
-            this.parser = new StdErrParser();
-        }
-        
-        /**
-         * Eclipse compiler hopefully only uses println(String).
-         * 
-         * {@inheritDoc}
-         */
-        public void println(String x)
-        {
-            if (x.indexOf (&quot;. ERROR in &quot;) &gt; 0)
-            {                
-                this.errorCount++;
-            }
-            
-            super.println(x);
-        }
-        
-        /**
-         * Unfortunately, the Eclipse compiler wraps System.out into a BufferedWriter.
-         * 
-         * So we get whole buffers here and cannot do anything about it.
-         * 
-         * {@inheritDoc}
-         */
-        public void write(byte[] buf, int off, int len)
-        {
-            super.write(buf, off, len);
-            // we cannot convert back to string because the buffer might start
-            // _inside_ a multibyte character
-            // so we build a simple parser.
-            int _errno = this.parser.parse (buf, off, len);
-            if (_errno &gt; 0)
-            {
-                // TODO: emit error message instantly, but it may be incomplete yet
-                // and we'd need to throw an exception to abort compilation
-                this.errorCount += _errno;
-            }
-        }
-        
-        /**
-         * Get the error state.
-         * 
-         * @return true if there was an error detected.
-         */
-        public int getErrorCount()
-        {
-            return this.errorCount;
-        }
-    }
-    
-    /**
-     * Common class for parsing Eclipse compiler output.
-     */
-    private static abstract class StreamParser
-    {
-        int idx;
-        byte[] buffer;
-        int offset;
-        int length;
-        byte[] lastIdentifier;
-        int lastDigit;
-        
-        abstract int parse (byte[] buf, int off, int len);
-        
-        void init(byte[] buf, int off, int len)
-        {
-            this.buffer = buf;
-            this.offset = off;
-            this.length = len;
-            this.idx = 0;
-            this.lastIdentifier = null;
-            this.lastDigit = -1;           
-        }
-        
-        int getNext()
-        {
-            if (this.offset+this.idx == this.length)
-                return Integer.MIN_VALUE;
-            
-            return this.buffer[this.offset+this.idx++];
-        }
-        
-        boolean findString (final String aString)
-        {
-            byte[] _search_bytes = aString.getBytes();
-            int _search_idx = 0;
-            
-            do
-            {
-                int _c = getNext();
-                if (_c == Integer.MIN_VALUE)
-                    return false;
-                
-                if (_c == _search_bytes[_search_idx])
-                    _search_idx++;
-                else
-                {
-                    _search_idx = 0;
-                    if (_c == _search_bytes[_search_idx])
-                        _search_idx++;
-                }
-            }
-            while (_search_idx &lt; _search_bytes.length);
-            
-            return true;
-        }
-        
-        boolean readIdentifier()
-        {
-            int _c;
-            int _start_idx = this.idx;
-            
-            do
-            {
-                _c = getNext();
-                // abort on incomplete string
-                if (_c == Integer.MIN_VALUE)
-                    return false;
-            }
-            while (! Character.isWhitespace((char)_c));
-            
-            this.idx--;
-            this.lastIdentifier = new byte[this.idx-_start_idx];
-            System.arraycopy (this.buffer, _start_idx, this.lastIdentifier, 0, this.idx-_start_idx);
-            
-            return true;                
-        }
-                    
-        boolean readNumber()
-        {
-            int _c;
-            int _start_idx = this.idx;
-            
-            do
-            {
-                _c = getNext();
-                // abort on incomplete string
-                if (_c == Integer.MIN_VALUE)
-                    return false;
-            }
-            while (Character.isDigit((char)_c));
-            
-            this.idx--;
-            String _digit_str = new String (this.buffer, _start_idx, this.idx-_start_idx);
-            try
-            {
-                this.lastDigit = Integer.parseInt(_digit_str);
-            }
-            catch (NumberFormatException _nfe)
-            {
-                // should not happen - ignore                    
-            }
-            
-            return true;                
-        }
-                    
-        boolean skipSpaces()
-        {
-            int _c;
-            
-            do
-            {
-                _c = getNext();
-                if (_c == Integer.MIN_VALUE)
-                    return false;
-            }
-            while (Character.isWhitespace((char)_c));
-            
-            this.idx--;
-            
-            return true;
-        }
-        
-    }
-
-    private static class StdOutParser extends StreamParser
-    {
-        int fileno;
-        int jobSize;
-        String lastFilename;
-        
-        int parse (byte[] buf, int off, int len)
-        {
-            super.init(buf, off, len);
-            this.fileno = -1;
-            this.jobSize = -1;
-            this.lastFilename = null;
-
-            // a line looks like this:
-            // [completed  /path/to/file.java - #1/2025]
-            do
-            {                
-                if (findString (&quot;[completed &quot;)
-                    &amp;&amp; skipSpaces ()
-                    &amp;&amp; readIdentifier())
-                {
-                    // remember file name
-                    String filename = new String(this.lastIdentifier);
-                    
-                    if (! skipSpaces())
-                        continue;
-                    
-                    int _c = getNext();
-                    if (_c == Integer.MIN_VALUE)
-                        return this.fileno;
-                    if (_c != '-')
-                        continue;
-                    
-                    if (! skipSpaces())
-                        continue;
-                    
-                    _c = getNext();
-                    if (_c == Integer.MIN_VALUE)
-                        return this.fileno;
-                    if (_c != '#')
-                        continue;
-                    
-                    if (! readNumber())                        
-                        return this.fileno;
-
-                    int _fileno = this.lastDigit;
-                    
-                    _c = getNext();
-                    if (_c == Integer.MIN_VALUE)
-                        return this.fileno;
-                    if (_c != '/')
-                        continue;
-                                            
-                    if (! readNumber())                        
-                        return this.fileno;
-                    
-                    _c = getNext();
-                    if (_c == Integer.MIN_VALUE)
-                        return this.fileno;
-                    if (_c != ']')
-                        continue;
-                    
-                    this.lastFilename = filename;
-                    this.fileno = _fileno;
-                    this.jobSize = this.lastDigit;
-                    // continue parsing (figure out last occurence)
-                }
-                else
-                    return this.fileno;
-                
-            }
-            while (true);
-        }
-        
-        String getLastFilename ()
-        {
-            return this.lastFilename;
-        }
-        
-        int getJobSize()
-        {
-            return this.jobSize;
-        }
-    }
-
-    private static class StdErrParser extends StreamParser
-    {
-        int errorCount;
-        
-        int parse (byte[] buf, int off, int len)
-        {
-            super.init (buf, off, len);
-            this.errorCount = 0;
-
-            // a line looks like this:
-            // [completed  /path/to/file.java - #1/2025]
-            do
-            {                
-                if (findString (&quot;. ERROR in &quot;))
-                    this.errorCount++;
-                else
-                    return this.errorCount;                
-            }
-            while (true);
-        }
-        
-        int getErrorCount ()
-        {
-            return this.errorCount;
-        }
-    }
-}

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/CompileWorker.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/installer/CompileWorker.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/InstallerBase.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/installer/InstallerBase.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/InstallerBase.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,378 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Copyright 2003 Jonathan Halliday
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *     
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.izforge.izpack.installer;
-
-import java.io.File;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Properties;
-import java.net.InetAddress;
-
-import com.izforge.izpack.CustomData;
-import com.izforge.izpack.Info;
-import com.izforge.izpack.Pack;
-import com.izforge.izpack.util.Debug;
-import com.izforge.izpack.util.IoHelper;
-import com.izforge.izpack.util.OsConstraint;
-import com.izforge.izpack.util.OsVersion;
-import com.izforge.izpack.util.VariableSubstitutor;
-
-/**
- * Common utility functions for the GUI and text installers. (Do not import swing/awt classes to
- * this class.)
- * 
- * @author Jonathan Halliday
- * @author Julien Ponge
- */
-public class InstallerBase
-{
-
-    /**
-     * The base name of the XML file that specifies the custom langpack. Searched is for the file
-     * with the name expanded by _ISO3.
-     */
-    protected static final String LANG_FILE_NAME = &quot;CustomLangpack.xml&quot;;
-
-    /**
-     * Loads the installation data. Also sets environment variables to &lt;code&gt;installdata&lt;/code&gt;.
-     * All system properties are available as $SYSTEM_&lt;variable&gt; where &lt;variable&gt; is the actual
-     * name _BUT_ with all separators replaced by '_'. Properties with null values are never stored.
-     * Example: $SYSTEM_java_version or $SYSTEM_os_name
-     * 
-     * @param installdata Where to store the installation data.
-     * 
-     * @exception Exception Description of the Exception
-     */
-    public void loadInstallData(AutomatedInstallData installdata) throws Exception
-    {
-        // Usefull variables
-        InputStream in;
-        ObjectInputStream objIn;
-        int size;
-        int i;
-
-        // We load the variables
-        Properties variables = null;
-        in = InstallerBase.class.getResourceAsStream(&quot;/vars&quot;);
-        if (null != in)
-        {
-            objIn = new ObjectInputStream(in);
-            variables = (Properties) objIn.readObject();
-            objIn.close();
-        }
-
-        // We load the Info data
-        in = InstallerBase.class.getResourceAsStream(&quot;/info&quot;);
-        objIn = new ObjectInputStream(in);
-        Info inf = (Info) objIn.readObject();
-        objIn.close();
-
-        // We put the Info data as variables
-        installdata.setVariable(ScriptParser.APP_NAME, inf.getAppName());
-        if (inf.getAppURL() != null)
-            installdata.setVariable(ScriptParser.APP_URL, inf.getAppURL());
-        installdata.setVariable(ScriptParser.APP_VER, inf.getAppVersion());
-
-        // We read the panels order data
-        in = InstallerBase.class.getResourceAsStream(&quot;/panelsOrder&quot;);
-        objIn = new ObjectInputStream(in);
-        List panelsOrder = (List) objIn.readObject();
-        objIn.close();
-
-        // We read the packs data
-        in = InstallerBase.class.getResourceAsStream(&quot;/packs.info&quot;);
-        objIn = new ObjectInputStream(in);
-        size = objIn.readInt();
-        ArrayList availablePacks = new ArrayList();
-        ArrayList allPacks = new ArrayList();
-        for (i = 0; i &lt; size; i++)
-        {
-            Pack pk = (Pack) objIn.readObject();
-            allPacks.add(pk);
-            if (OsConstraint.oneMatchesCurrentSystem(pk.osConstraints)) availablePacks.add(pk);
-        }
-        objIn.close();
-
-        // We determine the operating system and the initial installation path
-        String dir;
-        String installPath;
-        if (OsVersion.IS_WINDOWS)
-        {
-            dir = buildWindowsDefaultPath();
-        }
-        else if (OsVersion.IS_OSX)
-        {
-            dir = &quot;/Applications&quot;;
-        }
-        else
-        {
-            if (new File(&quot;/usr/local/&quot;).canWrite())
-            {
-                dir = &quot;/usr/local&quot;;
-            }
-            else
-            {
-                dir = System.getProperty(&quot;user.home&quot;);
-            }
-        }
-        
-        // We determine the hostname and IPAdress
-        String hostname;
-        String IPAddress;
-        
-        try {
-            InetAddress addr = InetAddress.getLocalHost();
-    
-		        // Get IP Address
-		        IPAddress = addr.getHostAddress();
-		    
-		        // Get hostname
-		        hostname = addr.getHostName();
-        } catch (Exception e) {
-            hostname = &quot;&quot;;
-            IPAddress = &quot;&quot;;
-        }
-        
-				
-
-        installdata.setVariable(&quot;APPLICATIONS_DEFAULT_ROOT&quot;, dir);
-        dir += File.separator;
-        installdata.setVariable(ScriptParser.JAVA_HOME, System.getProperty(&quot;java.home&quot;));
-        installdata.setVariable(ScriptParser.CLASS_PATH, System.getProperty(&quot;java.class.path&quot;));
-        installdata.setVariable(ScriptParser.USER_HOME, System.getProperty(&quot;user.home&quot;));
-        installdata.setVariable(ScriptParser.USER_NAME, System.getProperty(&quot;user.name&quot;));
-        installdata.setVariable(ScriptParser.IP_ADDRESS, IPAddress);
-        installdata.setVariable(ScriptParser.HOST_NAME, hostname);
-        installdata.setVariable(ScriptParser.FILE_SEPARATOR, File.separator);
-
-        Enumeration e = System.getProperties().keys();
-        while (e.hasMoreElements())
-        {
-            String varName = (String) e.nextElement();
-            String varValue = System.getProperty(varName);
-            if (varValue != null)
-            {
-                varName = varName.replace('.', '_');
-                installdata.setVariable(&quot;SYSTEM_&quot; + varName, varValue);
-            }
-        }
-
-        if (null != variables)
-        {
-            Enumeration enumeration = variables.keys();
-            String varName;
-            String varValue;
-            while (enumeration.hasMoreElements())
-            {
-                varName = (String) enumeration.nextElement();
-                varValue = variables.getProperty(varName);
-                installdata.setVariable(varName, varValue);
-            }
-        }
-
-        installdata.info = inf;
-        installdata.panelsOrder = panelsOrder;
-        installdata.availablePacks = availablePacks;
-        installdata.allPacks = allPacks;
-
-        // get list of preselected packs
-        Iterator pack_it = availablePacks.iterator();
-        while (pack_it.hasNext())
-        {
-            Pack pack = (Pack) pack_it.next();
-            if (pack.preselected) installdata.selectedPacks.add(pack);
-        }
-        // Set the installation path in a default manner
-        installPath = dir + inf.getAppName();
-        if (inf.getInstallationSubPath() != null)
-        { // A subpath was defined, use it.
-            installPath = IoHelper.translatePath(dir + inf.getInstallationSubPath(),
-                    new VariableSubstitutor(installdata.getVariables()));
-        }
-        installdata.setInstallPath(installPath);
-        // Load custom action data.
-        loadCustomData(installdata);
-
-    }
-
-    /**
-     * Add the contents of a custom langpack (if exist) to the previos loaded comman langpack. If
-     * not exist, trace an info and do nothing more.
-     * 
-     * @param idata install data to be used
-     */
-    protected void addCustomLangpack(AutomatedInstallData idata)
-    {
-        // We try to load and add a custom langpack.
-        try
-        {
-            idata.langpack.add(ResourceManager.getInstance().getInputStream(LANG_FILE_NAME));
-        }
-        catch (Throwable exception)
-        {
-            Debug.trace(&quot;No custom langpack available.&quot;);
-            return;
-        }
-        Debug.trace(&quot;Custom langpack for &quot; + idata.localeISO3 + &quot; available.&quot;);
-    }
-
-    /**
-     * Get the default path for Windows (i.e Program Files/...).
-     * Windows has a Setting for this in the environment and in the registry.
-     * Just try to use the setting in the environment. If it fails for whatever reason, we take the former solution (buildWindowsDefaultPathFromProps).
-     * @return The Windows default installation path for applications.
-     */
-    private String buildWindowsDefaultPath()
-    {
-      try{
-        //get value from environment...
-        String prgFilesPath = IoHelper.getenv(&quot;ProgramFiles&quot;);
-        if (prgFilesPath!=null &amp;&amp; prgFilesPath.length()&gt;0){
-          return prgFilesPath;
-        }else{
-          return buildWindowsDefaultPathFromProps();
-        }
-      }catch(Exception x){
-        x.printStackTrace();
-        return buildWindowsDefaultPathFromProps();
-      }
-    }
-    /** 
-     * just plain wrong in case the programfiles are not stored where the developer expects them.
-     * E.g. in custom installations of large companies or if used internationalized version of windows with a language pack.
-     * @return
-     */
-    private String buildWindowsDefaultPathFromProps()
-    {
-        StringBuffer dpath = new StringBuffer(&quot;&quot;);
-        try
-        {
-            // We load the properties
-            Properties props = new Properties();
-            props
-                    .load(InstallerBase.class
-                            .getResourceAsStream(&quot;/com/izforge/izpack/installer/win32-defaultpaths.properties&quot;));
-
-            // We look for the drive mapping
-            String drive = System.getProperty(&quot;user.home&quot;);
-            if (drive.length() &gt; 3) drive = drive.substring(0, 3);
-
-            // Now we have it :-)
-            dpath.append(drive);
-
-            // Ensure that we have a trailing backslash (in case drive was
-            // something
-            // like &quot;C:&quot;)
-            if (drive.length() == 2) dpath.append(&quot;\\&quot;);
-
-            String language = Locale.getDefault().getLanguage();
-            String country = Locale.getDefault().getCountry();
-            String language_country = language + &quot;_&quot; + country;
-
-            // Try the most specific combination first
-            if (null != props.getProperty(language_country))
-            {
-                dpath.append(props.getProperty(language_country));
-            }
-            else if (null != props.getProperty(language))
-            {
-                dpath.append(props.getProperty(language));
-            }
-            else
-            {
-                dpath.append(props.getProperty(Locale.ENGLISH.getLanguage()));
-            }
-        }
-        catch (Exception err)
-        {
-            dpath = new StringBuffer(&quot;C:\\Program Files&quot;);
-        }
-
-        return dpath.toString();
-    }
-
-    /**
-     * Loads custom data like listener and lib references if exist and fills the installdata.
-     * 
-     * @param installdata installdata into which the custom action data should be stored
-     * @throws Exception
-     */
-    private void loadCustomData(AutomatedInstallData installdata) throws Exception
-    {
-        // Usefull variables
-        InputStream in;
-        ObjectInputStream objIn;
-        int i;
-        // Load listeners if exist.
-        String[] streamNames = AutomatedInstallData.CUSTOM_ACTION_TYPES;
-        List[] out = new List[streamNames.length];
-        for (i = 0; i &lt; streamNames.length; ++i)
-            out[i] = new ArrayList();
-        in = InstallerBase.class.getResourceAsStream(&quot;/customData&quot;);
-        if (in != null)
-        {
-            objIn = new ObjectInputStream(in);
-            Object listeners = objIn.readObject();
-            objIn.close();
-            Iterator keys = ((List) listeners).iterator();
-            while (keys != null &amp;&amp; keys.hasNext())
-            {
-                CustomData ca = (CustomData) keys.next();
-
-                if (ca.osConstraints != null
-                        &amp;&amp; !OsConstraint.oneMatchesCurrentSystem(ca.osConstraints))
-                { // OS constraint defined, but not matched; therefore ignore
-                    // it.
-                    continue;
-                }
-                switch (ca.type)
-                {
-                case CustomData.INSTALLER_LISTENER:
-                    Class clazz = Class.forName(ca.listenerName);
-                    if (clazz == null)
-                        throw new InstallerException(&quot;Custom action &quot; + ca.listenerName
-                                + &quot; not bound!&quot;);
-                    out[ca.type].add(clazz.newInstance());
-                    break;
-                case CustomData.UNINSTALLER_LISTENER:
-                case CustomData.UNINSTALLER_JAR:
-                    out[ca.type].add(ca);
-                    break;
-                case CustomData.UNINSTALLER_LIB:
-                    out[ca.type].add(ca.contents);
-                    break;
-                }
-
-            }
-            // Add the current custem action data to the installdata hash map.
-            for (i = 0; i &lt; streamNames.length; ++i)
-                installdata.customData.put(streamNames[i], out[i]);
-        }
-        // uninstallerLib list if exist
-
-    }
-}

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/InstallerBase.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/installer/InstallerBase.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/Unpacker.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/installer/Unpacker.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/Unpacker.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,560 +0,0 @@
-/*
- * $Id$
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Copyright 2001 Johannes Lehtinen
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *     
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.izforge.izpack.installer;
-
-import java.io.BufferedInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.lang.reflect.Constructor;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-
-import com.izforge.izpack.ExecutableFile;
-import com.izforge.izpack.Pack;
-import com.izforge.izpack.PackFile;
-import com.izforge.izpack.ParsableFile;
-import com.izforge.izpack.UpdateCheck;
-import com.izforge.izpack.event.InstallerListener;
-import com.izforge.izpack.util.AbstractUIHandler;
-import com.izforge.izpack.util.AbstractUIProgressHandler;
-import com.izforge.izpack.util.FileExecutor;
-import com.izforge.izpack.util.IoHelper;
-import com.izforge.izpack.util.OsConstraint;
-
-/**
- * Unpacker class.
- * 
- * @author Julien Ponge
- * @author Johannes Lehtinen
- */
-public class Unpacker extends UnpackerBase
-{      
-    private static final String tempPath = &quot;$INSTALL_PATH/Uninstaller/IzpackWebTemp&quot;;
-       
-    
-    /**
-     * The constructor.
-     * 
-     * @param idata The installation data.
-     * @param handler The installation progress handler.
-     */
-    public Unpacker(AutomatedInstallData idata, AbstractUIProgressHandler handler)
-    {
-        super(idata,handler);
-    }              
-
-    /* (non-Javadoc)
-     * @see com.izforge.izpack.installer.IUnpacker#run()
-     */
-    public void run()
-    {
-        addToInstances();
-        try
-        {
-            //
-            // Initialisations
-            FileOutputStream out = null;
-            ArrayList parsables = new ArrayList();
-            ArrayList executables = new ArrayList();
-            ArrayList updatechecks = new ArrayList();
-            List packs = idata.selectedPacks;
-            int npacks = packs.size();
-            handler.startAction(&quot;Unpacking&quot;, npacks);
-            udata = UninstallData.getInstance();
-            // Custom action listener stuff --- load listeners ----
-            List[] customActions = getCustomActions();
-            // Custom action listener stuff --- beforePacks ----
-            informListeners(customActions, InstallerListener.BEFORE_PACKS, idata, new Integer(
-                    npacks), handler);
-            packs = idata.selectedPacks;
-            npacks = packs.size();
-            
-            
-            // We unpack the selected packs
-            for (int i = 0; i &lt; npacks; i++)
-            {
-                // We get the pack stream
-                //int n = idata.allPacks.indexOf(packs.get(i));
-                Pack p = (Pack) packs.get(i);
-                
-                // evaluate condition
-                if (p.hasCondition()) {
-                    if (rules != null) {
-                        if (!rules.isConditionTrue(p.getCondition())) {
-                            // skip pack, condition is not fullfilled.
-                            continue;
-                        }
-                    }
-                    else {
-                        // TODO: skip pack, because condition can not be checked 
-                    }
-                }
-                
-                // Custom action listener stuff --- beforePack ----
-                informListeners(customActions, InstallerListener.BEFORE_PACK, packs.get(i),
-                        new Integer(npacks), handler);
-                ObjectInputStream objIn = new ObjectInputStream(getPackAsStream(p.id, p.uninstall));
-
-                // We unpack the files
-                int nfiles = objIn.readInt();
-
-                // We get the internationalized name of the pack
-                final Pack pack = ((Pack) packs.get(i));
-                String stepname = pack.name;// the message to be passed to the
-                // installpanel
-                if (langpack != null &amp;&amp; !(pack.id == null || &quot;&quot;.equals(pack.id)))
-                {
-
-                    final String name = langpack.getString(pack.id);
-                    if (name != null &amp;&amp; !&quot;&quot;.equals(name))
-                    {
-                        stepname = name;
-                    }
-                }
-                handler.nextStep(stepname, i + 1, nfiles);
-                for (int j = 0; j &lt; nfiles; j++)
-                {
-                    // We read the header
-                    PackFile pf = (PackFile) objIn.readObject();
-                    // TODO: reaction if condition can not be checked
-                    if (pf.hasCondition() &amp;&amp; (rules != null)) {
-                        if (!rules.isConditionTrue(pf.getCondition())) {
-                            // skip, condition is not fulfilled
-							objIn.skip(pf.length());
-                            continue;
-                        }
-                    }
-                    if (OsConstraint.oneMatchesCurrentSystem(pf.osConstraints()))
-                    {
-                        // We translate &amp; build the path
-                        String path = IoHelper.translatePath(pf.getTargetPath(), vs);
-                        File pathFile = new File(path);
-                        File dest = pathFile;
-                        if (!pf.isDirectory()) dest = pathFile.getParentFile();
-
-                        if (!dest.exists())
-                        {
-                            // If there are custom actions which would be called
-                            // at
-                            // creating a directory, create it recursively.
-                            List fileListeners = customActions[customActions.length - 1];
-                            if (fileListeners != null &amp;&amp; fileListeners.size() &gt; 0)
-                                mkDirsWithEnhancement(dest, pf, customActions);
-                            else
-                            // Create it in on step.
-                            {
-                                if (!dest.mkdirs())
-                                {
-                                    handler.emitError(&quot;Error creating directories&quot;,
-                                            &quot;Could not create directory\n&quot; + dest.getPath());
-                                    handler.stopAction();
-                                    this.result = false;
-                                    return;
-                                }
-                            }
-                        }
-
-                        if (pf.isDirectory()) continue;
-
-                        // Custom action listener stuff --- beforeFile ----
-                        informListeners(customActions, InstallerListener.BEFORE_FILE, pathFile, pf,
-                                null);
-                        // We add the path to the log,
-                        udata.addFile(path, pack.uninstall);
-
-                        handler.progress(j, path);
-
-                        // if this file exists and should not be overwritten,
-                        // check
-                        // what to do
-                        if ((pathFile.exists()) &amp;&amp; (pf.override() != PackFile.OVERRIDE_TRUE))
-                        {
-                            boolean overwritefile = false;
-
-                            // don't overwrite file if the user said so
-                            if (pf.override() != PackFile.OVERRIDE_FALSE)
-                            {
-                                if (pf.override() == PackFile.OVERRIDE_TRUE)
-                                {
-                                    overwritefile = true;
-                                }
-                                else if (pf.override() == PackFile.OVERRIDE_UPDATE)
-                                {
-                                    // check mtime of involved files
-                                    // (this is not 100% perfect, because the
-                                    // already existing file might
-                                    // still be modified but the new installed
-                                    // is just a bit newer; we would
-                                    // need the creation time of the existing
-                                    // file or record with which mtime
-                                    // it was installed...)
-                                    overwritefile = (pathFile.lastModified() &lt; pf.lastModified());
-                                }
-                                else
-                                {
-                                    int def_choice = -1;
-
-                                    if (pf.override() == PackFile.OVERRIDE_ASK_FALSE)
-                                        def_choice = AbstractUIHandler.ANSWER_NO;
-                                    if (pf.override() == PackFile.OVERRIDE_ASK_TRUE)
-                                        def_choice = AbstractUIHandler.ANSWER_YES;
-
-                                    int answer = handler.askQuestion(idata.langpack
-                                            .getString(&quot;InstallPanel.overwrite.title&quot;)
-                                            + &quot; - &quot; + pathFile.getName(), idata.langpack
-                                            .getString(&quot;InstallPanel.overwrite.question&quot;)
-                                            + pathFile.getAbsolutePath(),
-                                            AbstractUIHandler.CHOICES_YES_NO, def_choice);
-
-                                    overwritefile = (answer == AbstractUIHandler.ANSWER_YES);
-                                }
-
-                            }
-
-                            if (!overwritefile)
-                            {
-                                if (!pf.isBackReference() &amp;&amp; !((Pack) packs.get(i)).loose)
-                                    objIn.skip(pf.length());
-                                continue;
-                            }
-
-                        }
-
-                        // We copy the file
-                        InputStream pis = objIn;
-                        if (pf.isBackReference())
-                        {
-                            InputStream is = getPackAsStream(pf.previousPackId, pack.uninstall);
-                            pis = new ObjectInputStream(is);
-                            // must wrap for blockdata use by objectstream
-                            // (otherwise strange result)
-                            // skip on underlaying stream (for some reason not
-                            // possible on ObjectStream)
-                            is.skip(pf.offsetInPreviousPack - 4);
-                            // but the stream header is now already read (== 4
-                            // bytes)
-                        }
-                        else if (((Pack) packs.get(i)).loose)
-                        {                            
-                            /* Old way of doing the job by using the (absolute) sourcepath.
-                             * Since this is very likely to fail and does not confirm to the documentation,
-                             * prefer using relative path's
-                            pis = new FileInputStream(pf.sourcePath);
-                             */
-                            
-                            //take the relative path and search for the file
-                            //1. look at the location where the &quot;info&quot;-file is loaded from (jar)
-                            //2. look into the current working directory
-                            //maybe look into other other locations after that (configurable ?)
-
-                            //find directory of jar file
-                            URL url = getClass().getResource(&quot;/info&quot;);
-                            String urlPath = url.getPath();
-                            int pos = urlPath.indexOf('!');
-                            if (pos&gt;=0 &amp;&amp; urlPath.startsWith(&quot;file:/&quot;)){
-                                //remove jar-specific part
-                                urlPath = urlPath.substring(&quot;file:/&quot;.length(), pos);
-                            }
-                            File installerDir = new File(urlPath);
-                            if (!installerDir.isDirectory())
-                            {
-                                installerDir = installerDir.getParentFile();
-                            }
-
-                            File resolvedFile = new File(installerDir, pf.getRelativeSourcePath());
-                            if (!resolvedFile.exists()){
-                                //try alternative destination - the current working directory
-                                //user.dir is likely (depends on launcher type) the current directory of the executable or jar-file...
-                                final File userDir = new File(System.getProperty(&quot;user.dir&quot;));
-                                resolvedFile = new File(userDir, pf.getRelativeSourcePath());
-                            }
-                            if (resolvedFile.exists()){
-                                pis = new FileInputStream(resolvedFile);
-                                //may have a different length &amp; last modified than we had at compiletime, therefore we have to build a new PackFile for the copy process...
-                                pf = new PackFile(resolvedFile.getParentFile(), resolvedFile,  pf.getTargetPath(), pf.osConstraints(), pf.override(), pf.getAdditionals());
-                            }else{
-                                //file not found
-                                //issue a warning (logging api pending)
-                                //since this file was loosely bundled, we continue with the installation.
-                                System.out.println(&quot;Could not find loosely bundled file: &quot;+pf.getRelativeSourcePath());
-                                out.close();
-                                continue;
-                            }
-                        }
-
-                        out = new FileOutputStream(pathFile);
-                        byte[] buffer = new byte[5120];
-                        long bytesCopied = 0;
-                        while (bytesCopied &lt; pf.length())
-                        {
-                            if (performInterrupted())
-                            { // Interrupt was initiated; perform it.
-                                out.close();
-                                if (pis != objIn) pis.close();
-                                return;
-                            }
-                            int maxBytes = (int) Math.min(pf.length() - bytesCopied, buffer.length);
-                            int bytesInBuffer = pis.read(buffer, 0, maxBytes);
-                            if (bytesInBuffer == -1)
-                                throw new IOException(&quot;Unexpected end of stream (installer corrupted?)&quot;);
-
-                            out.write(buffer, 0, bytesInBuffer);
-
-                            bytesCopied += bytesInBuffer;
-                        }
-                        // Cleanings
-                        out.close();
-                        if (pis != objIn) pis.close();
-
-                        // Set file modification time if specified
-                        if (pf.lastModified() &gt;= 0) pathFile.setLastModified(pf.lastModified());
-                        // Custom action listener stuff --- afterFile ----
-                        informListeners(customActions, InstallerListener.AFTER_FILE, pathFile, pf,
-                                null);
-
-                    }
-                    else
-                    {
-                        if (!pf.isBackReference()) objIn.skip(pf.length());
-                    }
-                }
-
-                // Load information about parsable files
-                int numParsables = objIn.readInt();
-                for (int k = 0; k &lt; numParsables; k++)
-                {
-                    ParsableFile pf = (ParsableFile) objIn.readObject();
-                    if (pf.hasCondition() &amp;&amp; (rules != null)) {
-                        if (!rules.isConditionTrue(pf.getCondition())) {
-                            // skip, condition is not fulfilled
-                            continue;
-                        }
-                    }
-                    pf.path = IoHelper.translatePath(pf.path, vs);
-                    parsables.add(pf);
-                }
-
-                // Load information about executable files
-                int numExecutables = objIn.readInt();
-                for (int k = 0; k &lt; numExecutables; k++)
-                {
-                    ExecutableFile ef = (ExecutableFile) objIn.readObject();
-                    if (ef.hasCondition() &amp;&amp; (rules != null)) {
-                        if (!rules.isConditionTrue(ef.getCondition())) {
-                            // skip, condition is false
-                            continue;
-                        }
-                    }
-                    ef.path = IoHelper.translatePath(ef.path, vs);
-                    if (null != ef.argList &amp;&amp; !ef.argList.isEmpty())
-                    {
-                        String arg = null;
-                        for (int j = 0; j &lt; ef.argList.size(); j++)
-                        {
-                            arg = (String) ef.argList.get(j);
-                            arg = IoHelper.translatePath(arg, vs);
-                            ef.argList.set(j, arg);
-                        }
-                    }
-                    executables.add(ef);
-                    if (ef.executionStage == ExecutableFile.UNINSTALL)
-                    {
-                        udata.addExecutable(ef);
-                    }
-                }
-                // Custom action listener stuff --- uninstall data ----
-                handleAdditionalUninstallData(udata, customActions);
-
-                // Load information about updatechecks
-                int numUpdateChecks = objIn.readInt();
-
-                for (int k = 0; k &lt; numUpdateChecks; k++)
-                {
-                    UpdateCheck uc = (UpdateCheck) objIn.readObject();
-
-                    updatechecks.add(uc);
-                }
-
-                objIn.close();
-
-                if (performInterrupted())
-                { // Interrupt was initiated; perform it.
-                    return;
-                }
-
-                // Custom action listener stuff --- afterPack ----
-                informListeners(customActions, InstallerListener.AFTER_PACK, packs.get(i),
-                        new Integer(i), handler);
-            }
-
-            // We use the scripts parser
-            ScriptParser parser = new ScriptParser(parsables, vs);
-            parser.parseFiles();
-            if (performInterrupted())
-            { // Interrupt was initiated; perform it.
-                return;
-            }
-
-            // We use the file executor
-            FileExecutor executor = new FileExecutor(executables);
-            if (executor.executeFiles(ExecutableFile.POSTINSTALL, handler) != 0)
-            {
-                handler.emitError(&quot;File execution failed&quot;, &quot;The installation was not completed&quot;);
-                this.result = false;
-            }
-
-            if (performInterrupted())
-            { // Interrupt was initiated; perform it.
-                return;
-            }
-
-            // We put the uninstaller (it's not yet complete...)
-            putUninstaller();
-
-            // update checks _after_ uninstaller was put, so we don't delete it
-            performUpdateChecks(updatechecks);
-
-            if (performInterrupted())
-            { // Interrupt was initiated; perform it.
-                return;
-            }
-
-            // Custom action listener stuff --- afterPacks ----
-            informListeners(customActions, InstallerListener.AFTER_PACKS, idata, handler, null);
-            if (performInterrupted())
-            { // Interrupt was initiated; perform it.
-                return;
-            }
-
-            // write installation information
-            writeInstallationInformation();
-            
-            // The end :-)
-            handler.stopAction();
-        }
-        catch (Exception err)
-        {
-            // TODO: finer grained error handling with useful error messages
-            handler.stopAction(); 
-            if(&quot;Installation cancelled&quot;.equals(err.getMessage()))
-            {
-                handler.emitNotification(&quot;Installation cancelled&quot;);
-            }
-            else
-            {
-                handler.emitError(&quot;An error occured&quot;, err.getMessage());
-                err.printStackTrace();
-            }
-            this.result = false;
-            System.exit(4);
-        }
-        finally
-        {
-            removeFromInstances();
-        }
-    }
-
-    /**
-     * Returns a stream to a pack, location depending on if it's web based.
-     * 
-     * @param n The pack number.
-     * @param uninstall true if pack must be uninstalled
-     * @return The stream or null if it could not be found.
-     * @exception Exception Description of the Exception
-     */
-    private InputStream getPackAsStream(String packid, boolean uninstall) throws Exception
-    {
-        InputStream in = null;
-
-        String webDirURL = idata.info.getWebDirURL();
-
-        packid = &quot;-&quot; + packid;
-        
-        if (webDirURL == null) // local
-        {
-            in = Unpacker.class.getResourceAsStream(&quot;/packs/pack&quot; + packid);
-        }
-        else
-        // web based
-        {
-            // TODO: Look first in same directory as primary jar
-            // This may include prompting for changing of media
-            // TODO: download and cache them all before starting copy process
-
-            // See compiler.Packager#getJarOutputStream for the counterpart
-            String baseName = idata.info.getInstallerBase();
-            String packURL = webDirURL + &quot;/&quot; + baseName + &quot;.pack&quot; + packid + &quot;.jar&quot;;
-            String tf = IoHelper.translatePath(Unpacker.tempPath, vs);
-            String tempfile;
-            try
-            {
-               tempfile = WebRepositoryAccessor.getCachedUrl(packURL, tf);
-               udata.addFile(tempfile, uninstall);
-            }
-            catch(Exception e)
-            {
-               if(&quot;Cancelled&quot;.equals(e.getMessage()))
-                  throw new InstallerException(&quot;Installation cancelled&quot;, e);
-               else
-                  throw new InstallerException(&quot;Installation failed&quot;, e);
-            }
-            URL url = new URL(&quot;jar:&quot; + tempfile + &quot;!/packs/pack&quot; + packid);
-
-            //URL url = new URL(&quot;jar:&quot; + packURL + &quot;!/packs/pack&quot; + packid);
-            // JarURLConnection jarConnection = (JarURLConnection)
-            // url.openConnection();
-            // TODO: what happens when using an automated installer?
-            in = new WebAccessor(null).openInputStream(url);
-            // TODO: Fails miserably when pack jars are not found, so this is
-            // temporary
-            if (in == null) throw new InstallerException(url.toString() + &quot; not available&quot;, new FileNotFoundException(url.toString()));
-        }
-        if( in != null &amp;&amp; idata.info.getPackDecoderClassName() != null )
-        {
-            Class decoder = Class.forName(idata.info.getPackDecoderClassName());
-            Class[] paramsClasses = new Class[1];
-            paramsClasses[0] = Class.forName(&quot;java.io.InputStream&quot;);
-            Constructor constructor = decoder.getDeclaredConstructor(paramsClasses);
-            // Our first used decoder input stream (bzip2) reads byte for byte from
-            // the source. Therefore we put a buffering stream between it and the
-            // source.
-            InputStream buffer = new BufferedInputStream(in);
-            Object[] params = { buffer };
-            Object instance = null;
-            instance = constructor.newInstance( params);
-            if (!InputStream.class.isInstance(instance))
-                throw new InstallerException(  &quot;'&quot; + idata.info.getPackDecoderClassName()
-                        + &quot;' must be derived from &quot;
-                        + InputStream.class.toString());
-            in = (InputStream) instance;
-
-        }
-        return in;
-    }   
-}

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/Unpacker.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/installer/Unpacker.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/UnpackerFactory.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/installer/UnpackerFactory.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/UnpackerFactory.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,66 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Copyright 2007 Dennis Reil
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *     
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.izforge.izpack.installer;
-
-import java.lang.reflect.Constructor;
-
-import com.izforge.izpack.util.AbstractUIProgressHandler;
-import com.izforge.izpack.util.Debug;
-
-
-/**
- * A Factory for getting unpacker instances. 
- * 
- * @author Dennis Reil, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">Dennis.Reil at reddot.de</A>&gt;
- */
-public abstract class UnpackerFactory
-{
-    /**
-     * Returns an instance of the desired unpacker class
-     * @param unpackerclassname
-     * @param installdata
-     * @param listener
-     * @return
-     */
-    public static IUnpacker getUnpacker(String unpackerclassname, AutomatedInstallData installdata, AbstractUIProgressHandler listener){
-        IUnpacker unpackerobj = null;
-        try
-        {
-            Class unpackerclass = Class.forName(unpackerclassname);
-            Class[] parametertypes = {AutomatedInstallData.class, AbstractUIProgressHandler.class};
-            Constructor unpackerconstructor = unpackerclass.getConstructor(parametertypes);
-            Object[] parameter = {installdata,listener};
-            unpackerobj = (IUnpacker) unpackerconstructor.newInstance(parameter);            
-        }        
-        catch (NoSuchMethodException e)
-        {
-            Debug.trace(&quot;Can't load unpacker: &quot; + unpackerclassname);
-            Debug.trace(&quot;Unpacker doesn't implement the desired method&quot;);
-            Debug.trace(e);
-        }
-        catch (Exception e)
-        {
-            Debug.trace(&quot;Can't load unpacker: &quot; + unpackerclassname);
-            Debug.trace(e);
-        }                
-        return unpackerobj;
-    }
-}

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/UnpackerFactory.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/installer/UnpackerFactory.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/WebRepositoryAccessor.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/installer/WebRepositoryAccessor.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/WebRepositoryAccessor.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,616 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- *
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- *
- * Copyright 2007 Vladimir Ralev
- *
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.izforge.izpack.installer;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.*;
-import java.io.*;
-import com.izforge.izpack.compiler.*;
-import com.izforge.izpack.*;
-import com.izforge.izpack.util.*;
-
-import com.izforge.izpack.compiler.CompilerException;
-
-import net.n3.nanoxml.*;
-
-/**
- * 
- * This class enumerates the availabe packs at the web repository. Parses the config files
- *  - install.xml, packsinfo.xml, langpacks and is used to override the static configuration
- *  in the installer jar.
- * 
- * @author &lt;a href=&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">vralev at redhat.com</A>&quot;&gt;Vladimir Ralev&lt;/a&gt;
- * @version $Revision: 1.1 $
- */
-public class WebRepositoryAccessor
-{
-   /** URL to remote install.xml */
-   private String installXmlUrl;
-
-   /** Base repository URL */
-   private String baseUrl;
-
-   /** install.xml */
-   private String installXmlString;
-
-   /** packsinfo.xml contains nbytes, pack name and pack id */
-   private String packsInfo;
-
-   /** list of PackInfo entries */
-   private ArrayList packs;
-
-   /** Constant for checking attributes. */
-   private static boolean YES = true;
-
-   /** Constant for checking attributes. */
-   private static boolean NO = false;
-
-   /** Files to be looked for at the repository base url */
-   private static final String installFilename = &quot;install.xml&quot;;
-
-   private static final String packsinfoFilename = &quot;packsinfo.xml&quot;;
-
-   /** Files being downloaded in the buffer, 1MB max */
-   private static final int BUFFER_SIZE = 1000000;
-   
-
-   /**
-    * 
-    * Create a new WebRepositoryAccessor.
-    * 
-    * @param urlbase
-    */
-   public WebRepositoryAccessor(String urlbase)
-   {
-      this.installXmlUrl = urlbase + &quot;/&quot; + installFilename;
-      this.baseUrl = urlbase;
-   }
-
-   /**
-    * Get the list of the packs from the remore install.xml
-    * 
-    * @return
-    */
-   public ArrayList getOnlinePacks()
-   {
-      readConfig();
-      packs = parsePacks();
-      readPacksInfo();
-      parsePacksInfo();
-      return packs;
-   }
-
-   /**
-    * Returns the contents of a file at url as a string (must be a text file)
-    * 
-    * @param url
-    * @return
-    */
-   private String stringFromURL(String url)
-   {
-      int max = BUFFER_SIZE;
-      byte[] raw = new byte[max];
-      InputStream in = null;
-      try
-      {
-         WebAccessor w = new WebAccessor(null);
-         in = w.openInputStream(new URL(url));
-         if (in == null)
-            throw new RuntimeException(&quot;Unable to open network stream&quot;);
-         int r = in.read(raw);
-         int off = r;
-         while (r &gt; 0)
-         {
-            r = in.read(raw, off, max - off);
-            off += r;
-         }
-         return new String(raw);
-      }
-      catch (Exception e)
-      {
-         System.out.println(e + &quot; while trying to download &quot; + url);
-         return null;
-      }
-      finally
-      {
-         try
-         {
-            if(in != null) in.close();
-         }
-         catch(Exception e){}
-      }
-   }
-
-   /**
-    * Reads the install.xml into confgiString
-    *
-    */
-   private void readConfig()
-   {
-      installXmlString = stringFromURL(installXmlUrl);
-   }
-
-   
-   /**
-    * Reads packsinfo.xml
-    *
-    */
-   private void readPacksInfo()
-   {
-      String url = this.baseUrl + &quot;/&quot; + packsinfoFilename;
-      packsInfo = stringFromURL(url);
-   }
-
-   /**
-    * Parse install.xml and return the list of packs
-    * 
-    * @return
-    */
-   private ArrayList parsePacks()
-   {
-      try
-      {
-         IXMLParser parser = XMLParserFactory.createDefaultXMLParser();
-         IXMLReader reader = StdXMLReader.stringReader(installXmlString);
-         parser.setReader(reader);
-         XMLElement xml = (XMLElement) parser.parse();
-         return loadPacksList(xml);
-      }
-      catch (Exception e)
-      {
-         System.out.println(&quot;WARN: Unable to parse install.xml&quot;);
-         return null;
-      }
-   }
-
-   /**
-    * Parse packsinfo.xml, fill the nbytes field, which is not available at runtime
-    * otherwise.
-    *
-    */
-   private void parsePacksInfo()
-   {
-      try
-      {
-         IXMLParser parser = XMLParserFactory.createDefaultXMLParser();
-         IXMLReader reader = StdXMLReader.stringReader(packsInfo);
-         parser.setReader(reader);
-         XMLElement xml = (XMLElement) parser.parse();
-         XMLElement root = xml; //requireChildNamed(xml, &quot;packs&quot;);
-         for (int q = 0; q &lt; root.getChildrenCount(); q++)
-         {
-            XMLElement ch = root.getChildAtIndex(q);
-            PackInfo pi = (PackInfo) packs.get(q);
-            Pack p = pi.getPack();
-            p.nbytes = Long.parseLong(ch.getAttribute(&quot;nbytes&quot;));
-         }
-      }
-      catch (Exception e)
-      {
-         System.out.println(&quot;WARN: Unable to parse packsinfo.xml&quot;);
-      }
-   }
-
-   /**
-    * First download the jar file. The create the input stream from the
-    * downloaded file. This is because the Jar connection's openInputStream
-    * will blocks until the whole jar in order to unzip it (there is no way
-    * to see the download progress there).
-    * 
-    * @param url
-    * @return
-    */
-   public static String getCachedUrl(String url, String tempFolder) throws Exception
-   {
-      int max = BUFFER_SIZE;
-      byte[] raw = new byte[max];
-      try
-      {
-         WebAccessor w = new WebAccessor(null);
-         InputStream in = w.openInputStream(new URL(url));
-         int r = in.read(raw);
-         File tempDir = new File(tempFolder);
-
-         tempDir.mkdirs();
-
-         File temp = File.createTempFile(&quot;izpacktempfile&quot;, &quot;jar&quot;, new File(tempFolder));
-         FileOutputStream fos = new FileOutputStream(temp);
-         String path = &quot;<A HREF="file:///&quot;">file:///&quot;</A> + temp.getAbsolutePath();
-         while (r &gt; 0)
-         {
-            fos.write(raw, 0, r);
-            r = in.read(raw);
-         }
-         in.close();
-         fos.close();
-
-         return path;
-      }
-      catch (SecurityException e)
-      {
-         System.out.println(e + &quot; while trying to write temp file: &quot; + tempFolder);
-         throw e;
-      }
-      catch (Exception e)
-      {
-         System.out.println(e + &quot; while trying to download &quot; + url);
-         throw e;
-      }
-   }
-
-   
-   protected ArrayList loadPacksList(XMLElement data) throws CompilerException
-   {
-      ArrayList result = new ArrayList();
-
-      // Initialisation
-      XMLElement root = requireChildNamed(data, &quot;packs&quot;);
-
-      // at least one pack is required
-      Vector packElements = root.getChildrenNamed(&quot;pack&quot;);
-      if (packElements.isEmpty())
-         parseError(root, &quot;&lt;packs&gt; requires a &lt;pack&gt;&quot;);
-
-      Iterator packIter = packElements.iterator();
-      while (packIter.hasNext())
-      {
-         XMLElement el = (XMLElement) packIter.next();
-
-         // Trivial initialisations
-         String name = requireAttribute(el, &quot;name&quot;);
-         String id = el.getAttribute(&quot;id&quot;);
-
-         boolean loose = &quot;true&quot;.equalsIgnoreCase(el.getAttribute(&quot;loose&quot;, &quot;false&quot;));
-         String description = requireChildNamed(el, &quot;description&quot;).getContent();
-         boolean required = requireYesNoAttribute(el, &quot;required&quot;);
-         String group = el.getAttribute(&quot;group&quot;);
-         String installGroups = el.getAttribute(&quot;installGroups&quot;);
-         String excludeGroup = el.getAttribute(&quot;excludeGroup&quot;);
-				 boolean uninstall = &quot;yes&quot;.equalsIgnoreCase(el.getAttribute(&quot;uninstall&quot;, &quot;yes&quot;));
-         String parent = el.getAttribute(&quot;parent&quot;);
-
-         if (required &amp;&amp; excludeGroup != null)
-         {
-            parseError(el, &quot;Pack, which has excludeGroup can not be required.&quot;, new Exception(
-                  &quot;Pack, which has excludeGroup can not be required.&quot;));
-         }
-
-				 PackInfo pack = new PackInfo(name, id, description, required, loose, excludeGroup, uninstall);
-         pack.setOsConstraints(OsConstraint.getOsList(el)); // TODO:
-         pack.setParent(parent);
-
-         // unverified
-         // if the pack belongs to an excludeGroup it's not preselected by default
-         if (excludeGroup == null)
-            pack.setPreselected(validateYesNoAttribute(el, &quot;preselected&quot;, YES));
-         else
-            pack.setPreselected(validateYesNoAttribute(el, &quot;preselected&quot;, NO));
-
-         // Set the pack group if specified
-         if (group != null)
-            pack.setGroup(group);
-         // Set the pack install groups if specified
-         if (installGroups != null)
-         {
-            StringTokenizer st = new StringTokenizer(installGroups, &quot;,&quot;);
-            while (st.hasMoreTokens())
-            {
-               String igroup = st.nextToken();
-               pack.addInstallGroup(igroup);
-            }
-         }
-
-         // We get the parsables list
-         Iterator iter = el.getChildrenNamed(&quot;parsable&quot;).iterator();
-         while (iter.hasNext())
-         {
-            XMLElement p = (XMLElement) iter.next();
-            String target = requireAttribute(p, &quot;targetfile&quot;);
-            String type = p.getAttribute(&quot;type&quot;, &quot;plain&quot;);
-            String encoding = p.getAttribute(&quot;encoding&quot;, null);
-            List osList = OsConstraint.getOsList(p); // TODO: unverified
-
-            pack.addParsable(new ParsableFile(target, type, encoding, osList));
-         }
-
-         // We get the executables list
-         iter = el.getChildrenNamed(&quot;executable&quot;).iterator();
-         while (iter.hasNext())
-         {
-            XMLElement e = (XMLElement) iter.next();
-            ExecutableFile executable = new ExecutableFile();
-            String val; // temp value
-
-            executable.path = requireAttribute(e, &quot;targetfile&quot;);
-
-            // when to execute this executable
-            val = e.getAttribute(&quot;stage&quot;, &quot;never&quot;);
-            if (&quot;postinstall&quot;.equalsIgnoreCase(val))
-               executable.executionStage = ExecutableFile.POSTINSTALL;
-            else if (&quot;uninstall&quot;.equalsIgnoreCase(val))
-               executable.executionStage = ExecutableFile.UNINSTALL;
-
-            // type of this executable
-            val = e.getAttribute(&quot;type&quot;, &quot;bin&quot;);
-            if (&quot;jar&quot;.equalsIgnoreCase(val))
-            {
-               executable.type = ExecutableFile.JAR;
-               executable.mainClass = e.getAttribute(&quot;class&quot;); // executable
-               // class
-            }
-
-            // what to do if execution fails
-            val = e.getAttribute(&quot;failure&quot;, &quot;ask&quot;);
-            if (&quot;abort&quot;.equalsIgnoreCase(val))
-               executable.onFailure = ExecutableFile.ABORT;
-            else if (&quot;warn&quot;.equalsIgnoreCase(val))
-               executable.onFailure = ExecutableFile.WARN;
-
-            // whether to keep the executable after executing it
-            val = e.getAttribute(&quot;keep&quot;);
-            executable.keepFile = &quot;true&quot;.equalsIgnoreCase(val);
-
-            // get arguments for this executable
-            XMLElement args = e.getFirstChildNamed(&quot;args&quot;);
-            if (null != args)
-            {
-               Iterator argIterator = args.getChildrenNamed(&quot;arg&quot;).iterator();
-               while (argIterator.hasNext())
-               {
-                  XMLElement arg = (XMLElement) argIterator.next();
-                  executable.argList.add(requireAttribute(arg, &quot;value&quot;));
-               }
-            }
-
-            executable.osList = OsConstraint.getOsList(e); // TODO:
-            // unverified
-
-            pack.addExecutable(executable);
-         }
-
-         // get the updatechecks list
-         iter = el.getChildrenNamed(&quot;updatecheck&quot;).iterator();
-         while (iter.hasNext())
-         {
-            XMLElement f = (XMLElement) iter.next();
-
-            String casesensitive = f.getAttribute(&quot;casesensitive&quot;);
-
-            // get includes and excludes
-            ArrayList includesList = new ArrayList();
-            ArrayList excludesList = new ArrayList();
-
-            // get includes and excludes
-            Iterator include_it = f.getChildrenNamed(&quot;include&quot;).iterator();
-            while (include_it.hasNext())
-            {
-               XMLElement inc_el = (XMLElement) include_it.next();
-               includesList.add(requireAttribute(inc_el, &quot;name&quot;));
-            }
-
-            Iterator exclude_it = f.getChildrenNamed(&quot;exclude&quot;).iterator();
-            while (exclude_it.hasNext())
-            {
-               XMLElement excl_el = (XMLElement) exclude_it.next();
-               excludesList.add(requireAttribute(excl_el, &quot;name&quot;));
-            }
-
-            pack.addUpdateCheck(new UpdateCheck(includesList, excludesList, casesensitive));
-         }
-         // We get the dependencies
-         iter = el.getChildrenNamed(&quot;depends&quot;).iterator();
-         while (iter.hasNext())
-         {
-            XMLElement dep = (XMLElement) iter.next();
-            String depName = requireAttribute(dep, &quot;packname&quot;);
-            pack.addDependency(depName);
-
-         }
-         result.add(pack);
-      }
-      return result;
-   }
-
-   /**
-    * Create parse error with consistent messages. Includes file name. For use When parent is
-    * unknown.
-    * 
-    * @param message Brief message explaining error
-    */
-   protected void parseError(String message) throws CompilerException
-   {
-      throw new CompilerException(installFilename + &quot;:&quot; + message);
-   }
-
-   /**
-    * Create parse error with consistent messages. Includes file name and line # of parent. It is
-    * an error for 'parent' to be null.
-    * 
-    * @param parent The element in which the error occured
-    * @param message Brief message explaining error
-    */
-   protected void parseError(XMLElement parent, String message) throws CompilerException
-   {
-      throw new CompilerException(installFilename + &quot;:&quot; + parent.getLineNr() + &quot;: &quot; + message);
-   }
-
-   /**
-    * Create a chained parse error with consistent messages. Includes file name and line # of
-    * parent. It is an error for 'parent' to be null.
-    * 
-    * @param parent The element in which the error occured
-    * @param message Brief message explaining error
-    */
-   protected void parseError(XMLElement parent, String message, Throwable cause) throws CompilerException
-   {
-      throw new CompilerException(installFilename + &quot;:&quot; + parent.getLineNr() + &quot;: &quot; + message, cause);
-   }
-
-   /**
-    * Create a parse warning with consistent messages. Includes file name and line # of parent. It
-    * is an error for 'parent' to be null.
-    * 
-    * @param parent The element in which the warning occured
-    * @param message Warning message
-    */
-   protected void parseWarn(XMLElement parent, String message)
-   {
-      System.out.println(installFilename + &quot;:&quot; + parent.getLineNr() + &quot;: &quot; + message);
-   }
-
-   /**
-    * Call getFirstChildNamed on the parent, producing a meaningful error message on failure. It is
-    * an error for 'parent' to be null.
-    * 
-    * @param parent The element to search for a child
-    * @param name Name of the child element to get
-    */
-   protected XMLElement requireChildNamed(XMLElement parent, String name) throws CompilerException
-   {
-      XMLElement child = parent.getFirstChildNamed(name);
-      if (child == null)
-         parseError(parent, &quot;&lt;&quot; + parent.getName() + &quot;&gt; requires child &lt;&quot; + name + &quot;&gt;&quot;);
-      return child;
-   }
-
-   /**
-    * Call getContent on an element, producing a meaningful error message if not present, or empty,
-    * or a valid URL. It is an error for 'element' to be null.
-    * 
-    * @param element The element to get content of
-    */
-   protected URL requireURLContent(XMLElement element) throws CompilerException
-   {
-      URL url = null;
-      try
-      {
-         url = new URL(requireContent(element));
-      }
-      catch (MalformedURLException x)
-      {
-         parseError(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; requires valid URL&quot;, x);
-      }
-      return url;
-   }
-
-   /**
-    * Call getContent on an element, producing a meaningful error message if not present, or empty.
-    * It is an error for 'element' to be null.
-    * 
-    * @param element The element to get content of
-    */
-   protected String requireContent(XMLElement element) throws CompilerException
-   {
-      String content = element.getContent();
-      if (content == null || content.length() == 0)
-         parseError(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; requires content&quot;);
-      return content;
-   }
-
-   /**
-    * Call getAttribute on an element, producing a meaningful error message if not present, or
-    * empty. It is an error for 'element' or 'attribute' to be null.
-    * 
-    * @param element The element to get the attribute value of
-    * @param attribute The name of the attribute to get
-    */
-   protected String requireAttribute(XMLElement element, String attribute) throws CompilerException
-   {
-      String value = element.getAttribute(attribute);
-      if (value == null)
-         parseError(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; requires attribute '&quot; + attribute + &quot;'&quot;);
-      return value;
-   }
-
-   /**
-    * Get a required attribute of an element, ensuring it is an integer. A meaningful error message
-    * is generated as a CompilerException if not present or parseable as an int. It is an error for
-    * 'element' or 'attribute' to be null.
-    * 
-    * @param element The element to get the attribute value of
-    * @param attribute The name of the attribute to get
-    */
-   protected int requireIntAttribute(XMLElement element, String attribute) throws CompilerException
-   {
-      String value = element.getAttribute(attribute);
-      if (value == null || value.length() == 0)
-         parseError(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; requires attribute '&quot; + attribute + &quot;'&quot;);
-      try
-      {
-         return Integer.parseInt(value);
-      }
-      catch (NumberFormatException x)
-      {
-         parseError(element, &quot;'&quot; + attribute + &quot;' must be an integer&quot;);
-      }
-      return 0; // never happens
-   }
-
-   /**
-    * Call getAttribute on an element, producing a meaningful error message if not present, or one
-    * of &quot;yes&quot; or &quot;no&quot;. It is an error for 'element' or 'attribute' to be null.
-    * 
-    * @param element The element to get the attribute value of
-    * @param attribute The name of the attribute to get
-    */
-   protected boolean requireYesNoAttribute(XMLElement element, String attribute) throws CompilerException
-   {
-      String value = requireAttribute(element, attribute);
-      if (&quot;yes&quot;.equalsIgnoreCase(value))
-         return true;
-      if (&quot;no&quot;.equalsIgnoreCase(value))
-         return false;
-
-      parseError(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; invalid attribute '&quot; + attribute + &quot;': Expected (yes|no)&quot;);
-
-      return false; // never happens
-   }
-
-   /**
-    * Call getAttribute on an element, producing a meaningful warning if not &quot;yes&quot; or &quot;no&quot;. If the
-    * 'element' or 'attribute' are null, the default value is returned.
-    * 
-    * @param element The element to get the attribute value of
-    * @param attribute The name of the attribute to get
-    * @param defaultValue Value returned if attribute not present or invalid
-    */
-   protected boolean validateYesNoAttribute(XMLElement element, String attribute, boolean defaultValue)
-   {
-      if (element == null)
-         return defaultValue;
-
-      String value = element.getAttribute(attribute, (defaultValue ? &quot;yes&quot; : &quot;no&quot;));
-      if (&quot;yes&quot;.equalsIgnoreCase(value))
-         return true;
-      if (&quot;no&quot;.equalsIgnoreCase(value))
-         return false;
-
-      // TODO: should this be an error if it's present but &quot;none of the
-      // above&quot;?
-      parseWarn(element, &quot;&lt;&quot; + element.getName() + &quot;&gt; invalid attribute '&quot; + attribute
-            + &quot;': Expected (yes|no) if present&quot;);
-
-      return defaultValue;
-   }
-
-}
\ No newline at end of file

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/installer/WebRepositoryAccessor.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/installer/WebRepositoryAccessor.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/io/FileSpanningInputStream.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/io/FileSpanningInputStream.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/io/FileSpanningInputStream.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,364 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A> <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Copyright 2007 Dennis Reil
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- * 
- * <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-package com.izforge.izpack.io;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.zip.GZIPInputStream;
-
-import com.izforge.izpack.util.Debug;
-
-/**
- * An inputstream which transparently spans over multiple volumes. The amount of volumes has to be
- * specified
- * 
- * @author Dennis Reil, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">Dennis.Reil at reddot.de</A>&gt;
- */
-public class FileSpanningInputStream extends InputStream
-{
-
-    private static final int EOF = -1;
-
-    protected FileInputStream fileinputstream;
-
-    protected String volumename;
-
-    protected int currentvolumeindex;
-
-    protected int volumestotal;
-
-    protected static boolean nextvolumenotfound = false;
-
-    protected long filepointer;
-
-    protected GZIPInputStream zippedinputstream;
-
-    protected byte[] magicnumber;
-
-    public FileSpanningInputStream(File volume, int volumestotal) throws IOException
-    {
-        fileinputstream = new FileInputStream(volume);
-        zippedinputstream = new GZIPInputStream(fileinputstream);
-        currentvolumeindex = 0;
-        volumename = volume.getAbsolutePath();
-        this.volumestotal = volumestotal;
-        filepointer = 0;
-
-        // read magic number
-        this.magicnumber = new byte[FileSpanningOutputStream.MAGIC_NUMER_LENGTH];
-        zippedinputstream.read(this.magicnumber);
-        // this.read(this.magicnumber);
-        Debug.trace(&quot;Opening stream to &quot; + volume + &quot; magicnr is &quot; + magicnumber);
-        // reset filepointer
-        filepointer = 0;
-    }
-
-    public FileSpanningInputStream(String volumename, int volumestotal) throws IOException
-    {
-        this(new File(volumename), volumestotal);
-    }
-
-    /**
-     * checks if the MagicNumber of this stream is valid. The stream has to be opened right before.
-     * 
-     * @return
-     * @throws IOException
-     */
-    private boolean isMagicNumberValid() throws IOException
-    {
-        Debug.trace(&quot;trying to read magic number&quot;);
-        boolean valid = false;
-        byte[] magicnumberofvolume = new byte[FileSpanningOutputStream.MAGIC_NUMER_LENGTH];
-        long oldfilepointer = this.filepointer;
-        // this.read(magicnumberofvolume);
-        this.zippedinputstream.read(magicnumberofvolume);
-        this.filepointer = oldfilepointer;
-        Debug.trace(&quot;MagicNr is &quot; + magicnumberofvolume);
-        if ((magicnumberofvolume != null) &amp;&amp; (this.magicnumber != null))
-        {
-            if (magicnumberofvolume.length != this.magicnumber.length)
-            {
-                // magicnumbers aren't valid
-                valid = false;
-            }
-            else
-            {
-                boolean errorfound = false;
-                // check if magicnumbers are identical
-                for (int i = 0; i &lt; magicnumberofvolume.length; i++)
-                {
-                    byte op1 = magicnumberofvolume[i];
-                    byte op2 = this.magicnumber[i];
-                    if (op1 != op2)
-                    {
-                        errorfound = true;
-                        break;
-                    }
-                }
-                valid = !errorfound;
-            }
-        }
-        return valid;
-    }
-
-    /**
-     * creates an inputstream to the next volume
-     * 
-     * @return true - an inputstream to the next volume has been created false - the last volume was
-     * reached
-     * @throws IOException
-     */
-    private boolean createInputStreamToNextVolume() throws IOException
-    {
-        currentvolumeindex++;
-        // have we reached the last volume?
-        if (currentvolumeindex &gt;= volumestotal)
-        {
-            Debug.trace(&quot;last volume reached.&quot;);
-            return false;
-        }
-        // the next volume name
-        String nextvolumename = volumename + &quot;.&quot; + currentvolumeindex;
-        Debug.trace(&quot;Trying to use next volume: &quot; + nextvolumename);
-        File nextvolumefile = new File(nextvolumename);
-        if (!nextvolumefile.exists())
-        {
-            currentvolumeindex--;
-            nextvolumenotfound = true;
-            Debug.trace(&quot;volume not found&quot;);
-            throw new VolumeNotFoundException(nextvolumename + &quot;was not found.&quot;, nextvolumename);
-        }
-        Debug.trace(&quot;next volume found.&quot;);
-        // try to open new stream to next volume
-        fileinputstream = new FileInputStream(nextvolumefile);
-        zippedinputstream = new GZIPInputStream(fileinputstream);
-        // check magic number
-        if (!this.isMagicNumberValid())
-        {
-            currentvolumeindex--;
-            nextvolumenotfound = true;
-            Debug
-                    .trace(&quot;volume found, but magic number incorrect. Maybe not a volume of the same version.&quot;);
-            throw new CorruptVolumeException(nextvolumename
-                    + &quot;was found, but has magic number error. Maybe not the right version?&quot;,
-                    nextvolumename);
-        }
-        // everything fine
-        nextvolumenotfound = false;
-        return true;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.io.InputStream#available()
-     */
-    public int available() throws IOException
-    {
-        if (nextvolumenotfound)
-        {
-            createInputStreamToNextVolume();
-        }
-        // return fileinputstream.available();
-        return zippedinputstream.available();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.io.InputStream#close()
-     */
-    public void close() throws IOException
-    {
-        zippedinputstream.close();
-        fileinputstream.close();
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.io.InputStream#read()
-     */
-    public int read() throws IOException
-    {
-        if (nextvolumenotfound)
-        {
-            // the next volume was not found, so try to create a new input stream to next volume
-            createInputStreamToNextVolume();
-        }
-        int nextbyte = zippedinputstream.read();
-        filepointer++;
-        if (nextbyte == EOF)
-        {
-            // if end of file is reached, try to open InputStream to next volume
-            // close the inputstream
-            try
-            {
-                zippedinputstream.close();
-            }
-            catch (Exception e)
-            {
-                // do nothing
-            }
-
-            if (createInputStreamToNextVolume())
-            {
-                // try to read next byte
-                nextbyte = zippedinputstream.read();
-                filepointer++;
-            }
-        }
-        return nextbyte;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.io.InputStream#read(byte[], int, int)
-     */
-    public int read(byte[] b, int off, int len) throws IOException
-    {
-        if (nextvolumenotfound)
-        {
-            // the next volume was not found, so try to create a new input stream to next volume
-            createInputStreamToNextVolume();
-        }
-        int bytesread = zippedinputstream.read(b, off, len);
-        filepointer += bytesread;
-        if (bytesread == EOF)
-        {
-            filepointer++; // bytesread was -1;
-            System.out.println(&quot;EOF reached.&quot;);
-            // close the inputstream
-            try
-            {
-                zippedinputstream.close();
-            }
-            catch (Exception e)
-            {
-                // do nothing
-            }
-            // try to open next volume
-            if (createInputStreamToNextVolume())
-            {
-                // try to read next bytes
-                Debug.trace(&quot;next volume opened, continuing read&quot;);
-                bytesread = zippedinputstream.read(b, off, len);
-                filepointer += bytesread;
-                // System.out.println(&quot;read into buffer: &quot; + bytesread + &quot; Bytes&quot;);
-            }
-        }
-        // System.out.println(&quot;return from read into buffer: &quot; + bytesread + &quot; Bytes&quot;);
-        return bytesread;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.io.InputStream#read(byte[])
-     */
-    public int read(byte[] b) throws IOException
-    {
-        return this.read(b, 0, b.length);
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see java.io.InputStream#skip(long)
-     */
-    public long skip(long n) throws IOException
-    {
-        if (nextvolumenotfound)
-        {
-            // the next volume was not found, so try to create a new input stream to next volume
-            createInputStreamToNextVolume();
-        }
-        long bytesskipped = 0;
-        byte[] buffer = new byte[4096];
-        try
-        {
-            while (bytesskipped &lt; n)
-            {
-                int maxBytes = (int) Math.min(n - bytesskipped, buffer.length);
-
-                int bytesInBuffer = this.read(buffer, 0, maxBytes);
-                if (bytesInBuffer == -1)
-                    throw new IOException(&quot;Unexpected end of stream (installer corrupted?)&quot;);
-
-                bytesskipped += bytesInBuffer;
-            }
-        }
-        catch (VolumeNotFoundException vnfe)
-        {
-            vnfe.setAlreadyskippedbytes(bytesskipped);
-            throw vnfe;
-        }
-        return bytesskipped;
-    }
-
-    /**
-     * Returns the name of the volume
-     * 
-     * @return the name of the volume
-     */
-    public String getVolumename()
-    {
-        return volumename;
-    }
-
-    /**
-     * Sets the volumename
-     * 
-     * @param volumename
-     */
-    public void setVolumename(String volumename)
-    {
-        Debug.trace(&quot;new volumename: &quot; + volumename);
-        // try to get the volumename from the given volume file
-        // the first volume has no suffix, additional volumes have a .INDEX# suffix
-        String volumesuffix = &quot;.&quot; + currentvolumeindex;
-        String nextvolumesuffix = &quot;.&quot; + (currentvolumeindex + 1);
-        if (volumename.endsWith(volumesuffix))
-        {
-            this.volumename = volumename.substring(0, volumename.lastIndexOf(volumesuffix));
-        }
-        else if (volumename.endsWith(nextvolumesuffix))
-        {
-            this.volumename = volumename.substring(0, volumename.lastIndexOf(nextvolumesuffix));
-        }
-        else
-        {
-            this.volumename = volumename;
-        }
-        Debug.trace(&quot;Set volumename to: &quot; + this.volumename);
-    }
-
-    /**
-     * Returns the current position in the file. Notice: this is the global position in all volumes.
-     * 
-     * @return the current position in file.
-     */
-    public long getFilepointer()
-    {
-        return filepointer;
-    }
-
-}
\ No newline at end of file

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/io/FileSpanningInputStream.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/io/FileSpanningInputStream.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/DataCheckPanel.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/panels/DataCheckPanel.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/DataCheckPanel.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,167 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- *
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- *
- * Copyright 2002 Jan Blok
- *
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * This panel written by Hal Vaughan
- * <A HREF="http://thresholddigital.com">http://thresholddigital.com</A>
- * <A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">hal at thresholddigital.com</A>
- * 
- * And updated by Fabrice Mirabile
- * <A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">miraodb at hotmail.com</A>
- */
-
-package com.izforge.izpack.panels;
-
-import java.util.Enumeration;
-import java.util.List;
-import java.util.Properties;
-
-import javax.swing.BoxLayout;
-import javax.swing.JEditorPane;
-import javax.swing.JLabel;
-import javax.swing.JScrollPane;
-
-import com.izforge.izpack.installer.InstallData;
-import com.izforge.izpack.installer.InstallerFrame;
-import com.izforge.izpack.installer.IzPanel;
-import com.izforge.izpack.Pack;
-
-/**
- * 
- * DataCheckPanel: Provide a lot of debugging information.  Print a simple header of our 
- * instance number and a line to separate output from other instances, then print all
- * the InstallData variables and list all the packs and selected packs.  I hope this will
- * be expanded by others to provide needed debugging information by those developing panels
- * for IzPack.
- * @author Hal Vaughan
- * @author Fabrice Mirabile
- */
-public class DataCheckPanel extends IzPanel
-{
-	
-	private static final long serialVersionUID = 3257848774955905587L;
-	
-	static int instanceCount = 0;
-	
-	protected int instanceNumber = 0;
-	
-	private InstallData iData;
-	
-	JEditorPane staticText;
-			
-	/**
-	 * The constructor.
-	 *
-	 * @param parent The parent.
-	 * @param id The installation data.
-	 */
-	public DataCheckPanel(InstallerFrame parent, InstallData id)
-	{
-		super(parent, id);
-		
-		iData = id;
-		instanceNumber = instanceCount++;
-		
-		String sInfo = &quot;Debugging data.  All InstallData variables and all packs (selected packs are marked).&quot;;
-		BoxLayout bLayout = new BoxLayout(this, BoxLayout.Y_AXIS);
-		setLayout (bLayout);
-//		setLayout(new GridLayout(3,1));
-		JLabel lInfo = new JLabel(sInfo);
-		add(lInfo);
-        staticText = new JEditorPane();
-        staticText.setEditable(false);
-        JScrollPane scrollText = new JScrollPane(staticText);
-        add(new JLabel(&quot;  &quot;));
-        add(scrollText);
-		
-	}
-	
-	/**
-	 * When the panel is made active, call the printDebugInfo method.
-     * 
-	 * @see com.izforge.izpack.installer.IzPanel#panelActivate()
-     * @param none
-     * @return void
-	 */
-	public void panelActivate()
-	{
-        printDebugInfo();
-    }
-	
-    /**
-     * Get and return the list of pack names.
-     * 
-     * @param packList
-     * @return String
-     */
-	private String getPackNames(List packList)
-	{
-		int i;
-		String pStatus;
-		String sOutput = &quot;&quot;;
-		Pack iPack;
-		for (i = 0; i &lt; packList.size(); i++)
-		{
-			iPack = (Pack) packList.get(i);
-			if (iData.selectedPacks.indexOf(iPack) != -1)
-				pStatus = &quot;Selected&quot;;
-			else
-				pStatus = &quot;Unselected&quot;;
-			sOutput = sOutput + &quot;\t&quot; + i + &quot;: &quot; + iPack.name + &quot; (&quot; + pStatus + &quot;)\n&quot;;
-		}
-		return sOutput;
-	}
-
-    /**
-     * Print list of variables names and value, as well as the list
-     * of packages and their status (selected or not).
-     * 
-     * @param none
-     * @return void
-     */
-    private void printDebugInfo()
-    {
-        int i = 0;
-        String sInfo = &quot;InstallData Variables:\n&quot;;
-        System.out.println(&quot;------------------------Data Check Panel Instance &quot; + 
-                instanceNumber + &quot;------------------------&quot;);
-        System.out.println(&quot;InstallData Variables:&quot;);
-        Properties varList = iData.getVariables();
-        String[] alphaName = new String[varList.size()];
-        Enumeration varNames = varList.propertyNames();
-        while (varNames.hasMoreElements())
-            alphaName[i++] = (String) varNames.nextElement();
-        java.util.Arrays.sort(alphaName);
-        for (i = 0; i &lt; alphaName.length; i++)
-            sInfo = sInfo + &quot;\tName: &quot; + alphaName[i] + &quot;, Value: &quot; + varList.getProperty(alphaName[i]) + &quot;\n&quot;;
-        sInfo = sInfo + &quot;\nAvailable Packs: \n&quot; + getPackNames(iData.allPacks) + &quot;\n&quot;;
-        System.out.println(sInfo);
-        staticText.setText(sInfo);
-    }
-
-	/**
-	 * By nature, always true.
-	 *
-	 * @return True
-	 */
-	public boolean isValidated()
-	{
-		return true;
-	}
-}

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/DataCheckPanel.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/panels/DataCheckPanel.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/PasswordGroup.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/panels/PasswordGroup.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/PasswordGroup.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,316 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Copyright 2003 Elmar Grom
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *     
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.izforge.izpack.panels;
-
-import com.izforge.izpack.installer.InstallData;
-import java.util.List;
-import java.util.Map;
-import java.util.Vector;
-
-import javax.swing.JPasswordField;
-
-/*---------------------------------------------------------------------------*/
-/**
- * This class can be used to manage multiple related password fields. This is used in the
- * &lt;code&gt;UserInputPanel&lt;/code&gt; to manage communication with the validator and processor for
- * password fields.
- * 
- * @see com.izforge.izpack.panels.UserInputPanel
- * 
- * @version 0.0.1 / 2/22/03
- * @author Elmar Grom
- */
-/*---------------------------------------------------------------------------*/
-public class PasswordGroup implements ProcessingClient
-{
-
-    // ------------------------------------------------------------------------
-    // Variable Declarations
-    // ------------------------------------------------------------------------
-    private Vector fields = new Vector();
-
-    private List validatorContainers = null;
-//  private Validator validator = null;
-//  private boolean hasParams = false;
-//  private Map validatorParams = null;
-    private Processor processor = null;
-
-    private int currentValidator = 0;
-
-    private InstallData idata;
-
-    /*--------------------------------------------------------------------------*/
-    /**
-     * Creates a password group to manage one or more password fields.
-     * 
-     * @param validator A string that specifies a class that provides a password validation service.
-     * The class must implement the &lt;code&gt;Validator&lt;/code&gt; interface. If an attempt to instantiate
-     * this class fails, no validation will be performed.
-     * @param processor A string that specifies a class that provides a password processing service,
-     * such as password encryption. The class must implement the &lt;code&gt;Processor&lt;/code&gt; interface.
-     * If an attempt to instantiate this class fails, no processing will be performed. Insted the
-     * contents of the first field will be returned.
-     */
-    /*--------------------------------------------------------------------------*/
-    public PasswordGroup(InstallData idata, List validatorContainers, String processor)
-    {
-        // ----------------------------------------------------
-        // attempt to create an instance of the Validator
-        // ----------------------------------------------------
-        try
-        {
-            this.idata = idata;
-//      this.validator = (Validator) Class.forName(validator).newInstance();
-            this.validatorContainers = validatorContainers;
-//      this.validatorParams = validatorParams;
-//      if (validatorParams != null) {
-//        if (validatorParams.size() &gt; 0) {
-//          hasParams = true;
-//        }
-//      }
-        } catch (Throwable exception)
-        {
-            this.validatorContainers = null;
-        }
-
-        // ----------------------------------------------------
-        // attempt to create an instance of the Processor
-        // ----------------------------------------------------
-        try
-        {
-            this.processor = (Processor) Class.forName(processor).newInstance();
-        } catch (Throwable exception)
-        {
-            this.processor = null;
-        }
-    }
-
-    public InstallData getIdata()
-    {
-        return idata;
-    }
-
-    /*--------------------------------------------------------------------------*/
-    /**
-     * Returns the number of sub-fields.
-     * 
-     * @return the number of sub-fields
-     */
-    /*--------------------------------------------------------------------------*/
-    public int getNumFields()
-    {
-        return (fields.size());
-    }
-
-    /*--------------------------------------------------------------------------*/
-    /**
-     * Returns the contents of the field indicated by &lt;code&gt;index&lt;/code&gt;.
-     * 
-     * @param index the index of the sub-field from which the contents is requested.
-     * 
-     * @return the contents of the indicated sub-field.
-     * 
-     * @exception IndexOutOfBoundsException if the index is out of bounds.
-     */
-    /*--------------------------------------------------------------------------*/
-    public String getFieldContents(int index) throws IndexOutOfBoundsException
-    {
-        if ((index &lt; 0) || (index &gt;= fields.size()))
-        {
-            throw (new IndexOutOfBoundsException());
-        }
-
-        String contents = new String(((JPasswordField) fields.elementAt(index)).getPassword());
-        return (contents);
-    }
-
-    /*--------------------------------------------------------------------------*/
-    /**
-     * Adds a &lt;code&gt;JPasswordField&lt;/code&gt; to the group of fields being managed by this object.
-     * 
-     * @param field &lt;code&gt;JPasswordField&lt;/code&gt; to add
-     */
-    /*--------------------------------------------------------------------------*/
-    public void addField(JPasswordField field)
-    {
-        if (field != null)
-        {
-            fields.add(field);
-        }
-    }
-
-    /*--------------------------------------------------------------------------*/
-    /**
-     * This method validates the group content. Validating is performed through a user supplied
-     * service class that provides the validation rules.
-     * 
-     * @return &lt;code&gt;true&lt;/code&gt; if the validation passes or no implementation of a validation
-     * rule exists. Otherwise &lt;code&gt;false&lt;/code&gt; is returned.
-     */
-    /*--------------------------------------------------------------------------*/
-    public boolean validateContents(int i)
-    {
-        boolean returnValue = true;
-        try
-        {
-            currentValidator = i;
-            ValidatorContainer container = getValidatorContainer(i);
-            Validator validator = container.getValidator();
-            if (validator != null)
-            {
-                returnValue = validator.validate(this);
-            }
-        } catch (Exception e)
-        {
-            System.out.println(&quot;validateContents(&quot; + i + &quot;) failed: &quot; + e);
-        // just return true
-        }
-        return returnValue;
-    }
-
-    public String getValidatorMessage(int i)
-    {
-        String returnValue = null;
-        try
-        {
-            ValidatorContainer container = getValidatorContainer(i);
-            if (container != null)
-            {
-                returnValue = container.getMessage();
-            }
-        } catch (Exception e)
-        {
-            System.out.println(&quot;getValidatorMessage(&quot; + i + &quot;) failed: &quot; + e);
-        // just return true
-        }
-        return returnValue;
-    }
-
-    public int validatorSize()
-    {
-        int size = 0;
-        if (validatorContainers != null)
-        {
-            size = validatorContainers.size();
-        }
-        return size;
-    }
-
-    public ValidatorContainer getValidatorContainer()
-    {
-        return getValidatorContainer(currentValidator);
-    }
-
-    public ValidatorContainer getValidatorContainer(int i)
-    {
-        ValidatorContainer container = null;
-        try
-        {
-            container = (ValidatorContainer) validatorContainers.get(i);
-        } catch (Exception e)
-        {
-            container = null;
-        }
-        return container;
-    }
-
-    public boolean hasParams()
-    {
-        return hasParams(currentValidator);
-    }
-
-    public boolean hasParams(int i)
-    {
-        boolean returnValue = false;
-        try
-        {
-            ValidatorContainer container = getValidatorContainer(i);
-            if (container != null)
-            {
-                returnValue = container.hasParams();
-            }
-        } catch (Exception e)
-        {
-            System.out.println(&quot;hasParams(&quot; + i + &quot;) failed: &quot; + e);
-        // just return true
-        }
-        return returnValue;
-    }
-
-    public Map getValidatorParams()
-    {
-        return getValidatorParams(currentValidator);
-    }
-
-    public Map getValidatorParams(int i)
-    {
-        Map returnValue = null;
-        try
-        {
-            ValidatorContainer container = getValidatorContainer(i);
-            if (container != null)
-            {
-                returnValue = container.getValidatorParams();
-            }
-        } catch (Exception e)
-        {
-            System.out.println(&quot;getValidatorParams(&quot; + i + &quot;) failed: &quot; + e);
-        // just return true
-        }
-        return returnValue;
-    }
-
-    // This method was added to support changes to ProcessingClient interface
-    // it's use is non-deterministic in the newly implemented text validators.
-    public String getText()
-    {
-        return getValidatorMessage(currentValidator);
-    }
-
-    /*--------------------------------------------------------------------------*/
-    /**
-     * Returns the password. If a processing service class was supplied it will be used to process
-     * the password before it is returned, otherwise the content of the first field will be
-     * returned.
-     * 
-     * @return the password
-     */
-    /*--------------------------------------------------------------------------*/
-    public String getPassword()
-    {
-        if (processor != null)
-        {
-            return (processor.process(this));
-        } else
-        {
-            String contents = &quot;&quot;;
-
-            if (fields.size() &gt; 0)
-            {
-                contents = new String(((JPasswordField) fields.elementAt(0)).getPassword());
-            }
-
-            return (contents);
-        }
-    }
-
-}
-/*---------------------------------------------------------------------------*/

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/PasswordGroup.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/panels/PasswordGroup.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/TextInputField.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/panels/TextInputField.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/TextInputField.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,200 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- * 
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- * 
- * Copyright 2008 Piotr Skowronek
- * 
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *     
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.izforge.izpack.panels;
-
-import java.util.Map;
-
-import javax.swing.JComponent;
-import javax.swing.JTextField;
-
-import com.izforge.izpack.util.Debug;
-
-/*---------------------------------------------------------------------------*/
-/**
- * This class is a wrapper for JTextField to allow field validation.
- * Based on RuleInputField.
- * 
- * @author Piotr Skowronek
- */
-/*---------------------------------------------------------------------------*/
-public class TextInputField extends JComponent implements ProcessingClient
-{
-
-    /**
-     * 
-     */
-    private static final long serialVersionUID = 8611515659787697087L;
-
-    /**
-     * Validator parameters.
-     */
-    private Map validatorParams;
-
-    /**
-     * Holds an instance of the &lt;code&gt;Validator&lt;/code&gt; if one was specified and available
-     */
-    private Validator validationService;
-
-    /**
-     * This composite can only contain one component ie JTextField
-     */
-    private JTextField field;
-    
-    /**
-     * Do we have parameters for validator?
-     */
-    private boolean hasParams = false;
-
-    /*--------------------------------------------------------------------------*/
-    /**
-     * Constructs a text input field.
-     *
-     * @param set A default value for field.
-     * @param size The size of the field.
-     * @param validator A string that specifies a class to perform validation services. The string
-     * must completely identify the class, so that it can be instantiated. The class must implement
-     * the &lt;code&gt;RuleValidator&lt;/code&gt; interface. If an attempt to instantiate this class fails, no
-     * validation will be performed.
-     * @param validatorParams validator parameters.
-     */
-    /*--------------------------------------------------------------------------*/
-    public TextInputField(String set, int size, String validator, Map validatorParams) {
-        this(set, size, validator);
-        this.validatorParams = validatorParams;
-        this.hasParams = true;
-    }
-    
-
-    /*--------------------------------------------------------------------------*/
-    /**
-     * Constructs a text input field.
-     *
-     * @param set A default value for field.
-     * @param suze The size of the field.
-     * @param validator A string that specifies a class to perform validation services. The string
-     * must completely identify the class, so that it can be instantiated. The class must implement
-     * the &lt;code&gt;RuleValidator&lt;/code&gt; interface. If an attempt to instantiate this class fails, no
-     * validation will be performed.
-     */
-    /*--------------------------------------------------------------------------*/
-    public TextInputField(String set, int size, String validator)
-    {
-        // ----------------------------------------------------
-        // attempt to create an instance of the Validator
-        // ----------------------------------------------------
-        try
-        {
-            if (validator != null)
-            {
-                validationService = (Validator) Class.forName(validator).newInstance();
-            }
-        }
-        catch (Throwable exception)
-        {
-            validationService = null;            
-            Debug.trace(exception);
-        }
-        
-        com.izforge.izpack.gui.FlowLayout layout = new com.izforge.izpack.gui.FlowLayout();
-        layout.setAlignment(com.izforge.izpack.gui.FlowLayout.LEADING);
-        layout.setVgap(0);
-        setLayout(layout);
-        
-        // ----------------------------------------------------
-        // construct the UI element and add it to the composite
-        // ----------------------------------------------------
-        field = new JTextField(set, size);
-        field.setCaretPosition(0);
-        add(field);
-    }
-
-
-    /*--------------------------------------------------------------------------*/
-    /**
-     * Returns the validator parameters, if any. The caller should check for the existence of
-     * validator parameters via the &lt;code&gt;hasParams()&lt;/code&gt; method prior to invoking this method.
-     * 
-     * @return a java.util.Map containing the validator parameters.
-     */
-    public Map getValidatorParams()
-    {
-        return validatorParams;
-    }
-
-    /*---------------------------------------------------------------------------*/
-    /**
-     * Returns the field contents, assembled acording to the encryption and separator rules.
-     * 
-     * @return the field contents
-     */
-    /*--------------------------------------------------------------------------*/
-    public String getText()
-    {
-        return (field.getText());
-    }
-
-    // javadoc inherited
-    public void setText(String value)
-    {
-        field.setText(value);
-    }
-
-    // javadoc inherited
-    public String getFieldContents(int index) {
-        return field.getText();
-    }
-
-    // javadoc inherited
-    public int getNumFields() {
-        // We've got only one field
-        return 1;
-    }
-
-    /*--------------------------------------------------------------------------*/
-    /**
-     * This method validates the field content. Validating is performed through a user supplied
-     * service class that provides the validation rules.
-     * 
-     * @return &lt;code&gt;true&lt;/code&gt; if the validation passes or no implementation of a validation
-     * rule exists. Otherwise &lt;code&gt;false&lt;/code&gt; is returned.
-     */
-    /*--------------------------------------------------------------------------*/
-    public boolean validateContents()
-    {
-        if (validationService != null)
-        {
-            return (validationService.validate(this));
-        }
-        else
-        {
-            return (true);
-        }
-    }
-
-    // javadoc inherited
-    public boolean hasParams() {
-        return hasParams;
-    }
-    
-    // ----------------------------------------------------------------------------
-}
-/*---------------------------------------------------------------------------*/

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/panels/TextInputField.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/panels/TextInputField.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/util/FileUtil.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/util/FileUtil.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/util/FileUtil.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,229 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- *
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- *
- * Copyright 2005 Marc Eppelmann
- *
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.izforge.izpack.util;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileReader;
-import java.io.FilenameFilter;
-import java.io.IOException;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-
-import java.net.URL;
-
-
-/**
- * Provides general global file utility methods
- *
- * @author marc.eppelmann
- */
-public class FileUtil
-{
-  //~ Constructors ***********************************************************************
-
-  /**
-   * Creates a new FileUtil object.
-   */
-  public FileUtil(){}
-
-  //~ Methods ****************************************************************************
-
-  /** 
-   * Gets the content from a File as StringArray List.
-   *
-   * @param fileName A file to read from.
-   *
-   * @return List of individual line of the specified file. List may be empty but not
-   *         null.
-   *
-   * @throws IOException
-   */
-  public static ArrayList getFileContent( String fileName )
-                                  throws IOException
-  {
-    ArrayList result = new ArrayList();
-
-    File      aFile = new File( fileName );
-
-    if( ! aFile.isFile() )
-    {
-      //throw new IOException( fileName + &quot; is not a regular File&quot; );
-      return result; // None
-    }
-
-    BufferedReader reader = null;
-
-    try
-    {
-      reader = new BufferedReader( new FileReader( aFile ) );
-    }
-    catch( FileNotFoundException e1 )
-    {
-      // TODO handle Exception
-      e1.printStackTrace();
-
-      return result;
-    }
-
-    String aLine = null;
-
-    while( ( aLine = reader.readLine() ) != null )
-    {
-      result.add( aLine + &quot;\n&quot; );
-    }
-
-    reader.close();
-
-    return result;
-  }
-
-  /** 
-   * Searches case sensitively, and returns true if the given SearchString occurs in the
-   * first File with the given Filename.
-   *
-   * @param aFileName A files name
-   * @param aSearchString the string search for
-   *
-   * @return true if found in the file otherwise false
-   */
-  public static boolean fileContains( String aFileName, String aSearchString )
-  {
-    return ( fileContains( aFileName, aSearchString, false ) );
-  }
-
-  /** 
-   * Tests if the given File contains the given Search String
-   *
-   * @param aFileName A files name
-   * @param aSearchString the String to search for
-   * @param caseInSensitiveSearch If false the Search is casesensitive
-   *
-   * @return true if found in the file otherwise false
-   */
-  public static boolean fileContains( String aFileName, String aSearchString,
-                                      boolean caseInSensitiveSearch )
-  {
-    boolean result = false;
-
-    String  searchString = caseInSensitiveSearch
-            ? aSearchString.toLowerCase() : aSearchString;
-
-    ArrayList fileContent = new ArrayList();
-
-    try
-    {
-      fileContent = getFileContent( aFileName );
-    }
-    catch( IOException e )
-    {
-      // TODO handle Exception
-      e.printStackTrace(  );
-    }
-
-    Iterator linesIter = fileContent.iterator(  );
-
-    while( linesIter.hasNext() )
-    {
-      String currentline = (String) linesIter.next(  );
-
-      if(caseInSensitiveSearch )
-      {
-        currentline = currentline.toLowerCase(  );
-      }
-
-      if( currentline.indexOf( searchString ) &gt; -1 )
-      {
-        result = true;
-
-        break;
-      }
-    }
-
-    return result;
-  }
-  
-  /**
-   * Gets file date and time.
-   *
-   * @param   url     The URL of the file for which date and time will be returned.
-   * @return  Returns long value which is the date and time of the file. If any error
-   *          occures returns -1 (=no file date and time available).
-   * @author  Ari Voutilainen, ari(dot)voutilainen(at) iki(dot)fi
-   */
-  public static long getFileDateTime(URL url)
-  {
-      if (url==null)
-          return -1;
-
-      String fileName = url.getFile();
-      if (fileName.charAt(0) == '/' || fileName.charAt(0) == '\\')
-          fileName = fileName.substring(1, fileName.length());
-
-      try
-      {
-          File file = new File(fileName);
-          // File name must be a file or a directory.
-          if (!file.isDirectory() &amp;&amp; !file.isFile())
-          {
-              return -1;
-          }
-
-          return file.lastModified();
-      }
-      catch (java.lang.Exception e)
-      {   // Trap all Exception based exceptions and return -1.
-          return -1;
-      }
-  }
-  
-  public static String[] getFileNames(String dirPath) throws Exception
-  {
-      return getFileNames(dirPath, null);
-  }
-  
-  public static String[] getFileNames(String dirPath, FilenameFilter fileNameFilter) throws Exception
-  {
-      String fileNames[] = null;
-      File dir = new File(dirPath);
-      if (dir.isDirectory())
-      {
-          if (fileNameFilter != null)
-          {
-              fileNames = dir.list(fileNameFilter);
-          }
-          else
-          {
-              fileNames = dir.list();
-          }
-      }
-      return fileNames;
-  }
-
-  /** 
-   * Test main
-   *
-   * @param args
-   */
-  public static void main( String[] args ){}
-}

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/util/FileUtil.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/util/FileUtil.java)

Deleted: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/util/OsConstraint.java
===================================================================
--- izpack-src/trunk/src/lib/com/izforge/izpack/util/OsConstraint.java	2008-02-11 20:06:52 UTC (rev 2042)
+++ izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/util/OsConstraint.java	2008-02-12 10:03:02 UTC (rev 2046)
@@ -1,348 +0,0 @@
-/*
- * IzPack - Copyright 2001-2008 Julien Ponge, All Rights Reserved.
- *
- * <A HREF="https://izpack.github.io/">https://izpack.github.io/</A>
- * <A HREF="http://izpack.codehaus.org/">http://izpack.codehaus.org/</A>
- *
- * Copyright 2002 Olexij Tkatchenko
- *
- * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     <A HREF="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</A>
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.izforge.izpack.util;
-
-
-import net.n3.nanoxml.XMLElement;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-
-/**
- * Encapsulates OS constraints specified on creation time and allows to check them against the
- * current OS.
- * &lt;p/&gt;
- * For example, this is used for &amp;lt;executable&amp;gt;s to check whether the executable is suitable for
- * the current OS.
- *
- * @author Olexij Tkatchenko &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/izpack-changes">ot at parcs.de</A>&gt;
- */
-public class OsConstraint
-        implements java.io.Serializable
-{
-    //~ Static variables/initializers &#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;
-
-    /**
-     *
-     */
-    private static final long serialVersionUID = 3762248660406450488L;
-
-    //~ Instance variables &#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;
-
-    /**
-     * OS architecture from java system properties
-     */
-    private String arch;
-
-    /**
-     * The OS family
-     */
-    private String family;
-
-    /**
-     * JRE version used for installation
-     */
-    private String jre;
-
-    /**
-     * OS name from java system properties
-     */
-    private String name;
-
-    /**
-     * OS version from java system properties
-     */
-    private String version;
-
-    //~ Constructors &#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;
-
-    /**
-     * Constructs a new instance. Please remember, MacOSX belongs to Unix family.
-     *
-     * @param family  The OS family (unix, windows or mac).
-     * @param name    The exact OS name.
-     * @param version The exact OS version (check property &lt;code&gt;os.version&lt;/code&gt; for values).
-     * @param arch    The machine architecture (check property &lt;code&gt;os.arch&lt;/code&gt; for values).
-     * @param jre     The Java version used for installation (check property &lt;code&gt;java.version&lt;/code&gt; for values).
-     */
-    public OsConstraint(String family,
-                        String name,
-                        String version,
-                        String arch,
-                        String jre)
-    {
-        this.family = (family != null)
-                ? family.toLowerCase()
-                : null;
-        this.name = (name != null)
-                ? name.toLowerCase()
-                : null;
-        this.version = (version != null)
-                ? version.toLowerCase()
-                : null;
-        this.arch = (arch != null)
-                ? arch.toLowerCase()
-                : null;
-        this.jre = (jre != null)
-                ? jre.toLowerCase()
-                : null;
-    }    // end OsConstraint()
-
-
-    /**
-     * Creates a new instance. Please remember, MacOSX belongs to Unix family.
-     *
-     * @param family  The OS family (unix, windows or mac).
-     * @param name    The exact OS name.
-     * @param version The exact OS version (check property &lt;code&gt;os.version&lt;/code&gt; for values).
-     * @param arch    The machine architecture (check property &lt;code&gt;os.arch&lt;/code&gt; for values).
-     */
-    public OsConstraint(String family,
-                        String name,
-                        String version,
-                        String arch)
-    {
-        this(family, name, version, arch, null);
-    }    // end OsConstraint()
-
-    //~ Methods &#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;
-
-    /**
-     * Matches OS specification in this class against current system properties.
-     *
-     * @return Description of the Return Value
-     */
-    public boolean matchCurrentSystem()
-    {
-        boolean match = true;
-        String osName = System.getProperty(&quot;os.name&quot;).toLowerCase();
-
-
-        if ((arch != null) &amp;&amp; (arch.length() != 0))
-        {
-            match = System.getProperty(&quot;os.arch&quot;).toLowerCase().equals(arch);
-        }    // end if
-
-        if (match &amp;&amp; (version != null) &amp;&amp; (version.length() != 0))
-        {
-            match = System.getProperty(&quot;os.version&quot;).toLowerCase().equals(version);
-        }    // end if
-
-        if (match &amp;&amp; (name != null) &amp;&amp; (name.length() != 0))
-        {
-            match = osName.equals(name);
-        }    // end if
-
-        if (match &amp;&amp; (family != null))
-        {
-            if (&quot;windows&quot;.equals(family))
-            {
-                match = OsVersion.IS_WINDOWS;
-            }    // end if
-            else if (&quot;mac&quot;.equals(family) || &quot;osx&quot;.equals(family))
-            {
-                match = OsVersion.IS_OSX;
-            }    // end else if
-            else if (&quot;unix&quot;.equals(family))
-            {
-                match = OsVersion.IS_UNIX;
-            }    // end else if
-        }    // end if
-
-        if (match &amp;&amp; (jre != null) &amp;&amp; (jre.length() &gt; 0))
-        {
-            match = System.getProperty(&quot;java.version&quot;).toLowerCase().startsWith(jre);
-        }    // end if
-
-        return match
-                &amp;&amp; ((family != null) || (name != null) || (version != null) || (arch != null) || (jre != null));
-    }    // end matchCurrentSystem()
-
-
-    /**
-     * Extract a list of OS constraints from given element.
-     *
-     * @param element parent XMLElement
-     * @return List of OsConstraint (or empty List if no constraints found)
-     */
-    public static List getOsList(XMLElement element)
-    {
-        // get os info on this executable
-        ArrayList osList = new ArrayList();
-        Iterator osIterator = element.getChildrenNamed(&quot;os&quot;).iterator();
-
-
-        while (osIterator.hasNext())
-        {
-            XMLElement os = (XMLElement) osIterator.next();
-
-
-            osList.add(new OsConstraint(os.getAttribute(&quot;family&quot;,
-                    null),
-                    os.getAttribute(&quot;name&quot;,
-                            null),
-                    os.getAttribute(&quot;version&quot;,
-                            null),
-                    os.getAttribute(&quot;arch&quot;,
-                            null),
-                    os.getAttribute(&quot;jre&quot;,
-                            null)));
-        }    // end while
-
-        // backward compatibility: still support os attribute
-        String osattr = element.getAttribute(&quot;os&quot;);
-
-
-        if ((osattr != null) &amp;&amp; (osattr.length() &gt; 0))
-        {
-            // add the &quot;os&quot; attribute as a family constraint
-            osList.add(new OsConstraint(osattr,
-                    null,
-                    null,
-                    null,
-                    null));
-        }    // end if
-
-        return osList;
-    }    // end getOsList()
-
-
-    /**
-     * Helper function: Scan a list of OsConstraints for a match.
-     *
-     * @param constraint_list List of OsConstraint to check
-     * @return true if one of the OsConstraints matched the current system or constraint_list is
-     *         null (no constraints), false if none of the OsConstraints matched
-     */
-    public static boolean oneMatchesCurrentSystem(List constraint_list)
-    {
-        if (constraint_list == null)
-        {
-            return true;
-        }    // end if
-
-        Iterator constraint_it = constraint_list.iterator();
-
-        // no constraints at all - matches!
-        if (!constraint_it.hasNext())
-        {
-            return true;
-        }    // end if
-
-        while (constraint_it.hasNext())
-        {
-            OsConstraint osc = (OsConstraint) constraint_it.next();
-
-
-            Debug.trace(&quot;checking if os constraints &quot; + osc + &quot; match current OS&quot;);
-
-            // check for match
-            if (osc.matchCurrentSystem())
-            {
-                Debug.trace(&quot;matched current OS.&quot;);
-
-                return true;    // bail out on first match
-            }    // end if
-        }    // end while
-
-        Debug.trace(&quot;no match with current OS!&quot;);
-
-        // no match found
-        return false;
-    }    // end oneMatchesCurrentSystem()
-
-
-    /**
-     * Helper function: Check whether the given XMLElement is &quot;suitable&quot; for the current OS.
-     *
-     * @param el The XMLElement to check for OS constraints.
-     * @return true if there were no OS constraints or the constraints matched the current OS.
-     */
-    public static boolean oneMatchesCurrentSystem(XMLElement el)
-    {
-        return oneMatchesCurrentSystem(getOsList(el));
-    }    // end oneMatchesCurrentSystem()
-
-
-    public void setFamily(String f)
-    {
-        family = f.toLowerCase();
-    }    // end setFamily()
-
-
-    public String getFamily()
-    {
-        return family;
-    }    // end getFamily()
-
-
-    public void setName(String n)
-    {
-        name = n.toLowerCase();
-    }    // end setName()
-
-
-    public String getName()
-    {
-        return name;
-    }    // end getName()
-
-    public void setVersion(String v)
-    {
-        version = v.toLowerCase();
-    }    // end setVersion()
-
-
-    public String getVersion()
-    {
-        return version;
-    }    // end getVersion()
-
-
-    public void setArch(String a)
-    {
-        arch = a.toLowerCase();
-    }    // end setArch()
-
-
-    public String getArch()
-    {
-        return arch;
-    }    // end getArch()
-
-    public String toString()
-    {
-        StringBuffer retval = new StringBuffer();
-
-
-        retval.append(&quot;[Os &quot;);
-        retval.append(&quot; family &quot;).append(family);
-        retval.append(&quot; name &quot;).append(name);
-        retval.append(&quot; version &quot;).append(version);
-        retval.append(&quot; arch &quot;).append(arch);
-        retval.append(&quot; jre &quot;).append(jre);
-        retval.append(&quot; ]&quot;);
-
-        return retval.toString();
-    }    // end toString()
-}    // end OsConstraint

Copied: izpack-src/tags/3.11.0/src/lib/com/izforge/izpack/util/OsConstraint.java (from rev 2043, izpack-src/trunk/src/lib/com/izforge/izpack/util/OsConstraint.java)

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000791.html">[izpack-changes] r2045 - izpack-src/trunk/src/dist-files
</A></li>
	<LI>Next message: <A HREF="000793.html">[izpack-changes] r2047 - izpack-utils/tags
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#792">[ date ]</a>
              <a href="thread.html#792">[ thread ]</a>
              <a href="subject.html#792">[ subject ]</a>
              <a href="author.html#792">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/izpack-changes">More information about the izpack-changes
mailing list</a><br>
</body></html>
